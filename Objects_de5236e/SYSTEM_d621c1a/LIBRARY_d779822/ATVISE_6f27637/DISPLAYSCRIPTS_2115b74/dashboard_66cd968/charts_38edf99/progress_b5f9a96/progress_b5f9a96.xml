<?xml version="1.0" encoding="UTF-8"?>
<script>
  <metadata>
    <priority>0</priority>
  </metadata>
  <code><![CDATA[/**
 * Code for the chart progress resource tile object display
 * ----------------------------------------
 * This script serves as an interface that connects the with highcharts for progress charts
 */

/**
 * DECLARATION SECTION
 */
var BORDER_ID = "border";
var CHART_ID = document.getElementById(BORDER_ID).id.replace("_border", "");
var FO_ID = "fo_container";
var HIGHCHARTS_CONTAINER_ID = "dashboard_highcharts_container";
var MAIN_LABEL_ID = "main_label";
var SUB_LABEL_ID = "sub_label";
var statusEnabled = webMI.query["statusEnabled"];
var statusTrigger = webMI.query["statusTrigger"];
var statusIndication = webMI.query["statusIndication"];
var base = webMI.query["base"];
var unit = webMI.query["unit"] || "";
var nodeMin = webMI.query["nodeMin"];
var nodeMax = webMI.query["nodeMax"];
var min = webMI.query["min"];
var max = webMI.query["max"];
var postDecimals = parseInt(webMI.query["postDecimals"]);
var alarmIndication = webMI.query["alarmIndication"];
var textColor = webMI.query["textColor"];
var barColor = webMI.query["barColor"];
var barBackgroundColor = webMI.query["barBackgroundColor"];
var barBorderColor = webMI.query["barBorderColor"];
var barBorderWidth = webMI.query["barBorderWidth"];

var active = false;

/** external references **/
var activationTriggerHandling =
	typeof activationTriggerHandling !== "undefined" ? activationTriggerHandling : undefined;
var rightsHandling = typeof rightsHandling !== "undefined" ? rightsHandling : undefined;
var updateRunTimeNodeConfig = typeof updateRunTimeNodeConfig !== "undefined" ? updateRunTimeNodeConfig : undefined;
var _isGood = typeof _isGood !== "undefined" ? _isGood : undefined;
var _isBad = typeof _isBad !== "undefined" ? _isBad : undefined;
var _isUncertain = typeof _isUncertain !== "undefined" ? _isUncertain : undefined;

/**
 * Trigger setup
 */
var OPEN_DISPLAY_TRIGGER = "com.atvise.dashboard.openDisplay";
var SET_ACTIVE_TRIGGER = "com.atvise.dashboard.setActive";
var SET_INACTIVE_TRIGGER = "com.atvise.dashboard.setInactive";
var SET_STATUS_TRIGGER = "com.atvise.dashboard.setStatus";

/**
 * BASE SETUP
 */
var chartDiv = document.getElementById(HIGHCHARTS_CONTAINER_ID);

/** data **/
var runTimeNodeConfig = {
	base: { value: null, address: webMI.query["base"], paramValue: "", read: true, write: false, aggregate: false },
	min: { value: null, address: webMI.query["nodeMin"], paramValue: webMI.query["min"], read: true, write: false },
	max: { value: null, address: webMI.query["nodeMax"], paramValue: webMI.query["max"], read: true, write: false }
};

/**
 * RUNTIME SECTION
 */
if (typeof activationTriggerHandling === "function") activationTriggerHandling("com.atvise.setActive");

var notifierConfig = {
	rights: [
		{ nodeId: webMI.query["base"], rights: "read", disable: true, notify: false },
		{ nodeId: webMI.query["nodeMin"], rights: "read", disable: true, notify: false },
		{ nodeId: webMI.query["nodeMax"], rights: "read", disable: true, notify: false },
		{ nodeId: webMI.query["alarm"], rights: "alarmRead", disable: false, notify: true },
		{ nodeId: webMI.query["activeNode"], rights: "read", disable: true, notify: true }
	]
};

var rightsHandlingProperties = {
	activationNodeSet: { activeNode: webMI.query["activeNode"], activeValue: webMI.query["activeValue"] },
	notifierConfiguration: notifierConfig,
	userRight: webMI.query["right"],
	editable: true
};

if (typeof rightsHandling === "function") rightsHandling(rightsHandlingProperties);

if (typeof updateRunTimeNodeConfig === "function") {
	updateRunTimeNodeConfig(runTimeNodeConfig, notifierConfig.rights, initialize);
} else {
	initialize(runTimeNodeConfig);
}

function initialize(nodeCfg) {
	webMI.addOnload(function () {
		if (
			!nodeCfg["base"].read ||
			(nodeCfg.min.address && !nodeCfg.min.read) ||
			(nodeCfg.max.address && !nodeCfg.max.read)
		) {
			setInactiveLayout();
			return;
		}

		var options = {};
		var categoryName = "dummy";
		var barObj = {};
		var backgroundObj = {};

		webMI.trigger.connect(
			SET_ACTIVE_TRIGGER,
			function () {
				webMI.gfx.setVisible(FO_ID, null);
			},
			FO_ID
		);

		webMI.trigger.connect(
			SET_INACTIVE_TRIGGER,
			function () {
				webMI.gfx.setVisible(FO_ID, false);
			},
			FO_ID
		);

		var statusLabels = {};
		statusLabels.Good = "";
		statusLabels.Bad = "BAD";
		statusLabels.Uncertain = "UNCERTAIN";
		statusLabels.Unknown = "UNKNOWN";

		var trendConfig;

		function round(value) {
			return parseFloat(value, 10).toFixed(postDecimals);
		}

		function formatLabels() {
			var label = "";

			if (this.point) {
				var statusLabel = getStatusLabel(this.point.status);
				label = round(this.y) + " " + unit;

				if (statusLabel !== statusLabels.Good) {
					label += " (" + statusLabel + ")";
				}
			} else {
				label = round(this.value) + " " + unit;
			}

			return label;
		}

		function getStatusLabel(status) {
			var label = "";

			if (_isGood(status)) {
				label = statusLabels.Good;
			} else if (_isBad(status)) {
				label = statusLabels.Bad;
			} else if (_isUncertain(status)) {
				label = statusLabels.Uncertain;
			} else {
				label = statusLabels.Unknown;
			}

			return label;
		}

		function createChart() {
			min = parseFloat(round(parseFloat(min, 10)), 10);
			max = parseFloat(round(parseFloat(max, 10)), 10);

			// Add 1% of value because border will not be displayed
			trendConfig.yAxis.max = max + parseInt(barBorderWidth, 10);
			trendConfig.yAxis.min = min - parseInt(barBorderWidth, 10);

			trendConfig.plotOptions.series.threshold = min;

			barObj.color = barColor;
			barObj.borderWidth = barBorderWidth;
			barObj.borderColor = barBorderColor;
			barObj.data = [];

			backgroundObj.grouping = false;
			backgroundObj.borderWidth = barBorderWidth;
			backgroundObj.borderColor = barBorderColor;
			backgroundObj.color = barBackgroundColor;
			backgroundObj.dataLabels = {};
			backgroundObj.dataLabels.enabled = false;
			backgroundObj.data = [{}];
			backgroundObj.data[0].y = max;
			backgroundObj.data[0].status = 0;

			trendConfig.series.push(backgroundObj, barObj);
			trendConfig.yAxis.tickPositioner = function () {
				return [min, max];
			};

			webMI.trendFactory.createTrend(chartDiv, options, function (trendInstance) {
				var chart = trendInstance.chart;

				// Open display trigger
				webMI.trigger.connect(
					OPEN_DISPLAY_TRIGGER,
					function (triggerObj) {
						if (active) {
							webMI.display.openDisplay(triggerObj.value);
						}
					},
					""
				);

				webMI.data.subscribe(base, function (node) {
					var seriesObj = {};
					seriesObj.y = node.value;
					seriesObj.status = node.status;

					updateStatus(seriesObj.status);

					chart.series[1].update(
						{
							data: [seriesObj]
						},
						true
					);
				});

				if (nodeCfg.min.address && nodeCfg.min.read) {
					webMI.data.subscribe(nodeMin, function (result) {
						min = result.value;

						updateAxis(min, max);

						chart.update({ plotOptions: { bar: { threshold: min } } });
						chart.redraw(true);
					});
				}

				if (nodeCfg.max.address && nodeCfg.max.read) {
					webMI.data.subscribe(nodeMax, function (result) {
						max = result.value;

						updateAxis(min, max);

						chart.series[0].update(
							{
								data: [{ y: max, status: 0 }]
							},
							true
						);

						chart.redraw(true);
					});
				}

				updateAxis(min, max);

				function updateAxis(min, max) {
					var axisMin = min - parseInt(barBorderWidth, 10);
					var axisMax = max + parseInt(barBorderWidth, 10);

					chart.yAxis[0].setExtremes(axisMin, axisMax, true, false);
					chart.yAxis[0].options.tickPositions = [min, max];
					chart.yAxis[0].options.startOnTick = false;
					chart.yAxis[0].options.endOnTick = false;
					chart.yAxis[0].options.labels.x = 0;
					chart.yAxis[0].options.labels.y = 0;
				}
			});
		}

		webMI.gfx.setVisible(MAIN_LABEL_ID, false);
		webMI.gfx.setVisible(SUB_LABEL_ID, false);
		webMI.gfx.setVisible(BORDER_ID, false);

		options.trendName = chartDiv.id.split("_dashboard_highcharts_container")[0];
		options.trendGroup = "";
		options.trendConfig = {};

		trendConfig = options.trendConfig;

		trendConfig.chart = {};
		trendConfig.title = {};
		trendConfig.xAxis = {};
		trendConfig.xAxis.labels = {};
		trendConfig.yAxis = {};
		trendConfig.yAxis.labels = {};
		trendConfig.tooltip = {};
		trendConfig.plotOptions = {};
		trendConfig.plotOptions.bar = {};
		trendConfig.plotOptions.series = {};
		trendConfig.plotOptions.series.states = {};
		trendConfig.plotOptions.series.states.hover = {};
		trendConfig.plotOptions.bar.dataLabels = {};
		trendConfig.legend = {};
		trendConfig.series = [];
		trendConfig.credits = {};
		trendConfig.exporting = {};

		trendConfig.chart.type = "bar";
		trendConfig.chart.zoomType = "";
		trendConfig.title.text = "";
		trendConfig.chart.panning = false;

		trendConfig.xAxis.type = "category";
		trendConfig.xAxis.title = "";
		trendConfig.xAxis.labels.enabled = false;
		trendConfig.xAxis.lineWidth = 0;
		trendConfig.xAxis.gridLineWidth = 0;
		trendConfig.xAxis.minorGridLineWidth = 0;
		trendConfig.xAxis.majorGridLineWidth = 0;
		trendConfig.xAxis.lineColor = "transparent";
		trendConfig.xAxis.tickLength = 0;
		trendConfig.xAxis.minorTickLength = 0;
		trendConfig.xAxis.majorTickLength = 0;
		trendConfig.xAxis.categories = [categoryName];

		trendConfig.yAxis.title = "";
		trendConfig.yAxis.lineWidth = 0;
		trendConfig.yAxis.gridLineWidth = 0;
		trendConfig.yAxis.minorGridLineWidth = 0;
		trendConfig.yAxis.majorGridLineWidth = 0;
		trendConfig.yAxis.lineColor = "transparent";
		trendConfig.yAxis.tickLength = 0;
		trendConfig.yAxis.minorTickLength = 0;
		trendConfig.yAxis.majorTickLength = 0;
		trendConfig.yAxis.labels.formatter = formatLabels;

		trendConfig.plotOptions.bar.dataLabels.enabled = true;
		trendConfig.plotOptions.bar.dataLabels.align = "right";
		trendConfig.plotOptions.bar.dataLabels.formatter = formatLabels;
		trendConfig.plotOptions.bar.dataLabels.color = textColor;
		trendConfig.plotOptions.bar.animation = false;

		trendConfig.tooltip.enabled = true;

		trendConfig.legend.enabled = false;
		trendConfig.credits.enabled = false;
		trendConfig.exporting.enabled = false;
		trendConfig.plotOptions.series.states.hover.enabled = false;
		trendConfig.plotOptions.series.enableMouseTracking = false;

		options.trendConfig.atviseOptions = {
			configNode: "",
			configName: "",
			mode: "",
			source: "opcUA",
			enableCursor1: false,
			enableCursor2: false,
			disableDownSampling: true
		};

		if (base) {
			createChart();
		} else {
			webMI.trigger.fire(SET_INACTIVE_TRIGGER, "", "");
		}
	});
}

function updateStatus(status) {
	if (status) webMI.trigger.fire(SET_STATUS_TRIGGER, { chart: CHART_ID, status: status });
}

function setActiveLayout() {
	chartDiv.style.visibility = "visible";

	webMI.trigger.fire(SET_ACTIVE_TRIGGER, "", FO_ID);
	webMI.trigger.fire(SET_ACTIVE_TRIGGER, { chart: CHART_ID });
}

function setInactiveLayout() {
	chartDiv.style.visibility = "hidden";

	webMI.trigger.fire(SET_INACTIVE_TRIGGER, "", FO_ID);
	webMI.trigger.fire(SET_INACTIVE_TRIGGER, { chart: CHART_ID });
}

/**
 * With the following object, we address linter warnings about unused variables and functions,
 * since these references will be shared with other linked display scripts.
 */
const sharedReferences = {
	alarmIndication,
	statusEnabled,
	statusTrigger,
	statusIndication,
	setActiveLayout
};
sharedReferences;
]]></code>
</script>