<?xml version="1.0" encoding="UTF-8"?>
<script>
  <metadata>
    <priority>0</priority>
    <help/>
  </metadata>
  <code><![CDATA[const PARAMETER_TABLE_NAME = webMI.query["tableID"];
const gConfigNode = webMI.query["configNode"];
const gTemplateName = webMI.query["templateName"];
var gSelectedRecipeName; //recipe currently selected in combobox
var PREFIX = "AGENT.OBJECTS.";
var gTemplateData = {}; //stores the data of selected Template
var gRecipeData = {};

var gParametersTableController;
var gAccessControlManager;

var gCurrentRecipeDescription = "";

var updateRecipeStructure = typeof updateRecipeStructure !== "undefined" ? updateRecipeStructure : undefined;
var createTableColumnsFromGlobalList =
	typeof createTableColumnsFromGlobalList !== "undefined" ? createTableColumnsFromGlobalList : undefined;
var gValidData = typeof gValidData !== "undefined" ? gValidData : undefined;
var fieldValidFormatter = typeof fieldValidFormatter !== "undefined" ? fieldValidFormatter : undefined;
var validateTableData = typeof validateTableData !== "undefined" ? validateTableData : undefined;
var openErrorPopup = typeof openErrorPopup !== "undefined" ? openErrorPopup : undefined;

if (webMI.getAccessControlSupport()) {
	gAccessControlManager = webMI.callExtension("SYSTEM.LIBRARY.ATVISE.QUICKDYNAMICS.Access Control Manager");
}

/**
 * handle access control responses (e.g. lock functions or ignore error)
 * @param compareRights
 * @param callback
 */
function handleAccessControlResponse(compareRights, successCallback, failCallback) {
	if (!gAccessControlManager) {
		successCallback();
		return;
	}

	var requiredRights = {
		nodeIds: [],
		rights: []
	};

	compareRights = [].concat(compareRights);
	compareRights.forEach(function (r) {
		requiredRights.nodeIds.push(r.node);
		requiredRights.rights.push(r.right);
	});

	gAccessControlManager.getRightsDict(requiredRights.nodeIds, requiredRights.rights, function (response) {
		// do the checks
		var allRights = true;

		for (var c in compareRights) {
			if (
				typeof response[compareRights[c].node] != "undefined" &&
				typeof response[compareRights[c].node][compareRights[c].right] != "undefined"
			) {
				allRights = allRights && response[compareRights[c].node][compareRights[c].right];
			} else {
				allRights = false;
				break;
			}
		}

		if (allRights) {
			successCallback();
		} else {
			failCallback();
		}
	});
}

webMI.addOnload(function () {
	webMI.gfx.setText("txtTemplateName", gTemplateName);
	webMI.trigger.fire("com.atvise.setActive", false, "btnSave");
	webMI.trigger.fire("com.atvise.setActive", false, "btn_save_as");

	updateRecipeStructure(gConfigNode, function () {
		loadRecipes(); //load recipes into combobox

		if (Object.hasOwn(webMI.query, "recipeName") && webMI.query["recipeName"] != "") {
			gSelectedRecipeName = webMI.query["recipeName"];
		}

		handleAccessControlResponse(
			{ node: gConfigNode + "." + gTemplateName, right: "read" },
			function () {
				//read TemplateData:
				webMI.data.read(gConfigNode + ".templates." + gTemplateName, function (e) {
					gTemplateData = JSON.parse(e.value);

					if (Object.hasOwn(gTemplateData, "parameters")) {
						var check = [];

						if (gSelectedRecipeName !== undefined) {
							check.push({
								node: gConfigNode + "." + gTemplateName + "." + gSelectedRecipeName,
								right: "write"
							});
						}

						gTemplateData.parameters.forEach(function (par) {
							check.push({
								node: par.node,
								right: "read"
							});
						});

						handleAccessControlResponse(
							check,
							function () {
								webMI.trigger.fire("com.atvise.setActive", true, "btnValuesFromProcess");
							},
							function () {
								webMI.trigger.fire("com.atvise.setActive", false, "btnValuesFromProcess");
							}
						);
					}

					initParametersTable();
				});
			},
			function () {}
		);

		webMI.trigger.connect(
			"valuechanged",
			function (e) {
				// check if modifying of node is allowed ("write")
				handleAccessControlResponse(
					{
						node: gConfigNode + "." + gTemplateName + "." + e.value,
						right: "write"
					},
					function () {
						webMI.trigger.fire("com.atvise.setActive", true, "btnSave");
					},
					function () {
						webMI.trigger.fire("com.atvise.setActive", false, "btnSave");
					}
				);

				// check if adding of nodes is allowed ("engineer")
				handleAccessControlResponse(
					{
						node: gConfigNode + "." + gTemplateName,
						right: "engineer"
					},
					function () {
						webMI.trigger.fire("com.atvise.setActive", true, "btn_save_as");
					},
					function () {
						webMI.trigger.fire("com.atvise.setActive", false, "btn_save_as");
					}
				);

				gSelectedRecipeName = e.value;
				selectRecipe();
			},
			"cboRecipes"
		);
	});
});

/**
 * loads Recipes, adds them to combobox and selects the recipe which should be edited
 * (or none in case of new recipe)
 */
function loadRecipes() {
	handleAccessControlResponse(
		{ node: "SYSTEM.LIBRARY.ATVISE.SERVERSCRIPTS.RecipeManagement.RecipeDataProvider", right: "execute" },
		function () {
			webMI.data.call(
				"GetRecipeData",
				{ mode: "recipesByTemplateName", templateName: gTemplateName, configNode: gConfigNode },
				function (e) {
					var arrCboEntries = []; //used for combobox display
					for (var i = 0; i < e.length; i++) {
						arrCboEntries.push({ value: e[i].name, text: e[i].name });
					}
					arrCboEntries.sort((a, b) => (a.value.toLowerCase() > b.value.toLowerCase() ? 1 : -1));
					webMI.trigger.fire("setItems", arrCboEntries, "cboRecipes");

					if (gSelectedRecipeName !== undefined) {
						webMI.trigger.fire("setSelectedItem", gSelectedRecipeName, "cboRecipes");
					} else {
						webMI.trigger.fire("setSelectedItem", "", "cboRecipes");
					}
				}
			);
		},
		function () {}
	);
}
/**
 * selects the recipe, reads its data from the node and calls displayRecipeData()
 * to display it in the table
 */
function selectRecipe() {
	if (gParametersTableController === undefined) {
		return;
	}

	gParametersTableController.clearData();

	if (gSelectedRecipeName === undefined) {
		//no recipe selected -> new receipe: display data only based on template
		webMI.trigger.fire("setValue", "", "inoutRecipeDescription");

		gParametersTableController.grid.setOptions({
			enableCellNavigation: true,
			editable: true,
			editorCellNavOnLRKeys: true
		});
		displayRecipeData();
	} else {
		//recipe selected: load values from recipe node and then display data
		handleAccessControlResponse(
			{
				node: gConfigNode + "." + gTemplateName + "." + gSelectedRecipeName,
				right: "read"
			},
			function () {
				webMI.data.read(gConfigNode + "." + gTemplateName + "." + gSelectedRecipeName, function (e) {
					gRecipeData = JSON.parse(e.value);
					displayRecipeData();
				});
			},
			function () {}
		);

		handleAccessControlResponse(
			{ node: gConfigNode + "." + gTemplateName + "." + gSelectedRecipeName, right: "write" },
			function () {
				gParametersTableController.grid.setOptions({
					enableCellNavigation: true,
					editable: true,
					editorCellNavOnLRKeys: true
				});
			},
			function () {
				gParametersTableController.grid.setOptions({
					enableCellNavigation: false,
					editable: false,
					editorCellNavOnLRKeys: false
				});
			}
		);
	}
}

/**
 * displays all recipe parameters in the table
 */
function displayRecipeData() {
	//description in_out_value:
	if (Object.hasOwn(gRecipeData, "description")) {
		webMI.trigger.fire("setValue", gRecipeData.description, "inoutRecipeDescription");
	} else {
		webMI.trigger.fire("setValue", "", "inoutRecipeDescription");
	}

	//parameters table:
	var parameters = gTemplateData.parameters;
	var data = [];
	data.result = [];

	for (var i = 0; i < parameters.length; i++) {
		let value;

		if (Object.hasOwn(gRecipeData, "values")) {
			if (Object.hasOwn(gRecipeData.values, parameters[i].name)) {
				//value stored in recipe -> use this value
				value = gRecipeData.values[parameters[i].name];
			} else {
				//value for this parameter not stored in recipe -> use defaultvalue from template
				value = parameters[i].defaultvalue;
			}
		} else {
			//no values stored/new recipe  -> use defaultvalue from template
			value = parameters[i].defaultvalue;
		}

		parameters[i].value = value;

		var valueEditorSettings = {};

		if (!Object.hasOwn(parameters[i], "options")) {
			parameters[i].options = "";
		}

		if (Object.hasOwn(parameters[i], "min")) {
			valueEditorSettings.min = parameters[i].min;
		}
		if (Object.hasOwn(parameters[i], "max")) {
			valueEditorSettings.max = parameters[i].max;
		}
		if (Object.hasOwn(parameters[i], "node")) {
			parameters[i].node = parameters[i].node.replace(PREFIX, "");
		}
		if (Object.hasOwn(parameters[i], "stepsize")) {
			valueEditorSettings.step = parameters[i].stepsize;
		}
		parameters[i]["value-editorSettings"] = valueEditorSettings;
		parameters[i]["value-editorType"] =
			Object.hasOwn(parameters[i], "options") &&
			(parameters[i].options || "").length > 0 &&
			parameters[i].datatype != "Bool"
				? "Options"
				: parameters[i].datatype == "Number" &&
				  Object.hasOwn(parameters[i], "min") &&
				  parameters[i].min != null &&
				  parameters[i].min != "" &&
				  Object.hasOwn(parameters[i], "max") &&
				  parameters[i].max != null &&
				  parameters[i].max != ""
				? "Range"
				: parameters[i].datatype;

		data.result.push(parameters[i]);
	}

	gParametersTableController.addData(data);
	gParametersTableController.getData().forEach(function (item) {
		validateRow(item);
	});
}

/**
 * Initializes the table and calls selectRecipe() as data request function
 */
function initParametersTable() {
	webMI.table.loadResources(function () {
		webMI.libraryLoader.load(
			["slickgrid/adaptations/slick.recipe.editors.js"],
			["slickgrid/adaptations/slick.recipe.editors.css"],
			function () {
				var config = [];

				var editors = {
					value: webMI.rootWindow.Slick.Recipe.Editors.IndividualType
				};
				var formatters = {
					name: NonEditFormatter,
					description: NonEditFormatter,
					value: ValueFormatter,
					unit: NonEditFormatter,
					min: NonEditFormatter,
					max: NonEditFormatter,
					stepsize: NonEditFormatter,
					defaultvalue: NonEditFormatter,
					node: NonEditFormatter,
					datatype: NonEditFormatter
				};
				config["columns"] = createTableColumnsFromGlobalList(webMI.query.columns, "Main", editors, formatters);

				config["mode"] = "once";
				config["renderInterval"] = 0;

				config["dataRequestFunction"] = function customDataRequest() {
					gParametersTableController = this;
					selectRecipe();

					gParametersTableController.grid.setOptions({
						enableCellNavigation: true,
						editable: true,
						editorCellNavOnLRKeys: true
					});

					gParametersTableController.grid.onCellChange.subscribe(function (_e, args) {
						validateRow(args.item);
					});

					// eslint-disable-next-line no-unused-vars
					gParametersTableController.grid.onBeforeCellEditorDestroy.subscribe(function (_e, _args) {
						webMI.gfx.setText("lblMessages", "");
					});

					gParametersTableController.grid.onActiveCellChanged.subscribe(function (_e, args) {
						webMI.gfx.setText("lblMessages", "");
						var itemId = args.grid.getDataItem(args.row).id;
						var field = args.grid.getColumns()[args.cell].field;
						if (
							itemId in gValidData &&
							field in gValidData[itemId] &&
							"valid" in gValidData[itemId][field] &&
							"errors" in gValidData[itemId][field] &&
							gValidData[itemId][field].valid === false &&
							Array.isArray(gValidData[itemId][field].errors)
						) {
							webMI.gfx.setText(
								"lblMessages",
								gValidData[itemId].parameterName +
									": " +
									gValidData[itemId][field].errors
										.filter(function (_element, index) {
											return index < 2;
										})
										.join(", ")
							);
						}
					});
				};

				webMI.table.register(PARAMETER_TABLE_NAME, "config", config);
				webMI.table.setReady(PARAMETER_TABLE_NAME, "config");
			}
		);
	});
}

/*format a Number value according to the set decimals*/
function formatNumberValue(dataContext, value) {
	value = parseFloat(value);
	if (isNaN(value)) {
		value = "";
	} else {
		if (
			Object.hasOwn(dataContext, "decimals") &&
			!isNaN(parseInt(dataContext.decimals)) &&
			parseInt(dataContext.decimals) == parseFloat(dataContext.decimals)
		) {
			value = webMI.sprintf("%." + dataContext.decimals + "f", value);
		}
	}

	return value;
}

function ValueFormatter(row, cell, value, columnDef, dataContext) {
	return fieldValidFormatter(
		row,
		cell,
		(Object.hasOwn(dataContext, "options") && (dataContext.options || "").trim() != "") || dataContext.options === ""
			? value
			: formatNumberValue(dataContext, value),
		columnDef,
		dataContext
	);
}

// eslint-disable-next-line no-unused-vars
function NonEditFormatter(_row, _cell, value, _columnDef, _dataContext) {
	return "<div style='width:100%; text-align: center'class='inactive-value'>" + value + "</div>";
}

/**
 * checks if an row is valid and will set a [fieldname]-valid property for validated fields
 */
function validateRow(item) {
	/*----------validate value-------------*/
	var valueValid = true;
	var valueErrors = [];

	gValidData[item.id] = { parameterName: item.name };

	if (Object.hasOwn(item, "min") && item.datatype == "Number") {
		if (!isNaN(item.min) && item.min != null && item.min != "") {
			let min = parseFloat(item.min);
			let value = parseFloat(item.value);

			if (value < min) {
				valueValid = false;
				valueErrors.push("T{value is less than defined minimum} " + min);
			}
		}
	}

	if (Object.hasOwn(item, "max") && item.datatype == "Number") {
		if (!isNaN(item.max) && item.max != null && item.max != "") {
			let max = parseFloat(item.max);
			let value = parseFloat(item.value);

			if (value > max) {
				valueValid = false;
				valueErrors.push("T{value is greater than defined maximum} " + max);
			}
		}
	}

	if (Object.hasOwn(item, "stepsize") && Object.hasOwn(item, "min") && item.datatype == "Number") {
		if (
			!isNaN(item.stepsize) &&
			!isNaN(item.min) &&
			item.stepsize != null &&
			item.stepsize != "" &&
			item.min != null &&
			item.min != ""
		) {
			let decimals = 0;
			if (Object.hasOwn(item, "decimals") && !isNaN(item.decimals) && item.decimals != null && item.decimals != "") {
				decimals = parseInt(item.decimals);
			}
			var factor = Math.pow(10, decimals);
			var stepsize = parseFloat(item.stepsize) * factor;
			let min = parseFloat(item.min) * factor;
			let value = parseFloat(item.value) * factor;

			if ((value - min) % stepsize != 0) {
				valueValid = false;
				valueErrors.push("T{value is not in stepsize} " + stepsize / factor);
			}
		}
	}

	gValidData[item.id].value = { valid: valueValid, errors: valueErrors };

	if (
		Object.hasOwn(item, "decimals") &&
		item.datatype == "Number" &&
		!isNaN(item.decimals) &&
		item.decimals != null &&
		item.decimals != ""
	) {
		let decimals = parseInt(item.decimals);
		if (parseFloat(item.decimals) !== decimals) {
			gValidData[item.id].decimals = { valid: false, errors: ["T{value is not allowed to have decimals}"] };
		} else if (Object.hasOwn(item, "value") && !isNaN(item.value) && item.value != null && item.value != "") {
			var re = RegExp("^-?\\d*(\\.\\d{0," + decimals + "})?$");
			if (!Object.hasOwn(gValidData[item.id], "value")) {
				gValidData[item.id].value = { valid: true, errors: [] };
			}
			let value = parseFloat(item.value);

			if (re.exec(value) == null) {
				gValidData[item.id].value.valid = false;
				gValidData[item.id].value.errors.push("T{value exceeds max number of decimals} " + decimals);
			}
		}
	}

	if (item.datatype != "Bool" && Object.hasOwn(item, "options") && (item.options || "").trim() != "") {
		var values = (item.options || "").split(";");
		gValidData[item.id].value = { valid: values.includes(String(item.value)), errors: [] };
		if (!gValidData[item.id].value.valid) {
			gValidData[item.id].value.errors.push("T{value is not in the list of options}");
		}
	}

	if (item.datatype == "Bool") {
		gValidData[item.id].value.valid = Boolean(String(item.value) == "true" || String(item.value) == "false");

		if (!gValidData[item.id].value.valid) {
			gValidData[item.id].value.errors.push("T{invalid value}");
		}
	}

	/*-----------------------------------*/
}

webMI.trigger.connect(
	"clicked",
	function () {
		var valid = validateTableData();

		if (valid.valid == false) {
			openErrorPopup(valid.errors);
			return;
		}

		updateRecipe(gSelectedRecipeName);
	},
	"btnSave"
);

/**
 * handle template data storage, writes current template state to new template structure
 */
webMI.trigger.connect(
	"clicked",
	function () {
		var valid = validateTableData();

		if (valid.valid == false) {
			openErrorPopup(valid.errors);
			return;
		}

		webMI.display.openWindow({
			display: "SYSTEM.LIBRARY.ATVISE.OBJECTDISPLAYS.Advanced.recipemanager.add_popup",
			height: 310,
			width: 600,
			remember: true,
			modal: true,
			resizable: false,
			movable: true,
			scrollbars: true,
			menubar: false,
			status: false,
			toolbar: false,
			query: {
				configNode: gConfigNode,
				mode: "recipes",
				templateName: gTemplateName,
				dialogTitle: "T{Save recipe as}:",
				triggerName: "add_recipe",
				label1: "T{Recipe}:",
				value1: gSelectedRecipeName
			}
		});
	},
	"btn_save_as"
);

/**
 * trigger to save template with another name
 */
webMI.trigger.connect("add_recipe", function (e) {
	handleAccessControlResponse(
		[
			{
				node: "SYSTEM.LIBRARY.ATVISE.SERVERSCRIPTS.RecipeManagement.RecipeDataProvider",
				right: "execute"
			},
			{
				node: gConfigNode + "." + gTemplateName,
				right: "engineer"
			}
		],
		function () {
			webMI.data.call(
				"GetRecipeData",
				{
					mode: "SaveRecipe",
					templateName: gTemplateName,
					recipeName: e.value.value1,
					configNode: gConfigNode,
					data: JSON.stringify({
						name: e.value.value1
					})
				},
				function () {
					updateRecipe(e.value.value1);
				}
			);
		},
		function () {}
	);
});

function updateRecipe(recipeName) {
	var tableData = gParametersTableController.getData();
	var data = {
		name: recipeName,
		description: gCurrentRecipeDescription,
		values: {}
	};

	for (var i = 0; i < tableData.length; i++) {
		data.values[tableData[i].name] = tableData[i].value;
	}

	handleAccessControlResponse(
		[
			{ node: "SYSTEM.LIBRARY.ATVISE.SERVERSCRIPTS.RecipeManagement.RecipeDataProvider", right: "execute" },
			{ node: gConfigNode + "." + gTemplateName + "." + recipeName, right: "write" }
		],
		function () {
			webMI.data.call(
				"GetRecipeData",
				{
					mode: "SaveRecipe",
					configNode: gConfigNode,
					templateName: gTemplateName,
					recipeName: recipeName,
					data: JSON.stringify(data)
				},
				function () {
					gSelectedRecipeName = recipeName;
					gParametersTableController.clearData();
					loadRecipes();
				}
			);
		},
		function () {}
	);
}

webMI.trigger.connect(
	"valuechanged",
	function (e) {
		gCurrentRecipeDescription = e.value;
	},
	"inoutRecipeDescription"
);

webMI.trigger.connect(
	"clicked",
	function () {
		var data = gParametersTableController.getData();

		if (data == null || data == undefined) {
			return;
		}

		var addr = [];
		data.forEach(function (row) {
			addr.push(PREFIX + "" + row.node);
		});

		//set empty values array, if no values have been set before (new recipe):
		if (!Object.hasOwn(gRecipeData, "values")) {
			gRecipeData.values = [];
		}

		webMI.data.read(addr, function (readData) {
			for (var i = 0; i < data.length; i++) {
				gRecipeData.values[data[i].name] = readData[i].value;
				data[i].value = readData[i].value;
				gParametersTableController.updateData(data[i].id, data[i]);
				validateRow(data[i]);
			}
		});
	},
	"btnValuesFromProcess"
);
]]></code>
</script>
