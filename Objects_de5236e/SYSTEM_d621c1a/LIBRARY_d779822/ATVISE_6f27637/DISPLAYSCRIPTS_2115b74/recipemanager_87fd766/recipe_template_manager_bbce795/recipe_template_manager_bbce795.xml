<?xml version="1.0" encoding="UTF-8"?>
<script>
  <metadata>
    <priority>0</priority>
    <help/>
  </metadata>
  <code><![CDATA[var gTemplateTableController;
var gParameterTablecontroller;
var gAccessControlManager;
var PREFIX = "AGENT.OBJECTS.";
var gSelectedTemplateName = "";
const gConfigNode = webMI.query["configNode"];
const PARAMETER_TABLE_NAME = webMI.query["tableID"];
const PARAMETER_TABLE_NAME2 = webMI.query["tableID2"];

var updateRecipeStructure = typeof updateRecipeStructure !== "undefined" ? updateRecipeStructure : undefined;
var createTableColumnsFromGlobalList =
	typeof createTableColumnsFromGlobalList !== "undefined" ? createTableColumnsFromGlobalList : undefined;

if (webMI.getAccessControlSupport()) {
	gAccessControlManager = webMI.callExtension("SYSTEM.LIBRARY.ATVISE.QUICKDYNAMICS.Access Control Manager");
}

/**
 * handle access control responses (e.g. lock functions or ignore error)
 * @param compareRights
 * @param callback success
 * @param callback fail
 */
function handleAccessControlResponse(compareRights, successCallback, failCallback) {
	if (!gAccessControlManager) {
		successCallback();
		return;
	}

	var requiredRights = {
		nodeIds: [],
		rights: []
	};

	compareRights = [].concat(compareRights);
	compareRights.forEach(function (r) {
		requiredRights.nodeIds.push(r.node);
		requiredRights.rights.push(r.right);
	});

	gAccessControlManager.getRightsDict(requiredRights.nodeIds, requiredRights.rights, function (response) {
		// do the checks
		var allRights = true;

		for (var c in compareRights) {
			if (
				typeof response[compareRights[c].node] != "undefined" &&
				typeof response[compareRights[c].node][compareRights[c].right] != "undefined"
			) {
				allRights = allRights && response[compareRights[c].node][compareRights[c].right];
			} else {
				allRights = false;
				break;
			}
		}

		if (allRights) {
			successCallback();
		} else {
			failCallback();
		}
	});
}

/**
 * handle access control responses (e.g. lock functions or ignore error)
 * success if any node/right comibination is true
 * @param compareRights
 * @param callback success
 * @param callback fail
 */
function handleAccessControlResponseAny(compareRights, successCallback, failCallback) {
	if (!gAccessControlManager) {
		successCallback();
		return;
	}

	var requiredRights = {
		nodeIds: [],
		rights: []
	};

	compareRights = [].concat(compareRights);
	compareRights.forEach(function (r) {
		requiredRights.nodeIds.push(r.node);
		requiredRights.rights.push(r.right);
	});

	gAccessControlManager.getRightsDict(requiredRights.nodeIds, requiredRights.rights, function (response) {
		// do the checks
		var anyRights = false;

		for (var c in compareRights) {
			if (
				typeof response[compareRights[c].node] != "undefined" &&
				typeof response[compareRights[c].node][compareRights[c].right] != "undefined"
			) {
				anyRights = anyRights || response[compareRights[c].node][compareRights[c].right];
			}
		}

		if (anyRights) {
			successCallback();
		} else {
			failCallback();
		}
	});
}

/**
 * create recipe template table data
 */
function getTableData() {
	webMI.data.call("GetRecipeData", { mode: "RecipeTemplates", configNode: gConfigNode }, function (e) {
		var templateData = e;
		var rows = [];
		rows.result = [];
		for (const key in templateData) {
			var templateNode = templateData[key];
			var templateRowItem = {};
			var template = JSON.parse(templateNode.value);
			templateRowItem.id = template.id;
			templateRowItem.name = template.id;
			templateRowItem.description = template.description;
			templateRowItem.edit = "edit";
			rows.push(templateRowItem);
		}

		initRecipeTemplates(rows);
	});
}

/**
 * create recipe template table data
 */
function updateTemplates() {
	if (gTemplateTableController === undefined) {
		return;
	}

	webMI.data.call("GetRecipeData", { mode: "RecipeTemplates", configNode: gConfigNode }, function (templateData) {
		var rows = [];
		for (var t in templateData) {
			var json = JSON.parse(templateData[t].value);
			json.name = json.id;
			delete json.id;
			rows.push(json);
		}
		gTemplateTableController.clearData();
		gTemplateTableController.addData({ result: rows });

		// remove "active" class from template table
		for (var node of webMI.rootWindow.document.querySelectorAll("[id^=tbl_templates_] [class*=active]")) {
			node.classList.remove("active");
		}
	});
}

/**
 * create recipe template parameter table data for given template
 * @param recipeTemplatename
 */
function updateRecipeParameters(recipeTemplatename) {
	if (gParameterTablecontroller === undefined) {
		return;
	}
	if (recipeTemplatename === undefined) {
		gParameterTablecontroller.clearData();
		return;
	}

	webMI.data.call(
		"GetRecipeData",
		{ mode: "TemplateParameterByName", templateName: recipeTemplatename, configNode: gConfigNode },
		function (parameterData) {
			gParameterTablecontroller.clearData();
			for (var i = 0; i < parameterData.length; i++) {
				if (Object.hasOwn(parameterData[i], "node")) {
					parameterData[i].node = parameterData[i].node.replace(PREFIX, "");
				}
			}
			gParameterTablecontroller.addData({ result: parameterData });
		}
	);
}

webMI.addOnload(function () {
	updateRecipeStructure(gConfigNode, function () {
		setAddBtnActive();
		if (webMI.getMethodSupport().indexOf("AddNode") < 0 || webMI.getMethodSupport().indexOf("CheckNodeExists") < 0) {
			console.warn("The necessary webMI methods are not supported, please add the configuration node manually");
		} else {
			handleAccessControlResponse(
				{ node: "SYSTEM.LIBRARY.ATVISE.WEBMIMETHODS.CheckNodeExists", right: "execute" },
				function () {
					webMI.data.call("CheckNodeExists", { address: gConfigNode }, function (e) {
						setAddBtnActive();
						if (e.result) {
							// config node exists
							initTables();
							return;
						}

						handleAccessControlResponse(
							[
								{ node: gConfigNode.substring(0, gConfigNode.lastIndexOf(".")), right: "engineer" },
								{ node: "SYSTEM.LIBRARY.ATVISE.WEBMIMETHODS.AddNode", right: "execute" }
							],
							function () {
								gAccessControlManager.assist.addNode(
									{
										address: gConfigNode,
										nodeClass: "NODECLASS_OBJECT",
										typeDefinition: "i=61"
									},
									function () {
										gAccessControlManager.assist.addNode(
											{
												address: gConfigNode + ".templates",
												nodeClass: "NODECLASS_OBJECT",
												typeDefinition: "i=61"
											},
											function () {
												setAddBtnActive();
												initTables();
											},
											function (error) {
												console.error(gConfigNode + ".templates", error);
												permissionMissing();
											}
										);
									},
									function (error) {
										console.error(gConfigNode, error);
										permissionMissing();
									}
								);
							},
							function () {
								permissionMissing();
							}
						);
					});
				},
				function () {
					permissionMissing();
				}
			);
		}

		webMI.gfx.setText("lbl_selected_recipe_template", "");
		webMI.trigger.fire("com.atvise.setActive", false, "btn_delete");
		webMI.trigger.fire("com.atvise.setActive", false, "btn_export");
		handleAccessControlResponse(
			{ node: gConfigNode, right: "engineer" },
			function () {
				webMI.trigger.fire("com.atvise.setActive", true, "btn_import");
			},
			function () {
				webMI.trigger.fire("com.atvise.setActive", false, "btn_import");
			}
		);
	});
});

/**
 * initiate both tables
 */
function initTables() {
	handleAccessControlResponse(
		{ node: "SYSTEM.LIBRARY.ATVISE.SERVERSCRIPTS.RecipeManagement.RecipeDataProvider", right: "execute" },
		function () {
			getTableData();
		},
		function () {}
	);
}

/**
 * show missing permission message
 */
function permissionMissing() {
	webMI.gfx.setText("not_authorized_message", "T{Permission(s) missing for recipe management!}");
	webMI.gfx.setVisible("not_authorized_message", null);
	webMI.gfx.setVisible("id_1", false);
	webMI.gfx.setVisible("id_11", false);
	removeTableFooter("tbl_templates");
	removeTableFooter("tbl_params");
}

/**
 * remove footer from DOM from slickgrid for table id
 * @param id
 */
function removeTableFooter(id) {
	var nodes = webMI.rootWindow.document.querySelectorAll('tr[id*="' + id + '"][id$="footerBar1"]');
	nodes.forEach(function (n) {
		while (n.firstChild != null) {
			n.removeChild(n.firstChild);
		}
	});
}

/**
 * set add button active based on access control right
 */
function setAddBtnActive() {
	handleAccessControlResponse(
		{ node: gConfigNode, right: "engineer" },
		function () {
			webMI.trigger.fire("com.atvise.setActive", true, "btn_add");
			webMI.trigger.fire("com.atvise.setActive", true, "btn_import");
		},
		function () {
			webMI.trigger.fire("com.atvise.setActive", false, "btn_add");
			webMI.trigger.fire("com.atvise.setActive", false, "btn_import");
		}
	);
}

/**
 * initialize template slick grid table with given row data
 * @param rows
 */
function initRecipeTemplates(rows) {
	try {
		webMI.table.loadResources(function () {
			var config = {};

			// always add an edit column
			config["columns"] = createTableColumnsFromGlobalList(webMI.query.columnsTemplates, "Main", {}, {}).concat({
				id: "edit",
				name: "T{Edit}",
				field: "edit",
				sortable: false,
				filter: false,
				visible: true,
				resizable: true,
				width: 10,
				// eslint-disable-next-line no-unused-vars
				formatter: function (_row, _cell, _value, _columnDef, _dataContext) {
					return "<div style='width:100%; text-align:center;'><i class='fas fa-edit'></i></div>";
				}
			});

			config["mode"] = "once"; // or live/triggered
			config["bufferInterval"] = 75;
			config["onClickCallback"] = function (_e, info) {
				if (info.column.id == "edit") {
					webMI.query.templateName = info.item.name;
					webMI.display.openDisplay(
						"SYSTEM.LIBRARY.ATVISE.OBJECTDISPLAYS.Advanced.recipemanager.recipe_template_editor",
						webMI.query
					);
					return;
				} else {
					if (gSelectedTemplateName != info.item.name) {
						webMI.gfx.setText("lbl_selected_recipe_template", info.item.name);
						gSelectedTemplateName = info.item.name;
						updateRecipeParameters(info.item.name);
					}
				}
				setDeleteExportButtonInActive();
			};
			config["onHeaderClickCallback"] = function (_e, info) {
				if (info.column.id != "atvise_marker") {
					return;
				}

				setDeleteExportButtonInActive();
			};
			var data = {};
			data.result = rows;
			// eslint-disable-next-line no-unused-vars
			config["dataRequestFunction"] = function customDataRequest(_continuation) {
				var self = this;
				self.clearData();
			};

			webMI.table.register(PARAMETER_TABLE_NAME, "config", config);
			webMI.table.setReady(PARAMETER_TABLE_NAME, "config");
			gTemplateTableController = webMI.table.request(PARAMETER_TABLE_NAME, "controller");

			initRecipeParameters([]);
		});
	} catch (ex) {
		// do nothing
	}
}

/**
 * activate/deactivate delete and export button based on selected items
 */
function setDeleteExportButtonInActive() {
	if (gTemplateTableController == null || gTemplateTableController.isReady !== true) {
		return;
	}

	if (gTemplateTableController.getSelectedItems().length > 0) {
		var compareRightsDelete = [];
		var compareRightsExport = [];
		for (const item of gTemplateTableController.getSelectedItems()) {
			compareRightsDelete.push({
				node: gConfigNode + "." + item.name,
				right: "engineer"
			});
			compareRightsExport.push({
				node: gConfigNode + "." + item.name,
				right: "read"
			});
		}

		handleAccessControlResponseAny(
			compareRightsDelete,
			function () {
				webMI.trigger.fire("com.atvise.setActive", true, "btn_delete");
			},
			function () {
				webMI.trigger.fire("com.atvise.setActive", false, "btn_delete");
			}
		);

		handleAccessControlResponseAny(
			compareRightsExport,
			function () {
				webMI.trigger.fire("com.atvise.setActive", true, "btn_export");
			},
			function () {
				webMI.trigger.fire("com.atvise.setActive", false, "btn_export");
			}
		);
	} else {
		webMI.trigger.fire("com.atvise.setActive", false, "btn_delete");
		webMI.trigger.fire("com.atvise.setActive", false, "btn_export");
	}
}

/**
 * open delete template dialog to ask user if he wants to delete a template
 */
function deleteSelectedTemplate() {
	webMI.query.triggerName = "remove_recipe_template";
	webMI.query.dialogTitle = "T{Remove recipe template}:";
	webMI.query.dialogMessageLine1 = "T{Do you want to delete the selected recipe template(s)?}";
	webMI.query.dialogMessageLine2 = "T{Recipes of selected template(s) will be deleted too!}";

	webMI.display.openWindow({
		display: "SYSTEM.LIBRARY.ATVISE.OBJECTDISPLAYS.Advanced.recipemanager.recipe_delete",
		height: 310,
		width: 600,
		remember: true,
		modal: true,
		resizable: false,
		movable: true,
		scrollbars: true,
		menubar: false,
		status: false,
		toolbar: false,
		query: webMI.query
	});
}

/*format a Number value according to the set decimals*/
function formatNumberValue(dataContext, value) {
	if (
		(!Object.hasOwn(dataContext, "options") || (dataContext.options || "").trim() == "") &&
		(dataContext.datatype == "Number" || dataContext.datatype == "Range")
	) {
		value = parseFloat(value);
		if (isNaN(value)) {
			value = "";
		} else {
			if (
				Object.hasOwn(dataContext, "decimals") &&
				!isNaN(parseInt(dataContext.decimals)) &&
				parseInt(dataContext.decimals) == parseFloat(dataContext.decimals)
			) {
				value = webMI.sprintf("%." + dataContext.decimals + "f", value);
			}
		}
	}

	return value;
}

/**
 * initialize template parameter slick grid table with given row data
 * @param rows
 */
function initRecipeParameters(rows) {
	var config = {};
	// eslint-disable-next-line no-unused-vars
	var nodeFormatter = function (_row, _cell, value, _columnDef, _dataContext) {
		return "<div style='width:100%; text-align: center'>" + value + "</div>";
	};
	config["columns"] = createTableColumnsFromGlobalList(
		webMI.query.columnsParameters,
		"Main",
		{},
		{
			defaultvalue: function (_row, _cell, value, _columnDef, dataContext) {
				return "<div style='width:100%; text-align: center'>" + formatNumberValue(dataContext, value) + "</div>";
			},
			node: nodeFormatter
		}
	);

	config["mode"] = "once"; // or live/triggered
	config["bufferInterval"] = 75;

	// eslint-disable-next-line no-unused-vars
	config["onClickCallback"] = function (_e, _info) {};
	/* Example set of data */
	var data = {};
	data.result = rows;
	// eslint-disable-next-line no-unused-vars
	config["dataRequestFunction"] = function customDataRequest(_continuation) {
		var self = this;
		self.clearData();
	};

	webMI.table.register(PARAMETER_TABLE_NAME2, "config", config);
	webMI.table.setReady(PARAMETER_TABLE_NAME2, "config");
	gParameterTablecontroller = webMI.table.request(PARAMETER_TABLE_NAME2, "controller");
}

/**
 * trigger to add a template
 */
webMI.trigger.connect("add_recipe_template", function (e) {
	// do nothing if no template name provided
	if (e.value.value1 == "") {
		return;
	}

	handleAccessControlResponse(
		[
			{
				node: "SYSTEM.LIBRARY.ATVISE.SERVERSCRIPTS.RecipeManagement.RecipeDataProvider",
				right: "execute"
			},
			{
				node: gConfigNode,
				right: "engineer"
			}
		],
		function () {
			webMI.data.call(
				"GetRecipeData",
				{
					mode: "CreateTemplate",
					templateName: e.value.value1,
					configNode: gConfigNode,
					data: JSON.stringify({
						id: e.value.value1,
						description: e.value.value2,
						parameters: []
					})
				},
				function () {
					updateTemplates();
				}
			);
		},
		function () {}
	);
});

/**
 * trigger to delete the currently selected template
 */
webMI.trigger.connect("remove_recipe_template", function () {
	handleAccessControlResponse(
		{ node: "SYSTEM.LIBRARY.ATVISE.SERVERSCRIPTS.RecipeManagement.RecipeDataProvider", right: "execute" },
		function () {
			deleteTemplateCallback(gTemplateTableController.getSelectedItems());
		},
		function () {}
	);
});

function deleteTemplateCallback(items) {
	if ([].concat(items).length == 0) {
		webMI.trigger.fire("com.atvise.setActive", false, "btn_delete");
		webMI.trigger.fire("com.atvise.setActive", false, "btn_export");
		updateTemplates();
		return;
	}

	handleAccessControlResponse(
		{ node: gConfigNode + "." + items[0].name, right: "engineer" },
		function () {
			webMI.data.call(
				"GetRecipeData",
				{
					mode: "DeleteTemplateByName",
					configNode: gConfigNode,
					templateName: items[0].name
				},
				function () {
					deleteTemplateCallback(items.slice(1));
				}
			);
		},
		function () {
			deleteTemplateCallback(items.slice(1));
		}
	);
}

webMI.trigger.connect(
	"clicked",
	function () {
		deleteSelectedTemplate();
	},
	"btn_delete"
);

webMI.trigger.connect(
	"clicked",
	function () {
		webMI.display.openWindow({
			display: "SYSTEM.LIBRARY.ATVISE.OBJECTDISPLAYS.Advanced.recipemanager.add_popup",
			height: 310,
			width: 600,
			remember: true,
			modal: true,
			resizable: false,
			movable: true,
			scrollbars: true,
			menubar: false,
			status: false,
			toolbar: false,
			query: {
				configNode: gConfigNode,
				mode: "templates",
				dialogTitle: "T{Add recipe template}:",
				triggerName: "add_recipe_template",
				label1: "T{Template name}:",
				value1: "",
				useSecondValue: true,
				label2: "T{Description}:",
				value2: ""
			}
		});
	},
	"btn_add"
);

webMI.trigger.connect(
	"clicked",
	function () {
		handleAccessControlResponse(
			{ node: "SYSTEM.LIBRARY.ATVISE.SERVERSCRIPTS.RecipeManagement.RecipeDataProvider", right: "execute" },
			function () {
				var exp = JSON.stringify(
					gTemplateTableController.getSelectedItems().reduce(function (obj, r) {
						obj[r.name] = [];
						return obj;
					}, {})
				);
				webMI.data.call("GetRecipeData", { mode: "Export", export: exp, configNode: gConfigNode }, function (e) {
					var blob = new Blob([e.result], { type: "text/csv" });
					var downloadCsv = document.getElementById("downloadCsv");
					downloadCsv.download = "export.csv";
					downloadCsv.href = URL.createObjectURL(blob);
					downloadCsv.click();
				});
			},
			function () {}
		);
	},
	"btn_export"
);

webMI.trigger.connect(
	"clicked",
	function () {
		var selectCsv = document.getElementById("selectCsv");
		if (selectCsv.onchange == null) {
			selectCsv.onchange = function (e) {
				if (e.target.files.length != 1) {
					return;
				}

				const fr = new FileReader();
				fr.onload = function (ev) {
					handleAccessControlResponse(
						{ node: "SYSTEM.LIBRARY.ATVISE.SERVERSCRIPTS.RecipeManagement.RecipeDataProvider", right: "execute" },
						function () {
							webMI.data.call(
								"GetRecipeData",
								{ mode: "Import", csvData: ev.target.result, configNode: gConfigNode },
								function () {
									webMI.trigger.fire("com.atvise.setActive", false, "btn_delete");
									webMI.trigger.fire("com.atvise.setActive", false, "btn_export");
									updateTemplates();
								}
							);
						},
						function () {}
					);
				};
				fr.readAsText(e.target.files[0]);
			};
		}
		selectCsv.click();
	},
	"btn_import"
);
]]></code>
</script>
