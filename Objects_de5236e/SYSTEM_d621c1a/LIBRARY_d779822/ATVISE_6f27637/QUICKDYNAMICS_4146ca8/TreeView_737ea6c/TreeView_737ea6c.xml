<?xml version="1.0" encoding="UTF-8"?>
<script>
  <metadata>
    <icon type="image/png">iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAACxIAAAsSAdLdfvwAAAAZdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuMTZEaa/1AAAA9klEQVRYR+2U0Q3DIAxEM0JG6GKVulkzSkbqBtQnsArWVTW0xIrUj2cJ25wdTFhSSqFkc72vwiYkB8hbrdAo2fiLK5sVGiUbpzDiJe/B4iNk82rgYhNqENdcGxslG/miIhx2AuF3IPYveAcKWh8DDQk78j+AnKb5RsiCTdbHKMKsIGNv9tYLCzZYH6MSv7E4QEzzGn+9sOiGDn7fgPUxJC98BLGX8BuoUzlNAzhWIW4ERZgVZPRdwk7CfsPwBuaNwPoYkvd/B4ahTsXbAI5ViBtBEWYFGSd6B7yoMIqwOEBM8xp/vRhFROeMwIuIzrmER0Cdx5GWJ2HIp5zjmg5LAAAAAElFTkSuQmCC</icon>
    <visible>1</visible>
    <title>Tree View</title>
    <description>Creates a tree view to display nodes.</description>
  </metadata>
  <parameter behavior="mandatory" desc="foreign object ID" name="renderTo" valuetype="string"/>
  <parameter behavior="optional" defaultvalue="AGENT.OBJECTS" desc="start address" name="startAddress" valuetype="address"/>
  <parameter behavior="mandatory" defaultvalue="100" desc="busy indicator delay" name="busyIndicatorTolerance" valuetype="number"/>
  <parameter behavior="optional" defaultvalue="3" desc="icon offset" name="expandoOffset" valuetype="number"/>
  <parameter behavior="optional" defaultvalue="12" desc="font size" name="fontSize" valuetype="number"/>
  <parameter behavior="optional" defaultvalue="{&quot;baseVariableImage&quot;:&quot;/treeView/icons/baseVariable.svg&quot;,&quot;folderImage&quot;:&quot;/treeView/icons/folder.svg&quot;,&quot;aggregateFunctionImage&quot;:&quot;/treeView/icons/aggregateFunction.svg&quot;,&quot;collapsedLeafImage&quot;:&quot;/treeView/icons/leafCollapsed.svg&quot;,&quot;expandedLeafImage&quot;:&quot;/treeView/icons/leafExpanded.svg&quot;}" desc="image paths" name="imagePaths" valuetype="string"/>
  <parameter behavior="optional" defaultvalue="15" desc="child indentation" name="leafIndentation" valuetype="number"/>
  <parameter behavior="optional" defaultvalue="2" desc="margin" name="leafPadding" valuetype="number"/>
  <parameter behavior="optional" defaultvalue="[&quot;baseVariable&quot;, &quot;aggregateFunction&quot;]" desc="type filter" name="selectableTypes" valuetype="string"/>
  <parameter behavior="optional" defaultvalue="100" desc="search depth" name="searchDepth" valuetype="string"/>
  <parameter behavior="mandatory" defaultvalue="treeView/datasources/opcua.js" desc="filename of datasource implementation" name="dataSourceFilePath" valuetype="string"/>
  <parameter behavior="mandatory" defaultvalue="SYSTEM.LIBRARY.ATVISE.OBJECTDISPLAYS.Advanced.dialogs.message_dialog_small" desc="display for error message" name="dialogDisplay" valuetype="display"/>
  <parameter behavior="mandatory" defaultvalue="opcUA" desc="name of data source" name="dataSourceType" valuetype="string"/>
  <parameter behavior="mandatory" defaultvalue="{}" desc="options for data source" name="dataSourceOptions" valuetype="string"/>
  <parameter behavior="optional" defaultvalue="true" desc="set caching behavior for tree view" name="nodeCacheActive" valuetype="bool"/>
  <code><![CDATA[return (function (window, document) {
	/**
	 * @callback {function} TreeView#eventCallback
	 * @param {object} data The corresponding node information.
	 * @param {HTMLNode} target The clicked html node.
	 */

	/**
	 * Fired when a node is expanded.
	 * @event TreeView#expand
	 * @type {object}
	 * @property {object} data The corresponding node information.
	 * @property {HTMLNode} target The clicked html node.
	 */

	/**
	 * Fired when all nodes are expanded by calling {@link TreeView#expandAll}
	 * @event TreeView#expandAll
	 * @type {object}
	 * @property {object} data The corresponding node information.
	 * @property {HTMLNode} target The clicked html node.
	 */

	/**
	 * Fired when a node is collapsed.
	 * @event TreeView#collapse
	 * @type {object}
	 * @property {object} data The corresponding node information.
	 * @property {HTMLNode} target The clicked html node.
	 */

	/**
	 * Fired when all nodes are collapsed by calling {@link TreeView#collapseAll}
	 * @event TreeView#collapseAll
	 * @type {object}
	 * @property {object} data The corresponding node information.
	 * @property {HTMLNode} target The clicked html node.
	 */

	/**
	 * Fired a node is selected.
	 * @event TreeView#select
	 * @type {object}
	 * @property {object} data The corresponding node information.
	 * @property {HTMLNode} target The clicked html node.
	 */

	/**
	 * Fired a single node that is rendered the first time. (The first time it is appended to the DOM)
	 * @event TreeView#render
	 * @type {object}
	 * @property {object} data The corresponding node information.
	 * @property {HTMLNode} target The clicked html node.
	 */

	/**
	 * Fired when the TreeView has finished its' initialization.
	 * @event TreeView#ready
	 * @type {object}
	 * @property {object} TreeViewInstance The instance of the TreeView to work on.
	 */
	var events = ["expand", "expandAll", "collapse", "collapseAll", "select", "notFound", "render", "ready"];

	let datasource;

	/**
	 * The configuration object for the TreeView.
	 * @typedef {object} TreeView#options
	 * @property {string} renderTo The id of the container to render the tree to.
	 * @property {string} [startAddress="AGENT.OBJECTS"] The opcUA Address to start displaying the tree from.
	 * @property {array} [selectableTypes = "[baseVariable, aggregateFunction]"] The types of leaves that can be selected. See {@link TreeView#types}
	 * @property {number} [fontSize=12] The font size for the treeView [px].
	 * @property {number} [leafPadding=2] The padding top and bottom between the leaves [px]
	 * @property {number} [leafIndentation=15] The indentation for child leaves [px]
	 * @property {number} [expandoOffset=3] The distance from the expando to the leaf icon[px]
	 * @property {number} [expandoOffset=3] The distance from the expando to the leaf icon[px]
	 * @property {number} [busyIndicatorTolerance=100] The time to has to pass by to start displaying the busy indicator [ms]
	 * @property {number} [searchDepth=100] The folder depth to use for filtering internally.
	 * @property {number} [navigationDepth=100] The folder depth to use for navigating internally.
	 * @property {object} imagePaths The image paths for the tree icons.
	 *     See default:
	 *        <p>- baseVariableImage: "/treeView/icons/baseVariable.svg" </p>
	 *        <p>- folderImage: "/treeView/icons/folder.svg" </p>
	 *        <p>- aggregateFunctionImage: "/treeView/icons/aggregateFunction.svg" </p>
	 *        <p>- collapsedLeafImage: "/treeView/icons/leafCollapsed.svg" </p>
	 *        <p>- expandedLeafImage: "/treeView/icons/leafExpanded.svg" </p>
	 */
	var defaultOptions = {
		renderTo: "",
		startAddress: "AGENT.OBJECTS",
		aggregateAddressPrefix: "AGENT.HISTORY.AGGREGATETEMPLATES",
		dataSourceFilePath: "treeView/datasources/opcua.js",
		fontSize: 12,
		leafPadding: 2,
		leafIndentation: 15,
		busyIndicatorTolerance: 100,
		expandoOffset: 3,
		searchDepth: 100,
		navigationDepth: 1,
		imagePaths: {
			baseVariableImage: "/treeView/icons/baseVariable.svg",
			folderImage: "/treeView/icons/folder.svg",
			aggregateFunctionImage: "/treeView/icons/aggregateFunction.svg",
			collapsedLeafImage: "/treeView/icons/leafCollapsed.svg",
			expandedLeafImage: "/treeView/icons/leafExpanded.svg"
		}
	};

	/**
	 * A helper method for parsing the data-item of a node
	 * @param {HTMLElement} node The corresponding DOM-node
	 * @return {string} object The parsed data-item
	 * @memberOf TreeView
	 * @private
	 */
	function getDataFromNode(node) {
		if (node) {
			return JSON.parse(node.getAttribute("data-item"));
		} else {
			return undefined;
		}
	}

	/**
	 * A class that represents a tree view that shows opcUA nodes.
	 * @param {TreeView#options} options Configuration options.
	 * @class
	 * @alias TreeView
	 */
	class TreeView {
		constructor(options) {
			this.internal = {};
			this.internal.doc = document;
			this.internal.win = window;
			this.internal.options = mergeData(defaultOptions, options);
			this.internal.eventListeners = [];
			this.internal.selectedNodeData = {};
			this.internal.selectedNode = undefined;
			this.internal.scrollWrapper = null;
			this.internal.container = null;
			this.internal.busyIndicator = null;
			this.internal.busyIndicatorWrapper = null;
			this.internal.handlers = {};
			this.internal.node = options.renderTo;
			this.internal.availableAddresses = [];
			this.internal.initialized = false;
			this.internal.adHocMode = false;
			initialize(this);

			if (options.dataSourceType === "" || options.dataSourceFilePath === "") {
				this.internal.adHocMode = true;
				datasource = {};
				this.setSelectableTypes = function (selectableTypes) {
					this.internal.options.selectableTypes = selectableTypes;
				};

				this.setTreeStructure = function (treeStructure) {
					datasource.treeStructure = treeStructure;
					datasource.fetchTreeStructure = function (browseNodeId) {
						return new Promise((resolve) => {
							const treeStructure = [];
							let subTree;

							function findById(treeStructure, browseNodeId) {
								for (let node of treeStructure) {
									if (node.id === browseNodeId) return node;

									if (node.children) {
										let desiredNode = findById(node.children, browseNodeId);
										if (desiredNode) return desiredNode;
									}
								}
								return false;
							}

							if (browseNodeId) {
								subTree = findById(datasource.treeStructure, browseNodeId);
							} else {
								subTree = { children: datasource.treeStructure };
							}

							subTree.children.forEach((item) => {
								var iconElement = document.createElement("img");

								if (options.imagePaths[item.type]) {
									iconElement.src = "en" + options.imagePaths[item.type];
								}

								treeStructure.push({
									name: item.name || item.id,
									address: item.address || item.id,
									type: item.type,
									hasChildren: !!(item.children && item.children.length),
									children: item.children || [],
									dataID: item.id,
									icon: iconElement
								});
							});

							if (treeStructure.error) {
								reject(treeStructure);
							} else {
								resolve(treeStructure);
							}
						});
					};

					return datasource
						.fetchTreeStructure(this.internal.options.startAddress)
						.then(this.renderDataToDOM.bind(this));
				};
			} else {
				webMI.data.loadScript(options.dataSourceFilePath, () => {
					const type = options.dataSourceType;
					datasource = new webMI.rootWindow.treeViewDatasources[type](this.internal.options);
					this.internal.options.selectableTypes = datasource.getSelectableTypes();
					datasource.fetchTreeStructure().then(this.renderDataToDOM.bind(this));
				});
			}

			webMI.addOnunload(this.destroy.bind(this));
		}
		/**
		 * Expands a leaflet by the expando or the leaf text
		 * @param {HTMLElement} node The node that has the data-item attribute on it.
		 * @param {boolean} skipEmit Option to prevent treeView event
		 */
		expand(node, skipEmit) {
			var data = getDataFromNode(node);
			var leaves = getChildLeaves(node);

			if (data.hasChildren) {
				if (leaves) {
					leaves.classList.remove("hidden");
					var expando = node.querySelector(".tree-expando");
					expando.src = this.internal.options.languagePrefix + this.internal.options.imagePaths.expandedLeafImage;
					updateScroller(this);
					if (!skipEmit) {
						emit(this, "expand", {
							target: node,
							data: getDataFromNode(node)
						});
					}
				} else {
					showBusyIndicator(this);
					datasource
						.fetchTreeStructure(data.address, node)
						.then((response) => {
							this.renderDataToDOM.bind(this)(response, node);
						})
						.catch((error) => {
							let message = error.toString();

							// Limit message to 200 character and append ellipsis
							if (message.length > 200) {
								message = error.toString().substring(0, 200) + " â€¦";
							}

							this.dialog = webMI.display.openWindow({
								display: base.dialogDisplay,
								height: 160,
								width: 400,
								modal: true,
								resizable: false,
								movable: true,
								scrollbars: false,
								menubar: false,
								status: false,
								toolbar: false,
								query: {
									headline: "T{Tree View} T{Error}!",
									message: message,
									action_btn1: "com.atvise.tree_view_error_dialog"
								}
							});

							if (this.dialog) {
								this.dialog.cuba = function () {
									this.dialog = null;
								};
							}

							webMI.trigger.connect("com.atvise.tree_view_error_dialog", () => {
								webMI.display.closeWindow(this.dialog);
								this.dialog = null;
							});
							console.error(error);
							hideBusyIndicator(this);
						});
				}
			}
		}
		/**
		 * Expands all leaves
		 */
		expandAll() {
			var self = this;
			if (self.expandAllInProgress) {
				return;
			}
			self.expandAllInProgress = true;
			showBusyIndicator(self);

			datasource.fetchAvailableNodeAdresses(function (addresses) {
				self.internal.availableAddresses = addresses;
				expandNodeList(self, flattenAddresses(self.internal.availableAddresses), function () {
					emit(self, "expandAll", {});
					hideBusyIndicator(self);
					self.expandAllInProgress = false;
				});
			});
		}
		/**
		 * Collapses a leaf by the expando or the leaf text
		 * @param {HTMLElement} node  The node that has the data-item attribute on it.
		 * @param {boolean} skipEmit Option to prevent treeView event
		 */
		collapse(node, skipEmit) {
			var leaves = getChildLeaves(node);

			leaves.classList.add("hidden");
			var expando = node.querySelector(".tree-expando");
			expando.src = this.internal.options.languagePrefix + this.internal.options.imagePaths.collapsedLeafImage;
			updateScroller(this);
			if (skipEmit) {
				return;
			}
			emit(this, "collapse", {
				target: node,
				data: getDataFromNode(node)
			});
		}
		/**
		 * Collapses all leaves
		 */
		collapseAll() {
			var self = this;
			var nodes = this.internal.container.querySelectorAll(".tree-expando");
			forEach(nodes, function (node) {
				var parent = node.parentNode;
				var leaves = parent.parentNode.querySelector(".tree-child-leaves");
				if (parent && leaves && parent.hasAttribute("data-item")) {
					self.collapse(parent, true);
				}
			});
			emit(this, "collapseAll", {});
		}
		/**
		 * Get the data for the currently selected tree element
		 * @return {object} data Data from selected element
		 */
		getSelectedNode() {
			return this.internal.selectedNodeData;
		}
		/**
		 * Select a specifc node in the tree.
		 * @param {string} nodePath Nodeaddress to select
		 * @param {string} aggregatePath Aggreateaddress to select. (in relation to the nodePath)
		 * @param {boolean} skipCollapse Omit collapsing all nodes.
		 */
		selectNode(nodePath, aggregatePath, skipCollapse) {
			var self = this;
			var nodeAddresses = [];
			if (this.internal.adHocMode || !isNaN(Number(nodePath.slice(0, nodePath.indexOf("."))))) {
				nodeAddresses.push(nodePath);
			} else {
				nodeAddresses = buildAddressList(self, nodePath, aggregatePath);
			}

			if (!self || !self.internal) return;

			if (self.selectInProgress) {
				return;
			}

			self.selectInProgress = true;
			showBusyIndicator(self);

			if (!skipCollapse) {
				this.collapseAll();
			}

			expandNodeList(self, nodeAddresses, function (result) {
				var selectElement = result.relatedNode;
				if (selectElement === null) {
					selectElement = result.lastValidNode;
				}
				if (selectElement) {
					let scrollerInterval;
					processSelection(self, selectElement.querySelector(".tree-leaf-text"), null);

					if (!self.internal.scroller) {
						scrollerInterval = setInterval(() => {
							if (self.internal.scroller) {
								self.internal.scroller.scrollToElement(selectElement);
								clearInterval(scrollerInterval);
							}
						}, 100);
					} else {
						self.internal.scroller.scrollToElement(selectElement);
					}
				} else {
					processSelection(self);
				}

				self.selectInProgress = false;
				hideBusyIndicator(self);
			});
		}
		/**
		 * Only show nodes in the tree that contain the search-string in their path.
		 * @param {string} searchString The string to filter for.
		 * @param {boolean} refreshSearchData Refresh the nodesdata used for filter. (use this when the nodes have been updated on the server side)
		 */
		filter(searchString, refreshSearchData) {
			var self = this;
			var results = {};

			if (!self || !self.internal) return;

			if (self.filterInProgress) {
				console.warn("Filtering for term: " + searchString + " omitted, because filterprocess is busy.");
				return;
			}

			self.filterInProgress = true;
			showBusyIndicator(self);

			if (refreshSearchData || self.internal.availableAddresses.length < 1) {
				datasource.fetchAvailableNodeAdresses(function (availableAddresses) {
					self.internal.availableAddresses = availableAddresses;
					results = getSearchResults(self, searchString);

					self.collapseAll();
					filterNodes(self, results.searchResults, results.negativeResults, searchString, function () {
						self.filterInProgress = false;
						hideBusyIndicator(self);
					});
				});
			} else {
				results = getSearchResults(self, searchString);
				self.collapseAll();
				filterNodes(self, results.searchResults, results.negativeResults, searchString, function () {
					self.filterInProgress = false;
					hideBusyIndicator(self);
				});
			}
		}
		/**
		 * Attach an event handler to the tree view
		 * @param {string} name Name of the event to attach
		 * @param {TreeView#eventCallback} callback The callback to execute on the event
		 * @param {object} scope The context to call the callback with
		 */
		on(name, callback, scope) {
			if (events.indexOf(name) > -1) {
				if (!this.internal.handlers[name]) {
					this.internal.handlers[name] = [];
				}
				this.internal.handlers[name].push({
					callback: callback,
					context: scope
				});

				//execute ready callback immediately if initialization is already complete
				if (name === "ready" && this.internal.initialized === true) {
					emit(this, "ready", this);
				}
			} else {
				throw new Error(name + " is not supported by TreeView.");
			}
		}
		/**
		 * Attach an event handler to the tree view and remove it automatically after it has been executed the first time.
		 * @param {string} name Name of the event to attach
		 * @param {TreeView#eventCallback} callback The callback to execute on the event
		 * @param {object} scope The context to call the callback with
		 */
		one(name, callback, scope) {
			if (events.indexOf(name) > -1) {
				if (!this.internal.handlers[name]) {
					this.internal.handlers[name] = [];
				}
				this.internal.handlers[name].push({
					callback: callback,
					context: scope,
					one: true
				});
			} else {
				throw new Error(name + " is not supported by TreeView.");
			}
		}
		/**
		 * Detach an event handler from the tree view
		 * @param {string} name Name of the event to detach
		 * @param {TreeView#eventCallback} callback The function to detach
		 */
		off(name, callback) {
			var index,
				found = false;
			if (this.internal.handlers[name] instanceof Array) {
				this.internal.handlers[name].forEach(function (handle, i) {
					index = i;
					if (handle.callback === callback && !found) {
						found = true;
					}
				});
				if (found) {
					this.internal.handlers[name].splice(index, 1);
				}
			}
		}
		/**
		 * Destroy the TreeView and release memory
		 */
		destroy() {
			this.internal.handlers = null;
			for (var i = 0; i < this.internal.eventListeners.length; i++) {
				var listenerObj = this.internal.eventListeners[i];
				listenerObj.node.removeEventListener(listenerObj.event, listenerObj.callback, false);
			}
			while (this.internal.scrollWrapper.firstChild) {
				this.internal.scrollWrapper.removeChild(this.internal.scrollWrapper.firstChild);
			}
			if (this.internal.busyIndicatorTimeout) {
				this.internal.win.clearTimeout(this.internal.busyIndicatorTimeout);
			}
			this.internal.scroller.destroy();
			this.internal.scroller = null;
			this.internal.doc = null;
			this.internal.win = null;
			this.internal.scrollWrapper = null;
			this.internal.selectedNodeData = null;
			this.internal.selectedNode = null;
			this.internal.busyIndicator = null;
			this.internal.busyIndicatorWrapper = null;
			this.internal.container = null;
			this.internal.eventListeners = null;
			this.internal.availableAddresses = null;
			this.internal.initialized = null;
			this.internal = null;

			this.selectInProgress = null;
			this.filterInProgress = null;
			this.expandAllInProgress = null;
		}
		/**
		 * A method that takes the data to display in the treeView and appends the HTML elements to the DOM
		 * @param {HTMLElement} container The DOM element the data should be rendered to (can also be a leaf element)
		 * @param {object} data The data that should be appended to the dom
		 * @param {object} self The TreeView instance
		 * @fires TreeView#render
		 * @memberOf TreeView
		 * @private
		 */
		renderDataToDOM(data, container) {
			const self = this;

			if (!self || !self.internal) return;

			if (!container) {
				container = self.internal.container;
			}
			var leaves = [];
			forEach(data, function (item) {
				leaves.push(renderLeaf.call(self, item));
			});

			if (container !== self.internal.container) {
				var childContainer = self.internal.doc.createElement("div");
				childContainer.setAttribute("class", "tree-child-leaves");
				childContainer.style.marginLeft = self.internal.options.leafIndentation + "px";
				container.parentNode.appendChild(childContainer);
				container = childContainer;
			}

			container.innerHTML = leaves
				.map(function (leaf) {
					return leaf.outerHTML;
				})
				.join("");

			forEach(container.querySelectorAll(".tree-leaf-text"), function (node) {
				if (isMobileTouchDevice) {
					node.addEventListener("touchstart", clickHandler.bind(self), false);
					self.internal.eventListeners.push({
						node: node,
						event: "touchstart",
						callback: clickHandler.bind(self)
					});
				} else {
					node.addEventListener("click", clickHandler.bind(self), false);
					self.internal.eventListeners.push({
						node: node,
						event: "click",
						callback: clickHandler.bind(self)
					});
				}
				node.addEventListener("dblclick", dblClickHandler.bind(self), false);
				self.internal.eventListeners.push({
					node: node,
					event: "dblclick",
					callback: dblClickHandler.bind(self)
				});
			});
			forEach(container.querySelectorAll(".tree-expando"), function (node) {
				if (isMobileTouchDevice) {
					node.addEventListener("touchstart", clickHandler.bind(self), false);
					self.internal.eventListeners.push({
						node: node,
						event: "touchstart",
						callback: clickHandler.bind(self)
					});
				} else {
					node.addEventListener("click", clickHandler.bind(self), false);
					self.internal.eventListeners.push({
						node: node,
						event: "click",
						callback: clickHandler.bind(self)
					});
				}
			});

			if (self.internal.initialized === false) {
				emit(self, "ready", self);
				self.internal.initialized = true;
			}

			//when child leaves were loaded from server or selection or filtering, emit expand event
			if (
				container !== self.internal.container &&
				!self.selectInProgress &&
				!self.filterInProgress &&
				!self.expandAllInProgress
			) {
				var targetNode = container.parentNode.querySelector(".tree-leaf-content");
				emit(self, "expand", {
					target: targetNode,
					data: getDataFromNode(targetNode)
				});
				hideBusyIndicator(self);
			}
			emit(self, "render", {
				target: targetNode,
				data: getDataFromNode(targetNode)
			});
			updateScroller(self);
		}
	}

	/**
	 * Initialize the tree view
	 * @param {object} self The TreeView instance
	 * @memberOf TreeView
	 * @private
	 */
	function initialize(self) {
		self.internal.scrollWrapper = self.internal.doc.getElementById(self.internal.node);
		if (self.internal.scrollWrapper === null) {
			self.internal.doc = self.internal.win.frameElement.ownerDocument;
			self.internal.win = self.internal.doc.defaultView;
			self.internal.scrollWrapper = self.internal.doc.getElementById(self.internal.node);
			if (self.internal.scrollWrapper === null) {
				throw new Error("Node '" + self.internal.node + "' not found!");
			}
		}
		self.internal.scrollWrapper.classList.add("tree-wrapper");
		self.internal.container = self.internal.doc.createElement("div");
		self.internal.scrollWrapper.appendChild(self.internal.container);
		self.internal.container.style.fontSize = self.internal.options.fontSize + "px";
		self.internal.container.classList.add("tree-container");
		self.internal.busyIndicator = self.internal.doc.createElement("div");
		self.internal.busyIndicator.classList.add("tree-busy-indicator");
		self.internal.busyIndicatorWrapper = self.internal.doc.createElement("div");
		self.internal.busyIndicatorWrapper.classList.add("tree-busy-indicator-wrapper");
		self.internal.busyIndicatorWrapper.classList.add("hidden");
		self.internal.busyIndicatorWrapper.appendChild(self.internal.busyIndicator);
		self.internal.scrollWrapper.appendChild(self.internal.busyIndicatorWrapper);

		var languageName = "";
		for (var language in project.languages) {
			languageName = language;
			break;
		}
		self.internal.options.languagePrefix = languageName;

		loadRelatedCSS(self);
		webMI.data.loadScript("other/atvise.iscroll.js", initScrollbars.bind(self));
	}

	/**
	 * Initialize the scrollbar (IScroll)
	 * @memberOf TreeView
	 * @private
	 */
	function initScrollbars() {
		this.internal.scroller = new this.internal.win.IScroll(this.internal.scrollWrapper, {
			preventDefaultException: { className: /(^|\s)tree-leaf-text|tree-expando(\s|$)/ },
			preventDefault: true,
			useTransform: false,
			useTransition: false,
			mouseWheel: true,
			scrollbars: true,
			bounce: false,
			mouseWheelSpeed: 1,
			disablePointer: true,
			disableMouse: false,
			disableTouch: false,
			momentum: true,
			scrollX: true,
			scrollY: true,
			tap: false,
			bindToWrapper: true,
			interactiveScrollbars: true,
			HWCompositing: false
		});
	}

	/**
	 * @param {object} self The treeview instance.
	 * @memberOf TreeView
	 * @private
	 */
	function loadRelatedCSS(self) {
		if (self.internal.doc.getElementById("treeViewStyle") == null) {
			var fileref = self.internal.doc.createElement("link");
			fileref.rel = "stylesheet";
			fileref.id = "treeViewStyle";
			fileref.type = "text/css";
			fileref.href = "/treeView/css/treeViewStyle.css";
			self.internal.doc.getElementsByTagName("head")[0].appendChild(fileref);
		}
	}

	/**
	 * Update the scrollbar when content has changed
	 * @param {object} self The TreeView instance
	 * @memberOf TreeView
	 * @private
	 */
	function updateScroller(self) {
		if (!self.internal) return;

		self.internal.win.setTimeout(function () {
			if (self.internal && self.internal.scroller) {
				self.internal.scroller.refresh();
			}
		}, 0);
	}

	/**
	 * Emit an event from the tree view
	 * @param {object} self The TreeView instance
	 * @param {string} name The name of the event to emit
	 * @memberOf TreeView
	 * @private
	 */
	function emit(self, name) {
		var args = [].slice.call(arguments, 2);
		if (events.indexOf(name) > -1) {
			if (self.internal.handlers[name] && self.internal.handlers[name] instanceof Array) {
				forEach(self.internal.handlers[name], function (handle) {
					self.internal.win.setTimeout(function () {
						handle.callback.apply(handle.context, args);
						if (handle.one) {
							self.off(name, handle.callback);
						}
					}, 0);
				});
			}
		} else {
			throw new Error(name + " event cannot be found on TreeView.");
		}
	}

	/**
	 * A Handler that is executed for every dblclick on a leaf.
	 * @param {Event} e The event object passed by the browser
	 * @memberOf TreeView
	 * @private
	 */
	function dblClickHandler(e) {
		var targetNode = e.target || e.currentTarget;
		if (targetNode.classList.contains("tree-leaf-text")) {
			handleLeafClick(this, targetNode.parentNode);
		}
	}

	/**
	 * A Handler that is executed for every click on a leaf.
	 * @param {Event} e The event object passed by the browser
	 * @memberOf TreeView
	 * @private
	 */
	function clickHandler(e) {
		e.preventDefault();
		var targetNode = e.target || e.currentTarget;
		if (targetNode.classList.contains("tree-leaf-text")) {
			processSelection(this, targetNode, e);
		} else if (targetNode.classList.contains("tree-expando")) {
			handleLeafClick(this, targetNode.parentNode);
		}
	}

	/**
	 * A method that adds the selection class to the leaf text.
	 * @param {object} self The treeVIew instance
	 * @param {HTMLElement} targetNode The HTMLElement the user has clicked on
	 * @param {Event} event The event delivered by the browser
	 * @memberOf TreeView
	 * @private
	 */
	function processSelection(self, targetNode, event) {
		if (self.internal.selectedNode && self.internal.selectedNode !== null) {
			self.internal.selectedNode.classList.remove("selected");
			self.internal.selectedNode = null;
			self.internal.selectedNodeData = null;
		}

		if (targetNode) {
			var data = getDataFromNode(targetNode.parentNode);
			if (data.type == "folder") {
				handleLeafClick(self, targetNode.parentNode);
				return;
			}

			if (!event) {
				// User hasn't clicked or touched anything. Create a pseudo event for handling in opt_series display.
				event = {
					target: targetNode
				};
			}

			var selectableValid = false;
			for (var i = 0; i < self.internal.options.selectableTypes.length; i++) {
				if (self.internal.options.selectableTypes[i] == data.type) {
					selectableValid = true;
					break;
				}
			}

			if (selectableValid) {
				emit(self, "select", {
					event: event,
					data: data
				});

				self.internal.selectedNode = targetNode;
				self.internal.selectedNodeData = data;
				targetNode.classList.add("selected");
			}
		} else {
			emit(self, "notFound", {});
		}
	}

	/**
	 * A method that triggers collapsing or expanding of a node.
	 * @param {object} self The TreeView instance
	 * @param {HTMLElement} targetNode The node that has the data-item attribute.
	 * @memberOf TreeView
	 * @private
	 */
	function handleLeafClick(self, targetNode) {
		var leaves = getChildLeaves(targetNode);
		if (leaves) {
			if (leaves.classList.contains("hidden")) {
				self.expand(targetNode);
			} else {
				self.collapse(targetNode);
			}
		} else {
			self.expand(targetNode);
		}
	}

	/**
	 * A method that displays the busy indicator.
	 * @param {object} self The TreeView instance
	 * @memberOf TreeView
	 * @private
	 */
	function showBusyIndicator(self) {
		if (!self.internal.busyIndicatorTimeout || self.internal.busyIndicatorTimeout === null) {
			self.internal.busyIndicatorTimeout = self.internal.win.setTimeout(function () {
				self.internal.busyIndicatorWrapper.classList.remove("hidden");
			}, self.internal.options.busyIndicatorTolerance);
		}
	}

	/**
	 * A method that hides the busy indicator.
	 * @param {object} self The TreeView instance
	 * @memberOf TreeView
	 * @private
	 */
	function hideBusyIndicator(self) {
		self.internal.win.clearTimeout(self.internal.busyIndicatorTimeout);
		self.internal.busyIndicatorTimeout = null;
		self.internal.busyIndicatorWrapper.classList.add("hidden");
	}

	/**
	 * A method that render a single leaf and returns the created HTML elements
	 * @param {object} item The data that represents the leaf
	 * @return {HTMLElement} leaf The HTML node that was created
	 * @memberOf TreeView
	 * @private
	 */
	function renderLeaf(item) {
		if (!this.internal) return;

		if (item.dataID) {
			var dataID = item.dataID;
			delete item.dataID;
		}

		var leaf = this.internal.doc.createElement("div");
		var content = this.internal.doc.createElement("div");
		var text = this.internal.doc.createElement("div");
		var expando = this.internal.doc.createElement("img");
		var icon = false || item.icon;
		var iconImgElement;

		// Check if icon is an img element
		if (icon && icon.tagName?.toUpperCase() !== "IMG") {
			iconImgElement = webMI.rootWindow.document.createElement("img");
			iconImgElement.src = this.internal.options.languagePrefix + icon;

			icon = iconImgElement;
		} else if (!icon) {
			iconImgElement = webMI.rootWindow.document.createElement("img");
			iconImgElement.style.height = 0;
			iconImgElement.style.width = 0;

			icon = iconImgElement;
		}

		icon.setAttribute("class", "tree-icon");
		icon.style.marginLeft = this.internal.options.fontSize + this.internal.options.expandoOffset + "px";
		leaf.setAttribute("class", "tree-leaf");
		content.setAttribute("class", "tree-leaf-content");
		content.style.height = this.internal.options.fontSize + "px";
		content.style.paddingTop = this.internal.options.leafPadding + "px";
		content.style.paddingBottom = this.internal.options.leafPadding + "px";
		content.setAttribute("data-item", JSON.stringify(item));
		if (dataID) {
			content.setAttribute("data-id", dataID);
		}
		content.id = "address-" + item.address;
		text.setAttribute("class", "tree-leaf-text");
		text.textContent = item.name;
		if (item.hasChildren) {
			expando.setAttribute("class", "tree-expando");
			expando.style.top = this.internal.options.leafPadding + "px";
			expando.src = this.internal.options.languagePrefix + this.internal.options.imagePaths.collapsedLeafImage;
			content.appendChild(expando);
		}
		content.appendChild(icon);
		content.appendChild(text);
		leaf.appendChild(content);
		return leaf;
	}

	/**
	 * A method that searches for the occurence of a string in nodepaths.
	 * @param {object} self The TreeView instance
	 * @param {string} searchString The string to filter for.
	 * @return {object} results
	 * @memberOf TreeView
	 * @private
	 */
	function getSearchResults(self, searchString) {
		var negativeResults = [];
		var searchResults = [];

		for (var i = 0; i < self.internal.availableAddresses.length; i++) {
			var aggregateReference = self.internal.availableAddresses[i].aggregateReference;
			if (aggregateReference) {
				var aggregatePathString = aggregateReference.substring(
					aggregateReference.indexOf(aggregateReference.split(".")[4])
				);
			} else {
				aggregatePathString = "";
			}

			if (
				self.internal.availableAddresses[i].address.indexOf(searchString) !== -1 ||
				aggregatePathString.indexOf(searchString) !== -1
			) {
				searchResults.push(self.internal.availableAddresses[i]);
			} else {
				negativeResults.push(self.internal.availableAddresses[i]);
			}
		}

		if (searchString !== "") {
			return ensureFullPath(searchResults, negativeResults);
		}

		return { searchResults: searchResults, negativeResults: negativeResults };
	}

	/**
	 * A method that ensures that the full path of a filtered node is shown in the treeView.
	 * @param {array} searchResults An array that contains the node addresses that should be displayed.
	 * @param {array} negativeResults An array that contains the node addresses that should not be displayed.
	 * @return {object} updatedAddresses
	 * @memberOf TreeView
	 * @private
	 */
	function ensureFullPath(searchResults, negativeResults) {
		//ensure that the full path is filtered
		var additionalSearchResults = [];
		for (var i = 0; i < negativeResults.length; i++) {
			var negativeResult = negativeResults[i].address;
			for (var h = 0; h < searchResults.length; h++) {
				var searchResult = searchResults[h].address;
				if (searchResult.indexOf(negativeResult + ".") !== -1) {
					additionalSearchResults.push({
						additionalResult: negativeResults[i],
						insertBefore: searchResults[h]
					});
				}
			}
		}

		for (var j = 0; j < additionalSearchResults.length; j++) {
			var additionalResult = additionalSearchResults[j].additionalResult;
			var insertBefore = additionalSearchResults[j].insertBefore;

			searchResults.splice(searchResults.indexOf(insertBefore), 0, additionalResult);

			if (negativeResults.indexOf(additionalResult) !== -1) {
				negativeResults.splice(negativeResults.indexOf(additionalResult), 1);
			}
		}

		return { searchResults: searchResults, negativeResults: negativeResults };
	}

	/**
	 * A method that invokes the expandation of nodes and hides non relevant ones for filtering.
	 * @param {object} self The TreeView instance
	 * @param {array} searchResults An array that contains the node addresses that should be displayed.
	 * @param {array} negativeResults An array that contains the node addresses that should not be displayed.
	 * @param {string} searchString The string to filter for.
	 * @param {function} doneCallback The callbacl function that is invoked when the filtering is complete.
	 * @memberOf TreeView
	 * @private
	 */
	function filterNodes(self, searchResults, negativeResults, searchString, doneCallback) {
		var nodeExpandations = [];

		for (var h = 0; h < searchResults.length; h++) {
			var address = searchResults[h].address;
			var aggregateReference = searchResults[h].aggregateReference;

			var htmlNode = self.internal.doc.getElementById("address-" + address);
			if (htmlNode) {
				htmlNode.style.display = "";
			}

			if (searchString !== "") {
				nodeExpandations.push(
					function (address, aggregateReference) {
						var nodeAddresses = buildAddressList(self, address, aggregateReference);

						return new Promise(function (resolve) {
							expandNodeList(self, nodeAddresses, function () {
								resolve();
							});
						});
					}.bind(self, address, aggregateReference)
				);
			} else {
				nodeExpandations.push(function () {
					return Promise.resolve();
				});
			}
		}

		//run promise chain
		nodeExpandations
			.reduce(function (prev, curr) {
				return prev.then(curr);
			}, Promise.resolve())
			.then(function () {
				for (var j = 0; j < negativeResults.length; j++) {
					var address = negativeResults[j].address;
					var htmlNode = self.internal.doc.getElementById("address-" + address);
					if (htmlNode) {
						htmlNode.style.display = "none";
					}
				}
				doneCallback();
			});
	}

	/**
	 * A method that builds out of the nodeAddress and aggregateAddress a sequential list of nodes that have to be expanded after each other.
	 * @param {object} self The TreeView instance
	 * @param {string} nodePath The address of the node.
	 * @param {string} aggregatePath The address of the aggregate.
	 * @return {Array} nodeAddresses
	 * @memberOf TreeView
	 * @private
	 */
	function buildAddressList(self, nodePath, aggregatePath) {
		var nodeAddresses = [];

		try {
			var startAddress = self.internal.options.startAddress;
			var aggregateAddressPrefix = self.internal.options.aggregateAddressPrefix;

			var subPath = nodePath.substring(nodePath.indexOf(startAddress) + startAddress.length + 1); //+ 1 cut off first dot
			var nodeFragments = subPath.split(".");

			if (subPath != "") nodePath = startAddress;

			//build nodeAddresses
			for (var i = 0; i < nodeFragments.length; i++) {
				if (nodeFragments[i]) nodePath = nodePath + "." + nodeFragments[i];
				nodeAddresses.push(nodePath);
			}

			if (aggregatePath && aggregatePath.length > 0) {
				var aggregateSubPath = aggregatePath.substring(
					aggregatePath.indexOf(aggregateAddressPrefix) + aggregateAddressPrefix.length + 1
				); //+ 1 cut off first dot
				var aggregateTemplateName = aggregateSubPath.split(".", 1)[0];
				aggregateAddressPrefix = aggregateAddressPrefix + "." + aggregateTemplateName;
				nodeAddresses.push(aggregateAddressPrefix);
				var aggregateFragments = aggregateSubPath.split(".");

				//build nodeAddresses for aggregates
				for (var h = 1; h < aggregateFragments.length; h++) {
					aggregateAddressPrefix = aggregateAddressPrefix + "." + aggregateFragments[h];
					nodeAddresses.push(aggregateAddressPrefix);
				}
			}
		} catch (ex) {
			// already invalidated
			// console.error(ex);
		}

		return nodeAddresses;
	}

	/**
	 * A method that expands nodes from a list sequentially.
	 * @param {object} self The TreeView instance.
	 * @param {array} nodeAddresses A list of addresses of nodes and aggregates.
	 * @param {function} doneCallback A callback function that is invoked after all nodes have been expanded.
	 * @memberOf TreeView
	 * @private
	 */
	function expandNodeList(self, nodeAddresses, doneCallback) {
		var expandSteps = [];
		var lastValidHtmlNode = null;

		//push functions for loading nodeAddresses into array
		for (var h = 0; h < nodeAddresses.length; h++) {
			var address = nodeAddresses[h];

			expandSteps.push(
				function (address) {
					var htmlNode = self.internal.doc.getElementById("address-" + address);

					//do not expand last element and ensure htmlNode exists
					if (address !== nodeAddresses[nodeAddresses.length - 1] && htmlNode !== null) {
						if (address.indexOf(this.internal.options.aggregateAddressPrefix) === -1) {
							lastValidHtmlNode = htmlNode;
						}

						self.expand(htmlNode, true);
						var data = getDataFromNode(htmlNode);

						//if node has children and it's childleaves are not loaded yet, wait for expand event
						if (data.hasChildren && !getChildLeaves(htmlNode)) {
							return new Promise(function (resolve) {
								self.one("render", function () {
									resolve({ relatedNode: htmlNode, lastValidNode: lastValidHtmlNode });
								});
							});
						} else {
							return Promise.resolve({ relatedNode: htmlNode, lastValidNode: lastValidHtmlNode });
						}
					} else {
						return Promise.resolve({ relatedNode: htmlNode, lastValidNode: lastValidHtmlNode });
					}
				}.bind(self, address)
			);
		}

		//run promise chain
		expandSteps
			.reduce(function (prev, curr) {
				return prev.then(curr);
			}, Promise.resolve())
			.then(function (result) {
				doneCallback(result);
			});
	}

	/**
	 * A helper method that returns the child leaves of a node.
	 * @param {HTMLElement} node
	 * @return {boolean}
	 * @memberOf TreeView
	 * @private
	 */
	function getChildLeaves(node) {
		var leaves = node.parentNode.querySelector(".tree-child-leaves");
		if (leaves) {
			return leaves;
		} else {
			return false;
		}
	}

	/**
	 * A helper method that builds a flat array of an array of objects (object-specific)
	 * @param {array} addresses
	 * @return {array} flattenedArray
	 * @memberOf TreeView
	 * @private
	 */
	function flattenAddresses(addresses) {
		var flattenedArray = [];

		for (var i = 0; i < addresses.length; i++) {
			flattenedArray.push(addresses[i].address);
			if (addresses[i].aggregateReference) {
				flattenedArray.push(addresses[i].aggregateReference);
			}
		}

		return flattenedArray;
	}

	/**
	 * A helper method to merge to objects recursively
	 * @param {object} data The base-object
	 * @param {object} addData The data to add recursively to the base object
	 * @memberOf TreeView
	 * @private
	 */
	function mergeData(data, addData) {
		for (var p in addData) {
			try {
				// Property in destination object set; update its value.
				if (addData[p].constructor === Object) {
					data[p] = mergeData(data[p], addData[p]);
				} else {
					data[p] = addData[p];
				}
			} catch (e) {
				// Property in destination object not set; create it and set its value.
				data[p] = addData[p];
			}
		}
		return data;
	}

	/**
	 * A forEach that will work with a NodeList and generic Arrays
	 * @param {Array} arr The array to iterate over
	 * @param {function} callback Function that executes for each element. First parameter is element, second is index
	 * @param {object} scope The context to execute callback with
	 * @memberOf TreeView
	 * @private
	 */
	function forEach(arr, callback, scope) {
		var i,
			len = arr.length;
		for (i = 0; i < len; i += 1) {
			callback.call(scope, arr[i], i);
		}
	}

	// Ensure correct types for options
	var options = {};
	for (const key in base) {
		switch (key) {
			// Strings
			case "renderTo":
			case "dataSourceType":
			case "dataSourceFilePath":
			case "startAddress":
				options[key] = base[key];
				break;
			// Booleans
			case "nodeCacheActive":
				options[key] = base[key] === "true" ? true : false;
				break;
			// JSON-Strings
			case "selectableTypes":
			case "imagePaths":
				options[key] = JSON.parse(base[key]);
				break;
			// Numbers
			case "searchDepth":
			case "fontSize":
			case "leafPadding":
			case "leafIndentation":
			case "busyIndicatorTolerance":
			case "expandoOffset":
				options[key] = parseFloat(base[key]);
				break;
		}
	}

	if (typeof options["dataSourceFilePath"] === "undefined" && base.dataSourceType === "opcUA") {
		options["dataSourceFilePath"] = "treeView/datasources/opcua.js";
	}

	if (typeof base.dataSourceOptions === "object") {
		options.dataSourceOptions = base.dataSourceOptions;
	} else if (typeof base.dataSourceOptions === "string") {
		try {
			options.dataSourceOptions = JSON.parse(base.dataSourceOptions);
		} catch (err) {
			if (err instanceof SyntaxError) {
				if (options.dataSourceType === "scope") {
					// Fallback for legacy scope options
					options.dataSourceOptions = { host: base.dataSourceOptions };
				} else {
					throw new Error("dataSourceOptions must be an object or a JSON string.");
				}
			}
		}
	} else {
		throw new Error("dataSourceOptions must be an object or a JSON string.");
	}

	// Move dataSourceOptions up one level
	for (const key in options.dataSourceOptions) {
		options[key] = options.dataSourceOptions[key];
	}

	delete options.dataSourceOptions;

	return new TreeView(options);
})(window, document);
]]></code>
</script>
