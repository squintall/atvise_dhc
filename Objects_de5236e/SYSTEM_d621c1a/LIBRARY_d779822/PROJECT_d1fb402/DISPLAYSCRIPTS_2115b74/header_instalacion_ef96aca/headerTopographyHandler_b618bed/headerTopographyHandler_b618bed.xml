<?xml version="1.0" encoding="UTF-8"?>
<script>
  <metadata>
    <priority>0</priority>
    <help/>
  </metadata>
  <code><![CDATA[/* -*- coding: utf-8 -*- */
/* HANDLER â€” HTML-only render. Columns by level with foreign rule; forward-only arrows. Tabs. */

/* ===== Helpers TE en la misma celda ===== */
var TE_GAP_IN = 6; // separaciÃ³n interna entre Base y _TE
function isTE(id) { return /_TE$/i.test(String(id || '')); }
function baseId(id) { return String(id || '').replace(/_TE$/i, ''); }

/* ===== Query params ===== */
var TOPO_Q = (typeof webMI !== 'undefined' && webMI.query) || {};
var TOPO_BASE = (TOPO_Q.base || TOPO_Q["base"]) || "";
var TOPO_CFG_NODE = TOPO_Q.topoNode || (TOPO_BASE ? (TOPO_BASE + ".topoNode") : "");
var TOPO_TARGET_ID = TOPO_Q.topoTarget || "topo_root";

var TOPO_TILE_W = Number(TOPO_Q.tileW || 130);
var TOPO_TILE_H = Number(TOPO_Q.tileH || 40);
var TOPO_GAP_X = Number(TOPO_Q.gapX || 100);
var TOPO_GAP_Y = Number(TOPO_Q.gapY || 30);

/* ===== DOM helpers ===== */
if (typeof $ !== 'function') { function $(id) { return document.getElementById(id); } }
if (typeof clearEl !== 'function') {
    function clearEl(el) { try { while (el && el.firstChild) el.removeChild(el.firstChild); } catch (_) { } }
}
if (typeof ensureTopoContainer2 !== 'function') {
    function ensureTopoContainer2() {
        var el = $(TOPO_TARGET_ID);
        if (!el) {
            el = document.createElement('div');
            el.id = TOPO_TARGET_ID;
            el.style.position = 'relative';
            el.style.width = '100%'; el.style.height = '100%';
            (document.body || document.documentElement).appendChild(el);
        }
        return el;
    }
}

/* ===== Parse config ===== */
if (typeof parseTopoConfig !== 'function') {
    function parseTopoConfig(str) {
        if (!str || typeof str !== 'string') return { nodes: [], edges: [] };
        try { return JSON.parse(str); }
        catch (e) {
            try { return JSON.parse(str.replace(/,\s*([}\]])/g, '$1')); }
            catch (_) { return { nodes: [], edges: [] }; }
        }
    }
}

/* ===== Render ===== */
function renderTopography(cfg) {
    var target = ensureTopoContainer2();
    var mount = target;
    var isFO = (target && target.namespaceURI === 'http://www.w3.org/2000/svg' &&
        String(target.localName).toLowerCase() === 'foreignobject');
    if (isFO) {
        clearEl(target);
        var docFO = (target && target.ownerDocument) || document;
        var wrap = docFO.createElement('div');
        wrap.style.width = '100%'; wrap.style.height = '100%'; wrap.style.position = 'relative';
        target.appendChild(wrap); mount = wrap;
    } else {
        clearEl(target); mount.style.position = 'relative';
    }

    var doc = (mount && mount.ownerDocument) || document;

    // capa de nodos
    var layer = doc.createElement('div');
    layer.style.position = 'absolute';
    layer.style.left = '0'; layer.style.top = '0';
    layer.style.right = '0'; layer.style.bottom = '0';
    layer.style.zIndex = '1';
    if (typeof ensureArrowCss === 'function') ensureArrowCss(doc);
    mount.appendChild(layer);

    // normalizaciÃ³n + edges
    var nodes = (cfg.nodes || []).map(inferTopoNode);
    var rawEdges = (Array.isArray(cfg.edges) && cfg.edges.length) ? cfg.edges.slice() : topoEdgesFromNodes(nodes);

    // columnas por niveles + regla forÃ¡neos
    var levels = Array.isArray(cfg.levels) ? cfg.levels.slice() : new Array(nodes.length).fill(1);
    var cols = topoAssignColumns(nodes, levels, rawEdges);

    // forward-only (izq -> der)
    var id2idx = Object.create(null);
    for (var i = 0; i < nodes.length; i++) if (nodes[i] && nodes[i].id) id2idx[nodes[i].id] = i;

    var edges = [];
    for (var e = 0; e < rawEdges.length; e++) {
        var ed = rawEdges[e], ia = id2idx[ed.from], ib = id2idx[ed.to];
        if (ia == null || ib == null) continue;
        var ca = cols[ia], cb = cols[ib];
        if (cb > ca) edges.push(ed);
        else if (ca > cb) edges.push({ from: ed.to, to: ed.from, style: ed.style, color: ed.color, width: ed.width });
        // misma columna -> omit
    }

    // bases con _TE
    var HAS_TE = Object.create(null);
    for (var j = 0; j < nodes.length; j++) {
        var nd = nodes[j]; if (!nd) continue;
        if (isTE(nd.id)) HAS_TE[baseId(nd.id)] = true;
    }

    // posiciones base
    var pos = topoPositionsFromColumns(nodes, cols, TOPO_TILE_W, TOPO_TILE_H, TOPO_GAP_X, TOPO_GAP_Y);

    // compactar por columna (las _TE no reservan renglÃ³n)
    (function compactPorCol() {
        var byX = Object.create(null);
        for (var k = 0; k < nodes.length; k++) {
            if (isTE(nodes[k].id)) continue;
            var x = pos[k][0];
            (byX[x] || (byX[x] = [])).push(k);
        }
        var xs = Object.keys(byX);
        for (var xi = 0; xi < xs.length; xi++) {
            var idxs = byX[xs[xi]].slice().sort(function (a, b) { return pos[a][1] - pos[b][1]; });
            var yCursor = null;
            for (var t = 0; t < idxs.length; t++) {
                var i2 = idxs[t], n2 = nodes[i2], p2 = pos[i2];
                if (yCursor === null) yCursor = p2[1];
                else if (p2[1] < yCursor) p2[1] = yCursor;
                var cellH = TOPO_TILE_H + (HAS_TE[n2.id] ? (TE_GAP_IN + TOPO_TILE_H) : 0);
                yCursor = p2[1] + cellH + TOPO_GAP_Y;
            }
        }
    })();

    // montaje de tiles (doble-tile en celda) + bounds
    var rectById = {};
    var maxX = 0, maxY = 0;

    for (var t = 0; t < nodes.length; t++) {
        var n = nodes[t];
        if (isTE(n.id)) continue; // _TE se monta junto a su base

        var p = pos[t], x = p[0], y = p[1];

        // Base
        var inst = mountTopoNode(layer, n, x, y, TOPO_TILE_W, TOPO_TILE_H);
        rectById[n.id] = { x: x, y: y, w: TOPO_TILE_W, h: TOPO_TILE_H, el: inst.el };

        // _TE debajo (misma celda)
        if (HAS_TE[n.id]) {
            var teId = n.id + '_TE';
            var teIdx = id2idx[teId];
            if (teIdx != null) {
                var teNode = nodes[teIdx];
                var yTE = y + TOPO_TILE_H + TE_GAP_IN;
                var instTE = mountTopoNode(layer, teNode, x, yTE, TOPO_TILE_W, TOPO_TILE_H);
                try { instTE.el.style.zIndex = '3'; } catch (_) { }
            }
        }

        // bounds por celda expandida
        var cellH = TOPO_TILE_H + (HAS_TE[n.id] ? (TE_GAP_IN + TOPO_TILE_H) : 0);
        var xk = x + TOPO_TILE_W, yk = y + cellH;
        if (xk > maxX) maxX = xk;
        if (yk > maxY) maxY = yk;
    }

    // viewport/canvas (una sola vez)
    var viewport = doc.createElement('div');
    viewport.style.position = 'absolute'; viewport.style.inset = '0'; viewport.style.overflow = 'auto';
    var canvas = doc.createElement('div');
    canvas.style.position = 'relative'; canvas.style.transformOrigin = '0 0';
    canvas.style.width = Math.max(mount.clientWidth || 0, maxX) + 'px';
    canvas.style.height = Math.max(mount.clientHeight || 0, maxY) + 'px';
    canvas.appendChild(layer);
    viewport.appendChild(canvas);
    mount.appendChild(viewport);

    // flechas
    var theme = topoInferTheme(TOPO_BASE || '');
    var accent = theme.accent || '#334155';
    drawTopoArrowsHtml(layer, rectById, edges, { color: accent, width: 2, headSize: 8, margin: 8 });
    // si ajustaste el "bus" en CORE, aquÃ­ no tocamos nada.

    // zoom/scroll (sin IIFE)
    var scale = 1, minS = 0.5, maxS = 2.0, step = 0.1;
    function applyScale() {
        canvas.style.transform = 'scale(' + scale.toFixed(3) + ')';
        canvas.dataset.scale = String(scale);
    }
    applyScale();

    viewport.addEventListener('wheel', function (e) {
        // ðŸ‘‰ Sin Ctrl: NO zoom, deja que el navegador scrollee normal
        if (!e.ctrlKey /* && !e.metaKey */) return;

        // ðŸ‘‰ Con Ctrl: sÃ­ hacemos zoom centrado en el cursor
        try { e.preventDefault(); } catch (_) { }

        var rect = viewport.getBoundingClientRect();
        var vx = e.clientX - rect.left;
        var vy = e.clientY - rect.top;

        var contentX = (vx + viewport.scrollLeft) / scale;
        var contentY = (vy + viewport.scrollTop) / scale;

        var dy = e.deltaY || 0;
        var s = scale + (dy > 0 ? -step : step);
        scale = Math.max(minS, Math.min(maxS, s));
        applyScale();

        viewport.scrollLeft = Math.max(0, contentX * scale - vx);
        viewport.scrollTop = Math.max(0, contentY * scale - vy);
    }, { passive: false });

    /* === Click -> abrir instalaciÃ³n en iframe "content" + centrar/resaltar === */
    (function bindOpenOnce() {

        var URL = "SYSTEM.DISPLAYS.Instalacion.Vista_Principal_V2";
        var IFRAME = "content";

        function centerAndHighlightByBase(base, isInitial) {
            if (!base) return;
            var el = layer.querySelector('.topo-node[data-base="' + base + '"]');
            if (!el) return;
            var s = parseFloat(canvas.dataset.scale || '1') || 1;
            var cx = (el.offsetLeft + el.offsetWidth / 2) * s;
            var cy = (el.offsetTop + el.offsetHeight / 2) * s;
            viewport.scrollLeft = Math.max(0, Math.round(cx - viewport.clientWidth / 2));
            viewport.scrollTop = Math.max(0, Math.round(cy - viewport.clientHeight / 2));
            var prev = el.style.boxShadow;
            el.style.boxShadow = '0 0 0 3px ' + (accent || '#1c7ed6') + ' inset';
            setTimeout(function () { el.style.boxShadow = prev || '0 1px 2px rgba(0,0,0,.08)'; }, isInitial ? 800 : 500);
        }


        // tambiÃ©n centra si el core disparÃ³ el CustomEvent 'topo:click'
        layer.addEventListener('topo:click', function (ev) {
            var d = ev.detail || {};
            if (!d.base) return;
            centerAndHighlightByBase(String(d.base), false);
        });
        // centrar al inicio (focusBase o base)
        var initialFocusBase = String(TOPO_Q.focusBase || TOPO_Q.base || '');
        if (initialFocusBase) centerAndHighlightByBase(initialFocusBase, true);
    })();
}

/* ===== Loader ===== */
function topoLoadAndRender() {
    if (!TOPO_CFG_NODE) return;
    try {
        webMI.data.read(TOPO_CFG_NODE, function (r) {
            var raw = r && r.value;
            var cfg = parseTopoConfig(String(raw || ''));
            cfg.nodes = Array.isArray(cfg.nodes) ? cfg.nodes : [];
            cfg.edges = (Array.isArray(cfg.edges) && cfg.edges.length) ? cfg.edges : topoEdgesFromNodes(cfg.nodes);
            topoReadLevelsForNodes(cfg.nodes, function (levels) {
                cfg.levels = levels;
                renderTopography(cfg);
            });
        });
    } catch (_) { }
}

/* autorun */
topoLoadAndRender();
]]></code>
</script>
