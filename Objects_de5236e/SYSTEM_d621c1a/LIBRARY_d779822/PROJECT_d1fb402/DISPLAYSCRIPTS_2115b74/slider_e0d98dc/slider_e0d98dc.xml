<?xml version="1.0" encoding="UTF-8"?>
<script>
  <metadata>
    <priority>0</priority>
  </metadata>
  <code><![CDATA[/**
 * Code for slider_horizontal and slider_vertical object displays
 * --------------------------------------------------------------
 * The slider is used for the graphical representation of the value of an address; it cannot be used &nbsp;as input control.
 * For each slider 0 to 4 limits (from &ldquo;limit low low&rdquo; up to &ldquo;limit high high&rdquo;) can be specified. These limits split the range defined by &ldquo;min&rdquo; and &ldquo;max&rdquo; in 1 to 5 intervals. Depending in what interval the value of the "base" address lies, the text color&nbsp;of the value will be changed according to the specified color for each limit &ndash; see below under &ldquo;Appearance&rdquo;. In case a limit lies below min or above max, it will not be explicitly drawn, though the text color will be changed accordingly. (e.g. max=100 and &ldquo;limit high high&rdquo;=120: although the slider will not go beyond &ldquo;max&rdquo;, the text color will change according to &ldquo;limit high high color&rdquo; as soon as the value reaches the &ldquo;limit high high&rdquo;)
 * The limits are defined as follows:<br>
 * - limit low low &gt;= value: text color according to "limit low low color"
 * - limit low low &lt;  value &lt;= limit low: text color according to "limit low color"
 * - limit low &lt;  value &lt; limit high: text color&nbsp;according to "text color"
 * - limit high &lt;=  value &lt; limit high high: text color&nbsp;according to "limit high color"
 * - limit high high  &lt;=  value: text color according to "limit high high&nbsp;color"
 * An additional border indicates the current value's negative state or an additionally defined alarm. The colors and blinking intervals are defined in global lists.
 */

/**
 * QD Calls e.g. Imports
 */

var AggregateManager = webMI.callExtension("SYSTEM.LIBRARY.ATVISE.QUICKDYNAMICS.Aggregate Manager");
webMI.addOnunload(function () {
	AggregateManager.destroy();
	AggregateManager = null;
});

var accessControlManager = webMI.callExtension("SYSTEM.LIBRARY.ATVISE.QUICKDYNAMICS.Access Control Manager");

/**
 * DECLARATION SECTION
 */

/* switch compatibility and advanced modes for designs */
var compatibilityMode = typeof webMI.query["compatibilityMode"] == "undefined" ? false : true;
var advancedMode = !compatibilityMode;
var isHorizontal = webMI.query["horizontalMode"] == "true" ? true : false;

var active = false;
var activeNode = webMI.query["activeNode"] == undefined ? "" : webMI.query["activeNode"];
var activeValue = webMI.query["activeValue"] == undefined ? "" : webMI.query["activeValue"];
var barColor = typeof webMI.query["fill"] != "undefined" ? webMI.query["fill"] : webMI.query["barColor"];
var barColorInactive =
	typeof webMI.query["fillColorInactive"] != "undefined"
		? webMI.query["fillColorInactive"]
		: webMI.query["barColorInactive"];
var barColorNotEditable =
	typeof webMI.query["fillColorNotEditable"] != "undefined"
		? webMI.query["fillColorNotEditable"]
		: webMI.query["barColorNotEditable"];
var barColorLimitsOn = webMI.query["barColorLimitsOn"];
var base = webMI.query["base"] == undefined ? "" : webMI.query["base"];
var decimalPositions = webMI.query["decimalPositions"];
var fontColor = webMI.query["fontColor"];
var i = 0;
var isActivationNodeSet = activeNode != "" && String(activeValue) != "";
var limitXCord = [0, 122];
var limitYCord = [0, -122];
var limitHigh = webMI.query["limitHigh"] == undefined ? "" : webMI.query["limitHigh"];
var limitHighFill = webMI.query["limitHighFill"];
var limitHighHigh = webMI.query["limitHighHigh"] == undefined ? "" : webMI.query["limitHighHigh"];
var limitHighHighFill = webMI.query["limitHighHighFill"];
var limitLow = webMI.query["limitLow"] == undefined ? "" : webMI.query["limitLow"];
var limitLowLow = webMI.query["limitLowLow"] == undefined ? "" : webMI.query["limitLowLow"];
var limitLowFill = webMI.query["limitLowFill"];
var limitLowLowFill = webMI.query["limitLowLowFill"];
var min = webMI.query["min"] == undefined ? "" : parseFloat(webMI.query["min"]);
var max = webMI.query["max"] == undefined ? "" : parseFloat(webMI.query["max"]);
var nodeMin = webMI.query["nodeMin"] == undefined ? "" : webMI.query["nodeMin"];
var nodeMax = webMI.query["nodeMax"] == undefined ? "" : webMI.query["nodeMax"];
var nodeLowLow = webMI.query["nodeLowLow"] == undefined ? "" : webMI.query["nodeLowLow"];
var nodeLow = webMI.query["nodeLow"] == undefined ? "" : webMI.query["nodeLow"];
var nodeHigh = webMI.query["nodeHigh"] == undefined ? "" : webMI.query["nodeHigh"];
var nodeHighHigh = webMI.query["nodeHighHigh"] == undefined ? "" : webMI.query["nodeHighHigh"];
var nodes = new Array(0, 0, 0, 0, 0, 0, 0); //array for base, min, max, limitLowLow, limitLow, LimitHigh, LimitHighhigh
var nodesToSubscribe = new Array();
var right = webMI.query["right"] == undefined ? "" : webMI.query["right"];
var scaleColor = webMI.query["scaleColor"];
var scaleXCord = [0, 122];
var scaleYCord = [0, -122];
var symbolFillColor = webMI.query["fillColor"];
var barID = "bar";

var lockActiveLayout = false;
var lockUpdateColor = false;
var lockInputEvents = false;

if (advancedMode) {
	var barWidth = parseInt(webMI.gfx.getWidth("bar"));
	var barHeight = parseInt(webMI.gfx.getHeight("bar"));
	var screenCTM = webMI.gfx.getScreenCTM("bar");
} else {
	limitXCord = [0, 100];
	limitYCord = [0, -100];
	scaleXCord = [0, 100];
	scaleYCord = [0, -100];
	barID = "barCompatible";
}

/** status **/
var alarmToSubscribe = webMI.query["alarm"];
var alarmIndication = webMI.query["alarmIndication"];
var statusEnabled = webMI.query["statusEnabled"];
var statusTrigger = webMI.query["statusTrigger"];
var statusIndication = webMI.query["statusIndication"];

/** other **/
var notAvailableString = "T{N/A}";

/** data **/
var runTimeNodeConfig = {
	base: {value: null, address: base, paramValue: "", read: true, write: true, aggregate: false},
	min: {value: null, address: nodeMin, paramValue: min, read: true, write: false},
	max: {value: null, address: nodeMax, paramValue: max, read: true, write: false},
	limitLowLow: {value: null, address: nodeLowLow, paramValue: limitLowLow, read: true, write: false},
	limitLow: {value: null, address: nodeLow, paramValue: limitLow, read: true, write: false},
	limitHigh: {value: null, address: nodeHigh, paramValue: limitHigh, read: true, write: false},
	limitHighHigh: {value: null, address: nodeHighHigh, paramValue: limitHighHigh, read: true, write: false}
};

/** notification cfg **/
var notifierConfig;

/** advanced menu layout with corrections **/
var menuLayout = {
	customElementPosition: webMI.query["elementPosition"],
	customFadeInAtHover: webMI.query["fadeInAtHover"],
	customElementOffsetX: webMI.query["elementOffsetX"],
	customElementOffsetY: webMI.query["elementOffsetY"],
	customClickareaEnlargement: webMI.query["clickareaEnlargement"],
	customElementLayoutOffsets: {}
};

if (advancedMode && isHorizontal) {
	menuLayout.customElementLayoutOffsets = {
		"top-left": {x: 80, y: 26},
		"top-right": {x: 13, y: 26},
		"bottom-left": {x: 80, y: 39},
		"bottom-right": {x: 13, y: 39}
	};
} else if (advancedMode) {
	menuLayout.customElementLayoutOffsets = {
		"top-left": {x: 29, y: 18},
		"top-right": {x: 38, y: 18},
		"bottom-left": {x: 29, y: 43},
		"bottom-right": {x: 38, y: 43}
	};
}

/** declare slide event handler **/
const sliderEventHandler = webMI.callExtension(
	isHorizontal
		? "SYSTEM.LIBRARY.ATVISE.QUICKDYNAMICS.Set Slider Horizontal"
		: "SYSTEM.LIBRARY.ATVISE.QUICKDYNAMICS.Set Slider Vertical",
	{
		id: "barControl",
		ele: document.getElementById("barControl"),
		node: base,
		min: min,
		max: max,
		decimalPositions: decimalPositions
	}
);


/**
 * RUNTIME SECTION
 */
if (typeof activationTriggerHandling === "function") activationTriggerHandling("com.atvise.setActive");

AggregateManager.isAggregates(webMI.query["base"], function (aggregate, aggregateNodeRights) {
	var address = aggregate ? webMI.query["base"].replace(aggregate, "") : webMI.query["base"];
	var eleBg_rect = document.getElementById("bg_rect");

	if (!eleBg_rect)
		return;

	notifierConfig = {
		id: eleBg_rect.id,
		rights: [
			{nodeId: webMI.query["base"], rights: "write", disable: true, notify: false},
			{nodeId: webMI.query["alarm"], rights: "alarmRead", disable: false, notify: true},
			{nodeId: webMI.query["nodeMin"], rights: "read", disable: true, notify: true},
			{nodeId: webMI.query["nodeMax"], rights: "read", disable: true, notify: true},
			{nodeId: webMI.query["nodeLowLow"], rights: "read", disable: false, notify: true},
			{nodeId: webMI.query["nodeLow"], rights: "read", disable: false, notify: true},
			{nodeId: webMI.query["nodeHigh"], rights: "read", disable: false, notify: true},
			{nodeId: webMI.query["nodeHighHigh"], rights: "read", disable: false, notify: true},
			{nodeId: webMI.query["activeNode"], rights: "read", disable: true, notify: true}
		],
		menuLayout: menuLayout
	};

	if (aggregateNodeRights) {
		for (var key in aggregateNodeRights) {
			var cR = aggregateNodeRights[key];
			notifierConfig.rights.push({
				nodeId: cR.node,
				rights: cR.right,
				disable: cR.disable ? true : false,
				notify: cR.notify ? true : false
			});
		}
	}

	var rightsHandlingProperties = {
		activationNodeSet: {activeNode: webMI.query["activeNode"], activeValue: webMI.query["activeValue"]},
		notifierConfiguration: webMI.query.displayAcNotification === "true" ? notifierConfig : {}
	};

	if (typeof rightsHandling === "function") rightsHandling(rightsHandlingProperties);

	if (aggregate) {
		notifierConfig.rights.push({nodeId: address, rights: "read", disable: true, notify: false});
		runTimeNodeConfig.base.aggregate = aggregate;
	}

	if (typeof updateRunTimeNodeConfig === "function") {
		updateRunTimeNodeConfig(runTimeNodeConfig, notifierConfig.rights, initialize);
	} else {
		initialize(runTimeNodeConfig);
	}
});

/**
 * FUNCTIONS
 */

/**
 * read or subscribe data by runtime node configuration
 * @param nodeCfg
 */
function initialize(nodeCfg) {
	/* init alarm indication */
	if (alarmToSubscribe != "") updateAlarmIndication(alarmToSubscribe);

	/* set init value */
	if (runTimeNodeConfig.base.value == null)
		runTimeNodeConfig.base.value = 0;

	/* base */
	if (nodeCfg.base.read) {
		if (!nodeCfg.base.subscribe) {
			nodeCfg.base.subscribe = true;

			if(AggregateManager)
			  AggregateManager.subscribeNodeOrAggregate(nodeCfg.base.address, manageBaseResult);

			function manageBaseResult(result) {
				if (typeof result.status != "undefined" && typeof updateStatusIndication === "function") {
					updateStatusIndication(result.status);
				}

				if (!result.error) {
					runTimeNodeConfig.base.value = result.value;
					_updateOutput();
					_updateColors();
				} else {
					runTimeNodeConfig.base.value = null;
					_updateOutput("slider_value", "T{N/A}");
					_updateColors();
				}
			}
		}
	} else {
		_updateOutput();
	}

	/* min max limits ... */
	for (var key in nodeCfg) {
		if (key != "base" && key != "outputNode") {
			let cKey = key;
			let node = nodeCfg[key];

			if (node.address && node.read) {
				if (!nodeCfg[key].subscribe) {
					nodeCfg[key].subscribe = true;

					webMI.data.subscribe(node.address, function (response) {
						runTimeNodeConfig[cKey].value = response.value;
						_updateColors();
					});
				}
			} else if (node.address && !node.read) {
				if (cKey == "min" || cKey == "max") {
					webMI.gfx.setText(cKey, "T{N/A}");
				}
			} else if (!node.address) {
				runTimeNodeConfig[cKey].value = node.paramValue;
				_updateColors();
			}
		}
	}

	if (typeof tooltip != "undefined") {
		webMI.callExtension("SYSTEM.LIBRARY.ATVISE.QUICKDYNAMICS.Tooltip", {
			auto: "true",
			id: "clickareaFO",
			text: tooltip
		});
	}
}

/**
 * switch to active layout
 */
function setActiveLayout() {
	lockUpdateColor = false;
	lockInputEvents = false;

	_updateOutput();
	_updateColors();

	/** set slider active **/
	if (webMI.query["editable"] == "No") {
		setInactiveLayout();
	} else {
		/** Position eines Rectangle-Elements als Boolean zur dynamischen Verwendung im Quick Dynamic eingesetzt **/
		webMI.gfx.setX("activeIndicator", "1");

		if (advancedMode) {
			webMI.gfx.setFill("slider_symbol_bg", symbolFillColor);
		} else {
			var field = barID;
			if (compatibilityMode)
				field = "output_field";

			if (!isHorizontal) {
				webMI.gfx.setFill(field, barColor);
			} else {
				webMI.gfx.setFill("value_field", barColor);
				webMI.gfx.setFill("label_field", barColor);
			}
		}
	}
}

/**
 * switch to inactive layout
 */
function setInactiveLayout() {
	lockUpdateColor = true;
	lockInputEvents = true;

	_updateOutput();
	_updateColors();

	/** Position eines Rectangle-Elements als Boolean zur dynamischen Verwendung im Quick Dynamic eingesetzt **/
	webMI.gfx.setX("activeIndicator", "0");

	/** set slider inactive **/
	if (advancedMode) {
		webMI.gfx.setFill("slider_symbol_bg", barColorInactive);
	} else {
		var field = barID;
		if (compatibilityMode)
			field = "output_field";

		if (!isHorizontal) {
			webMI.gfx.setFill(field, barColorInactive);
		} else {
			webMI.gfx.setFill("value_field", barColorInactive);
			webMI.gfx.setFill("label_field", barColorInactive);
		}
	}
}

/**
 * update on ac right changes
 */
function fetchCurrentRightsAndUpdate() {
	updateRunTimeNodeConfig(runTimeNodeConfig, notifierConfig.rights, initialize);
}

/**
 * update background color
 * @private
 */
function _updateColors() {
	var value = parseFloat(runTimeNodeConfig.base.value);

	var limitLowLow = parseFloat(runTimeNodeConfig.limitLowLow.value);
	var limitLow = parseFloat(runTimeNodeConfig.limitLow.value);
	var limitHigh = parseFloat(runTimeNodeConfig.limitHigh.value);
	var limitHighHigh = parseFloat(runTimeNodeConfig.limitHighHigh.value);

	var currentColor = barColor;
	if (!isNaN(limitLowLow) || !isNaN(limitLow) || !isNaN(limitHigh) || !isNaN(limitHighHigh)) {
		currentColor = barColorLimitsOn;
	}

	if (limitLowLow != null && value <= limitLowLow) {
		currentColor = limitLowLowFill;
	} else if (limitLow != null && value <= limitLow) {
		currentColor = limitLowFill;
	} else if (limitHighHigh != null && value >= limitHighHigh) {
		currentColor = limitHighHighFill;
	} else if (limitHigh != null && value >= limitHigh) {
		currentColor = limitHighFill;
	}

	var lockBase = runTimeNodeConfig.base.address && !runTimeNodeConfig.base.read;
	var lockLimitHighHigh = runTimeNodeConfig.limitHighHigh.address && !runTimeNodeConfig.limitHighHigh.read;
	var lockLimitHigh = runTimeNodeConfig.limitHigh.address && !runTimeNodeConfig.limitHigh.read;
	var lockLimitLowLow = runTimeNodeConfig.limitLowLow.address && !runTimeNodeConfig.limitLowLow.read;
	var lockLimitLow = runTimeNodeConfig.limitLow.address && !runTimeNodeConfig.limitLow.read;

	if (CRH && !CRH.state.accessControlState) {
		if (lockBase || lockLimitHighHigh || lockLimitHigh || lockLimitLow || lockLimitLowLow)
			currentColor = barColorInactive;
	}

	_updateLimits();
	_updateSlider(currentColor);
}

/**
 * update limit pointers
 * @private
 */
function _updateLimits() {
	var value = parseFloat(runTimeNodeConfig.base.value);
	var min = parseFloat(runTimeNodeConfig.min.value);
	var max = parseFloat(runTimeNodeConfig.max.value);
	var limitLowLow = parseFloat(runTimeNodeConfig.limitLowLow.value);
	var limitLow = parseFloat(runTimeNodeConfig.limitLow.value);
	var limitHigh = parseFloat(runTimeNodeConfig.limitHigh.value);
	var limitHighHigh = parseFloat(runTimeNodeConfig.limitHighHigh.value);

	if (!isNaN(min)) webMI.gfx.setText("min", min);
	if (!isNaN(max)) webMI.gfx.setText("max", max);

	sliderEventHandler.updateMinMax(min, max);

	if (String(limitLowLow) == "NaN" ||
		(String(min) != "NaN" && limitLowLow < min) ||
		(String(max) != "NaN" && limitLowLow > max)
	) {
		webMI.gfx.setVisible("limit_low_low", false);
	} else {
		if (isHorizontal)
			webMI.gfx.setMoveX("limit_low_low", webMI.translate(limitLowLow, min, max, limitXCord[0], limitXCord[1]));
		else webMI.gfx.setMoveY("limit_low_low", webMI.translate(limitLowLow, min, max, limitYCord[0], limitYCord[1]));
		webMI.gfx.setVisible("limit_low_low", null);
	}

	if (String(limitLow) == "NaN" ||
		(String(min) != "NaN" && limitLow < min) ||
		(String(max) != "NaN" && limitLow > max)
	) {
		webMI.gfx.setVisible("limit_low", false);
	} else {
		if (isHorizontal)
			webMI.gfx.setMoveX("limit_low", webMI.translate(limitLow, min, max, limitXCord[0], limitXCord[1]));
		else webMI.gfx.setMoveY("limit_low", webMI.translate(limitLow, min, max, limitYCord[0], limitYCord[1]));
		webMI.gfx.setVisible("limit_low", null);
	}

	if (String(limitHigh) == "NaN" ||
		(String(min) != "NaN" && limitHigh < min) ||
		(String(max) != "NaN" && limitHigh > max)
	) {
		webMI.gfx.setVisible("limit_high", false);
	} else {
		if (isHorizontal)
			webMI.gfx.setMoveX("limit_high", webMI.translate(limitHigh, min, max, limitXCord[0], limitXCord[1]));
		else webMI.gfx.setMoveY("limit_high", webMI.translate(limitHigh, min, max, limitYCord[0], limitYCord[1]));
		webMI.gfx.setVisible("limit_high", null);
	}

	if (
		String(limitHighHigh) == "NaN" ||
		(String(min) != "NaN" && limitHighHigh < min) ||
		(String(max) != "NaN" && limitHighHigh > max)
	) {
		webMI.gfx.setVisible("limit_high_high", false);
	} else {
		if (isHorizontal)
			webMI.gfx.setMoveX("limit_high_high", webMI.translate(limitHighHigh, min, max, limitXCord[0], limitXCord[1]));
		else webMI.gfx.setMoveY("limit_high_high", webMI.translate(limitHighHigh, min, max, limitYCord[0], limitYCord[1]));
		webMI.gfx.setVisible("limit_high_high", null);
	}
}

/**
 * update slider position
 * @param currentColor
 * @private
 */
function _updateSlider(currentColor) {
	var value = parseFloat(runTimeNodeConfig.base.value);
	var min = parseFloat(runTimeNodeConfig.min.value);
	var max = parseFloat(runTimeNodeConfig.max.value);
	var limitLowLow = parseFloat(runTimeNodeConfig.limitLowLow.value);
	var limitLow = parseFloat(runTimeNodeConfig.limitLow.value);
	var limitHigh = parseFloat(runTimeNodeConfig.limitHigh.value);
	var limitHighHigh = parseFloat(runTimeNodeConfig.limitHighHigh.value);

	if (!isNaN(limitLowLow) || !isNaN(limitLow) || !isNaN(limitHigh) || !isNaN(limitHighHigh)) {
		webMI.gfx.setFill("slider_value", currentColor);
	}

	if (advancedMode)
		webMI.gfx.setFill(barID, currentColor);

	var sliderValue = value;
	if (min > value) {
		sliderValue = min;
	}
	if (value > max) {
		sliderValue = max;
	}

	var lockBase = runTimeNodeConfig.base.address && !runTimeNodeConfig.base.read;
	var lockMin = runTimeNodeConfig.min.address && !runTimeNodeConfig.min.read;
	var lockMax = runTimeNodeConfig.max.address && !runTimeNodeConfig.max.read;

	if (CRH && !CRH.state.accessControlState) {
		if (lockBase || lockMin || lockMax)
			sliderValue = max;
	}

	if (isHorizontal) webMI.gfx.setMoveX("slider_pointer", webMI.translate(sliderValue, min, max, scaleXCord[0], scaleXCord[1]));
	else webMI.gfx.setMoveY("slider_pointer", webMI.translate(sliderValue, min, max, scaleYCord[0], scaleYCord[1]));

	if (advancedMode) {
		if (isHorizontal) webMI.gfx.setScaleX(barID, webMI.translate(sliderValue, min, max, 0, 1));
		else webMI.gfx.setScaleY(barID, webMI.translate(sliderValue, min, max, 0, 1));
	}
}

/**
 * update input value
 * @param component
 * @param value
 * @private
 */
function _updateOutput(component, value) {
	var tmpValue;

	if (!component) {
		component = "slider_value";
		tmpValue = formatValue(runTimeNodeConfig.base.value, decimalPositions);
	} else {
		tmpValue = formatValue(value);
	}

	var lockBase = runTimeNodeConfig.base.address && !runTimeNodeConfig.base.read;
	var lockMin = runTimeNodeConfig.min.address && !runTimeNodeConfig.min.read;
	var lockMax = runTimeNodeConfig.max.address && !runTimeNodeConfig.max.read;

	if (CRH && !CRH.state.accessControlState) {
		if (lockBase || lockMin || lockMax)
			tmpValue = notAvailableString;
	}

	function formatValue(value, decimal) {
		if (typeof value != "string")
			value = parseFloat(value);

		if (decimal) {
			var formatString = "%0." + parseFloat(decimal) + "f";
			value = webMI.sprintf(formatString, value);
		}
		return value
	}

	webMI.gfx.setText(component, tmpValue);
	webMI.gfx.setText("slider_value", tmpValue);
}

]]></code>
</script>
