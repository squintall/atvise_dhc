<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<svg height="304.80000000000001" version="1.2" width="607.60000000000002" xmlns="http://www.w3.org/2000/svg" xmlns:atv="http://webmi.atvise.com/2007/svgext" xmlns:xlink="http://www.w3.org/1999/xlink">
 <defs/>
 <metadata>
  <atv:parameter behavior="optional" defaultvalue="" desc="Dashboard ID" group="GeneralConfig" name="DashboardID" valuetype="string"/>
  <atv:parameter behavior="optional" config="Line;Spline;Area;Column;Bar;Pie;Pyramid;Solidgauge;Histogram;Gauge" defaultvalue="" desc="Chart Type" group="GeneralConfig" name="ChartType" valuetype="enum"/>
  <atv:parameter behavior="optional" config="Values;Alarms;Aggregates" defaultvalue="Values" desc="Data Type" group="GeneralConfig" name="DataType" valuetype="enum"/>
  <atv:parameter behavior="optional" config="EnumList;Text" defaultvalue="Text" desc="Series Source" group="GeneralConfig" name="SeriesSource" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="2" desc="InitialRange" group="GeneralConfig" name="InitialRange" valuetype="number"/>
  <atv:parameter behavior="optional" config="s;min;h;day;month" defaultvalue="min" desc="Initial Range Unit" group="GeneralConfig" name="InitialRangeUnit" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="true" desc="ZoomEnabled" group="Zoom" name="ZoomEnabled" valuetype="bool"/>
  <atv:parameter behavior="optional" defaultvalue="false" desc="Data Reduction Enabled" group="DataOptimization" name="DataReductionEnabled" valuetype="bool"/>
  <atv:parameter behavior="optional" defaultvalue="1000" desc="Data Reduction Max Size" group="DataOptimization" name="DataReductionMaxSize" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="false" desc="DataLimitEnabled" group="LimitAnalysis" name="DataLimitEnabled" valuetype="bool"/>
  <atv:parameter behavior="optional" config="Fixed;Node" defaultvalue="Fixed" desc="Data Max Type" group="LimitAnalysis" name="DataMaxType" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Data Max Limit" group="LimitAnalysis" name="DataMaxLimit" valuetype="number"/>
  <atv:parameter behavior="optional" desc="Data Max Node" group="LimitAnalysis" name="DataMaxNode" valuetype="address"/>
  <atv:parameter behavior="optional" defaultvalue="#aa0000" desc="Color Limit Point Max" group="LimitAnalysis" name="ColorLimitPointMax" valuetype="color"/>
  <atv:parameter behavior="optional" defaultvalue="#aa0000" desc="Color Limit Line Max" group="LimitAnalysis" name="ColorLimitLineMax" valuetype="color"/>
  <atv:parameter behavior="optional" config="Dash;DashDot;Dot;LongDash;LongDashDot;LongDashDotDot;ShortDash;ShortDashDot;ShortDashDotDot;ShortDot;Solid" defaultvalue="Solid" desc="Type Limit Line Max" group="LimitAnalysis" name="TypeLimitLineMax" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="Max" desc="Text Limit Line Max" group="LimitAnalysis" name="TextLimitLineMax" valuetype="string"/>
  <atv:parameter behavior="optional" config="Fixed;Node" defaultvalue="Fixed" desc="Data Min Type" group="LimitAnalysis" name="DataMinType" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Data Min Limit" group="LimitAnalysis" name="DataMinLimit" valuetype="number"/>
  <atv:parameter behavior="optional" desc="Data Min Node" group="LimitAnalysis" name="DataMinNode" valuetype="address"/>
  <atv:parameter behavior="optional" defaultvalue="#aa0000" desc="Color Limit Point Min" group="LimitAnalysis" name="ColorLimitPointMin" valuetype="color"/>
  <atv:parameter behavior="optional" defaultvalue="#aa0000" desc="Color Limit Line Min" group="LimitAnalysis" name="ColorLimitLineMin" valuetype="color"/>
  <atv:parameter behavior="optional" config="Dash;DashDot;Dot;LongDash;LongDashDot;LongDashDotDot;ShortDash;ShortDashDot;ShortDashDotDot;ShortDot;Solid" defaultvalue="Solid" desc="Type Limit Line Min" group="LimitAnalysis" name="TypeLimitLineMin" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="Min" desc="Text Limit Line Min" group="LimitAnalysis" name="TextLimitLineMin" valuetype="string"/>
  <atv:parameter behavior="optional" defaultvalue="false" desc="Data Processing Enabled" group="DataProcessing" name="DataProcessingEnabled" valuetype="bool"/>
  <atv:parameter behavior="optional" config="Simple-None;SinglePoint-LastValue;SinglePoint-FirstValue;SinglePoint-Max;SinglePoint-Min;Interval-Addition;Interval-Average;Interval-CountChanges;Interval-CountTimeOff;Interval-CountTimeOn;Interval-Difference;Interval-Histogram;Interval-Integration;FullRange-Addition;FullRange-Average;FullRange-Difference;FullRange-Integration;FullRange-OEE;FullRange-OEEAvailability;FullRange-OEEProductivity;FullRange-OEEQuality" defaultvalue="Simple-None" desc="Data Processing Type" group="DataProcessing" name="DataProcessingType" valuetype="enum"/>
  <atv:parameter behavior="optional" config="s;min;h;day;month" defaultvalue="s" desc="Processing Time Input Unit" group="DataProcessing" name="DataProcessingTimeInputUnit" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="false" desc="Formula Enabled" group="Formula f(X)" name="FormulaEnabled" valuetype="bool"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Formula Description" group="Formula f(X)" name="FormulaDescription" valuetype="string"/>
  <atv:parameter behavior="optional" config="Fixed;Node" defaultvalue="Fixed" desc="A Parameter Type" group="Formula f(X)" name="AParameterType" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="A Parameter Value" group="Formula f(X)" name="AParameterValue" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="A Parameter Node" group="Formula f(X)" name="AParameterNode" valuetype="address"/>
  <atv:parameter behavior="optional" config="Fixed;Node" defaultvalue="Fixed" desc="B Parameter Type" group="Formula f(X)" name="BParameterType" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="B Parameter Value" group="Formula f(X)" name="BParameterValue" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="B Parameter Node" group="Formula f(X)" name="BParameterNode" valuetype="address"/>
  <atv:parameter behavior="optional" config="Fixed;Node" defaultvalue="Fixed" desc="C Parameter Type" group="Formula f(X)" name="CParameterType" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="C Parameter Value" group="Formula f(X)" name="CParameterValue" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="C Parameter Node" group="Formula f(X)" name="CParameterNode" valuetype="address"/>
  <atv:parameter behavior="optional" config="Fixed;Node" defaultvalue="Fixed" desc="D Parameter Type" group="Formula f(X)" name="DParameterType" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="D Parameter Value" group="Formula f(X)" name="DParameterValue" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="D Parameter Node" group="Formula f(X)" name="DParameterNode" valuetype="address"/>
  <atv:parameter behavior="optional" config="Fixed;Node" defaultvalue="Fixed" desc="E Parameter Type" group="Formula f(X)" name="EParameterType" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="E Parameter Value" group="Formula f(X)" name="EParameterValue" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="E Parameter Node" group="Formula f(X)" name="EParameterNode" valuetype="address"/>
  <atv:parameter behavior="optional" config="AllData-DateTime;Interval-CustomText;Interval-CustomInterval;Interval-Dynamic;Interval-Histogram;Single-Simple" defaultvalue="" desc="Category Type" group="Category Selection" name="CategoryType" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="true" desc="Category Round Up" group="Category Selection" name="CategoryRound" valuetype="bool"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Custom Category" group="Category Selection" name="CategoryCustomText" valuetype="string"/>
  <atv:parameter behavior="optional" defaultvalue="1" desc="Custom Interval Length" group="Category Selection" name="CategoryCustomIntervalLength" valuetype="number"/>
  <atv:parameter behavior="optional" config="s;min;h;day;month" defaultvalue="h" desc="Custom Interval Unit" group="Category Selection" name="CategoryCustomIntervalUnit" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="0" desc="Category Time Offset" group="Category Selection" name="CategoryTimeOffset" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Global Enum List" group="EnumList" name="EnumList" valuetype="global"/>
  <atv:parameter behavior="optional" desc="Input1" group="Series 1" name="Series1Node" valuetype="address"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Label1" group="Series 1" name="Series1Label" valuetype="string"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Color1" group="Series 1" name="Series1Color" valuetype="color"/>
  <atv:parameter behavior="optional" desc="Input2" group="Series 2" name="Series2Node" valuetype="address"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Label2" group="Series 2" name="Series2Label" valuetype="string"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Color2" group="Series 2" name="Series2Color" valuetype="color"/>
  <atv:parameter behavior="optional" desc="Input3" group="Series 3" name="Series3Node" valuetype="address"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Label3" group="Series 3" name="Series3Label" valuetype="string"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Color3" group="Series 3" name="Series3Color" valuetype="color"/>
  <atv:parameter behavior="optional" desc="Input4" group="Series 4" name="Series4Node" valuetype="address"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Label4" group="Series 4" name="Series4Label" valuetype="string"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Color4" group="Series 4" name="Series4Color" valuetype="color"/>
  <atv:parameter behavior="optional" desc="Input5" group="Series 5" name="Series5Node" valuetype="address"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Label5" group="Series 5" name="Series5Label" valuetype="string"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Color5" group="Series 5" name="Series5Color" valuetype="color"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Title" group="Appereance" name="Title" valuetype="string"/>
  <atv:parameter behavior="optional" config="center;left;rigth" defaultvalue="center" desc="TitleAlign" group="Appereance" name="TitleAlign" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Subtitle" group="Appereance" name="Subtitle" valuetype="string"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="YName" group="Appereance" name="YName" valuetype="string"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="XName" group="Appereance" name="XName" valuetype="string"/>
  <atv:parameter behavior="optional" config="Color-Pallete;Color-Custom" defaultvalue="Color-Pallete" desc="Color Series Type" group="Appereance" name="ColorSeriesType" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Series Palette Color" group="Appereance" name="ColorSeriesPalette" substitute="$Color$" valuetype="global"/>
  <atv:parameter behavior="optional" defaultvalue="false" desc="Background Transparent Enabled" group="Appereance" name="ColorBackgroundTranspartentEnable" valuetype="bool"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Background Color" group="Appereance" name="ColorB" valuetype="global"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Grid Color" group="Appereance" name="ColorG" valuetype="global"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Color Title" group="Appereance" name="ColorTitle" valuetype="global"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Color Subtitle" group="Appereance" name="ColorSubTitle" valuetype="global"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Color Legend" group="Appereance" name="ColorLegend" valuetype="global"/>
  <atv:parameter behavior="optional" defaultvalue="#000000" desc="Color xAxis" group="Appereance" name="ColorxAxis" valuetype="color"/>
  <atv:parameter behavior="optional" defaultvalue="#000000" desc="Color yAxis" group="Appereance" name="ColoryAxis" valuetype="color"/>
  <atv:parameter behavior="optional" defaultvalue="SYSTEM.GLOBALS.atvFontColor" desc="Color dataLabels" group="Appereance" name="ColordataLabels" valuetype="global"/>
  <atv:parameter behavior="optional" defaultvalue="18" desc="TitleFontSize" group="Appereance" name="FontSizeTitle" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="14" desc="xAxis FontSize" group="Appereance" name="FontSizexAxis" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="14" desc="yAxis FontSize" group="Appereance" name="FontSizeyAxis" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="16" desc="Legend FontSize" group="Appereance" name="FontSizeLegend" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="16" desc="Data Labels FontSize" group="Appereance" name="FontSizedataLabels" valuetype="number"/>
  <atv:parameter behavior="optional" config="Value-Simple;Time-Dynamic;Time-Custom" defaultvalue="Value-Simple" desc="Data Label Type" group="Appereance" name="DatalabelType" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="mm:ss" desc="Data Label CustomTime Format" group="Appereance" name="DatalabelCustomTimeFormat" valuetype="string"/>
  <atv:parameter behavior="optional" defaultvalue="2" desc="Datalabel Number Decimals" group="Appereance" name="DatalabelNumberDecimals" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Datalabel Unit" group="Appereance" name="DatalabelUnit" valuetype="string"/>
  <atv:parameter behavior="optional" defaultvalue="2" desc="Line Width" group="Line Only" name="LineLineWidth" valuetype="number"/>
  <atv:parameter behavior="optional" config="Dash;DashDot;Dot;LongDash;LongDashDot;LongDashDotDot;ShortDash;ShortDashDot;ShortDashDotDot;ShortDot;Solid" defaultvalue="Solid" desc="Line Dash Style" group="Line Only" name="LineDashStyle" valuetype="enum"/>
  <atv:parameter behavior="optional" config="left;center;right" defaultvalue="center" desc="Label Position" group="Column Only" name="ColumnLabelPosition" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="false" desc="Stack Enabled" group="Column Only" name="ColumnStackEnabled" valuetype="bool"/>
  <atv:parameter behavior="optional" defaultvalue="100" desc="Pie Chart Size (%)" group="Pie Only" name="PieSize" valuetype="number"/>
  <atv:parameter behavior="optional" config="true;false" defaultvalue="false" desc="Place Labels Inside Pie" group="Pie Only" name="PieLabelInside" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="30" desc="Label Distance (pixels)" group="Pie Only" name="PieLabelDistance" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="100" desc="Max Value" group="Solid Gauge Only" name="SolidGaugeMaxValue" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Unit" group="Solid Gauge Only" name="SolidGaugeUnit" valuetype="string"/>
  <atv:parameter behavior="optional" defaultvalue="80" desc="OuterRadius" group="Solid Gauge Only" name="SolidGaugeOuterRadius" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="55" desc="InnerRadius" group="Solid Gauge Only" name="SolidGaugeInnerRadius" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Gauge Unit" group="Gauge Only" name="GaugeUnit" valuetype="string"/>
  <atv:parameter behavior="optional" defaultvalue="0" desc="Gauge Min" group="Gauge Only" name="GaugeMin" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="100" desc="Gauge Max" group="Gauge Only" name="GaugeMax" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Gauge Pane Color" group="Gauge Only" name="GaugePaneColor" valuetype="color"/>
  <atv:parameter behavior="optional" defaultvalue="0" desc="Gauge Band 1 Min" group="Gauge Only" name="GaugeBand1Min" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="50" desc="Gauge Band 1 Max" group="Gauge Only" name="GaugeBand1Max" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="#00aa00" desc="Gauge Band 1 Color" group="Gauge Only" name="GaugeBand1Color" valuetype="color"/>
  <atv:parameter behavior="optional" defaultvalue="50" desc="Gauge Band 2 Min" group="Gauge Only" name="GaugeBand2Min" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="75" desc="Gauge Band 2 Max" group="Gauge Only" name="GaugeBand2Max" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="#ecec00" desc="Gauge Band 2 Color" group="Gauge Only" name="GaugeBand2Color" valuetype="color"/>
  <atv:parameter behavior="optional" defaultvalue="75" desc="Gauge Band 3 Min" group="Gauge Only" name="GaugeBand3Min" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="100" desc="Gauge Band 3 Max" group="Gauge Only" name="GaugeBand3Max" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="#aa0000" desc="Gauge Band 3 Color" group="Gauge Only" name="GaugeBand3Color" valuetype="color"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Gauge Outer Radius" group="Gauge Only" name="GaugeOuterRadius" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Gauge Inner Radius" group="Gauge Only" name="GaugeInnerRadius" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Number of Bins" group="Histogram Only" name="HistogramNumberBins" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="OEEID" group="OEE Only" name="OEEID" valuetype="string"/>
  <atv:parameter behavior="optional" desc="Availability Counter Node" group="OEE Only" name="OEEAvailabilityCounterNode" valuetype="address"/>
  <atv:parameter behavior="optional" desc="Productivity Counter Node" group="OEE Only" name="OEEProductivityCounterNode" valuetype="address"/>
  <atv:parameter behavior="optional" desc="Quality Counter Node" group="OEE Only" name="OEEQualityCounterNode" valuetype="address"/>
  <atv:parameter behavior="optional" config="FixedSpeed;VariableSpeed;ExpectedUnitsCounter" defaultvalue="FixedSpeed" desc="Production Speed Method" group="OEE Only" name="OEEProductionSpeedMethod" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Production Fixed Speed" group="OEE Only" name="OEEProductionSpeed" valuetype="number"/>
  <atv:parameter behavior="optional" desc="Production Variable Speed Node" group="OEE Only" name="OEEProductionSpeedNode" valuetype="address"/>
  <atv:parameter behavior="optional" desc="Production Expected Units Counter Node" group="OEE Only" name="OEEProductionExpectedUnitsCounterNode" valuetype="address"/>
  <atv:parameter behavior="optional" config="U/s;U/min;U/h;U/d;U/month" defaultvalue="U/h" desc="Production Speed Unit" group="OEE Only" name="OEEProductionSpeedUnit" valuetype="enum"/>
  <atv:parameter behavior="optional" config="None;PlannedDowntimeEnum;PlannedDowntimeCounter" defaultvalue="None" desc="Planned Downtime Method" group="OEE Only" name="OEEPlannedDowntimeMethod" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="SYSTEM.GLOBALS.Advanced_Dashboard_List.OEE_Planned_Downtime_List" desc="Planned Downtime Enum" group="OEE Only" name="OEEPlannedDowntimeEnum" valuetype="global"/>
  <atv:parameter behavior="optional" desc="Planned Downtime Counter Node" group="OEE Only" name="OEEPlannedDowntimeCounterNode" valuetype="address"/>
  <atv:parameter behavior="optional" config="Input-BadUnits;Input-GoodUnits" defaultvalue="Input-BadUnits" desc="Quality Input Method" group="OEE Only" name="OEEQualityMethod" valuetype="enum"/>
  <atv:gridconfig enabled="true" gridstyle="lines" height="20" width="20"/>
  <atv:snapconfig enabled="true" height="10" width="10"/>
 </metadata>
 <rect atv:refpx="303.798" atv:refpy="140.5" fill="none" height="279" id="Border" stroke="#000000" stroke-width="2" width="605.597" x="1" y="1"/>
 <text atv:refpx="222.595" atv:refpy="160.4" fill="none" font-family="Arial" font-size="36" id="Label" text-anchor="middle" x="303.8" y="164.9">Advanced Chart</text>
 <foreignObject height="280" id="Chart_Container" width="605.597" x="0" y="0">
  <div style="width:100%;height:100%" xmlns="http://www.w3.org/1999/xhtml"/>
 </foreignObject>
 <script atv:desc="" atv:name="" type="text/ecmascript" xlink:href="../../highcharts/highcharts.js"/>
 <script atv:desc="" atv:name="" type="text/ecmascript" xlink:href="../../highcharts/highcharts-more.js"/>
 <script atv:desc="" atv:name="" type="text/ecmascript" xlink:href="../../highcharts/modules/exporting.js"/>
 <script atv:desc="" atv:name="" type="text/ecmascript" xlink:href="../../highcharts/modules/funnel.js"/>
 <script atv:desc="" atv:name="" type="text/ecmascript" xlink:href="../../highcharts/modules/solid-gauge.js"/>
 <script atv:desc="" atv:name="" type="text/ecmascript" xlink:href="../../highcharts/modules/histogram-bellcurve.js"/>
 <script atv:desc="" atv:name="" type="text/ecmascript" xlink:href="../../highcharts/modules/offline-exporting.js"/>
 <script atv:desc="" atv:name="" type="text/ecmascript" xlink:href="../../highcharts/modules/export-data.js"/>
 <script atv:desc="" atv:name="" type="text/ecmascript"><![CDATA[//------Initialize Variables-----------//

//------Parameters   
var Initializing=true;
var chartContainter;

//Chart Config Construction 
const elementRawConfig = { 
 
	// General Configuration
	GeneralConfig: {
		DashboardID: webMI.query["DashboardID"],
		ChartType: webMI.query["ChartType"],
		DataType: webMI.query["DataType"],
		SeriesSource: webMI.query["SeriesSource"],
		InitialRange: webMI.query["InitialRange"],
		InitialRangeUnit: webMI.query["InitialRangeUnit"]
	},
	
	// Zoom Configuration
	Zoom: {
		ZoomEnabled: webMI.query["ZoomEnabled"] 
	},
	
	// Data Optimization
	DataOptimization: {
		DataReductionEnabled: webMI.query["DataReductionEnabled"],
		DataReductionMaxSize: webMI.query["DataReductionMaxSize"]
	},
	
	// Limit Analysis	
	LimitAnalysis: {
		DataLimitEnabled: webMI.query["DataLimitEnabled"],
		DataMaxType: webMI.query["DataMaxType"],
		DataMaxLimit: webMI.query["DataMaxLimit"],
		DataMaxNode: webMI.query["DataMaxNode"],
		ColorLimitPointMax: webMI.query["ColorLimitPointMax"],		
		ColorLimitLineMax: webMI.query["ColorLimitLineMax"],
		TypeLimitLineMax: webMI.query["TypeLimitLineMax"],
		TextLimitLineMax: webMI.query["TextLimitLineMax"],
		DataMinType: webMI.query["DataMinType"],
		DataMinLimit: webMI.query["DataMinLimit"],		
		DataMinNode: webMI.query["DataMinNode"],
		ColorLimitPointMin: webMI.query["ColorLimitPointMin"],		
		ColorLimitLineMin: webMI.query["ColorLimitLineMin"],
		TypeLimitLineMin: webMI.query["TypeLimitLineMin"],
		TextLimitLineMin: webMI.query["TextLimitLineMin"]
	},
	
	// Data Processing
	DataProcessing: {
		DataProcessingEnabled: webMI.query["DataProcessingEnabled"]=== "true",
		ProcessingType: webMI.query["DataProcessingType"] !== undefined ? webMI.query["DataProcessingType"] : "Simple-None",
		DataProcessingTimeInputUnit:webMI.query["DataProcessingTimeInputUnit"],
	},
	
	// Formula
	 FormulaFX: {
        FormulaEnabled: webMI.query["FormulaEnabled"] === "true", // Convert string "true" to boolean
        FormulaDescription: webMI.query["FormulaDescription"],
        AParameterType: webMI.query["AParameterType"],
        AParameterValue: webMI.query["AParameterValue"],
        AParameterNode: webMI.query["AParameterNode"],
        BParameterType: webMI.query["BParameterType"],
        BParameterValue: webMI.query["BParameterValue"],
        BParameterNode: webMI.query["BParameterNode"],
        CParameterType: webMI.query["CParameterType"],
        CParameterValue: webMI.query["CParameterValue"],
        CParameterNode: webMI.query["CParameterNode"],
        DParameterType: webMI.query["DParameterType"],
        DParameterValue: webMI.query["DParameterValue"],
        DParameterNode: webMI.query["DParameterNode"],
        EParameterType: webMI.query["EParameterType"],
        EParameterValue: webMI.query["EParameterValue"],
        EParameterNode: webMI.query["EParameterNode"]
    },
	
	// Category
	Category: {
		CategoryType: webMI.query["CategoryType"],
		CategoryRound: webMI.query["CategoryRound"],
		CategoryCustomText: webMI.query["CategoryCustomText"] !== undefined ? webMI.query["CategoryCustomText"] : "",
		CategoryCustomIntervalLength: webMI.query["CategoryCustomIntervalLength"],
		CategoryCustomIntervalUnit: webMI.query["CategoryCustomIntervalUnit"],
		CategoryTimeOffset: webMI.query["CategoryTimeOffset"],
	},
	
	// EnumList
	EnumList: {
		EnumList: webMI.query["EnumList"]
	},
	
	// Series
	Series: [
		{
		  SeriesNode: webMI.query["Series1Node"],
		  SeriesLabel: webMI.query["Series1Label"],
		  SeriesColor: webMI.query["Series1Color"]
		},
		{
		  SeriesNode: webMI.query["Series2Node"],
		  SeriesLabel: webMI.query["Series2Label"],
		  SeriesColor: webMI.query["Series2Color"]
		},
		{
		  SeriesNode: webMI.query["Series3Node"],
		  SeriesLabel: webMI.query["Series3Label"],
		  SeriesColor: webMI.query["Series3Color"]
		},
		{
		  SeriesNode: webMI.query["Series4Node"],
		  SeriesLabel: webMI.query["Series4Label"],
		  SeriesColor: webMI.query["Series4Color"]
		},
		{
		  SeriesNode: webMI.query["Series5Node"],
		  SeriesLabel: webMI.query["Series5Label"],
		  SeriesColor: webMI.query["Series5Color"]
		}
	],
	
	// Appearance
	Appearance: {
		Title: webMI.query["Title"],
		TitleAlign: webMI.query["TitleAlign"],
		Subtitle: webMI.query["Subtitle"],
		YName: webMI.query["YName"],
		XName: webMI.query["XName"],
		ColorSeriesType:webMI.query["ColorSeriesType"],
		ColorSeriesPalette: webMI.query["ColorSeriesPalette"],
		ColorBackgroundTranspartentEnable:webMI.query["ColorBackgroundTranspartentEnable"],
		ColorBackground: webMI.query["ColorB"],
		ColorGrid: webMI.query["ColorG"],
		ColorTitle: webMI.query["ColorTitle"],
		ColorSubTitle: webMI.query["ColorSubTitle"],
		ColorLegend: webMI.query["ColorLegend"],
		ColorXaxis: webMI.query["ColorxAxis"],
		ColorYaxis: webMI.query["ColoryAxis"],
		ColorDataLabels: webMI.query["ColordataLabels"],
		FontSizeTitle: webMI.query["FontSizeTitle"],
		FontSizeXaxis: webMI.query["FontSizexAxis"],
		FontSizeYaxis: webMI.query["FontSizeyAxis"],
		FontSizeLegend: webMI.query["FontSizeLegend"],
		FontSizeDataLabels: webMI.query["FontSizedataLabels"],
		DatalabelType: webMI.query["DatalabelType"],
		DatalabelCustomTimeFormat: webMI.query["DatalabelCustomTimeFormat"],
		DatalabelNumberDecimals: webMI.query["DatalabelNumberDecimals"],
		DatalabelUnit: webMI.query["DatalabelUnit"]
	},
	
	// Line
	Line: {
		LineLineWidth: webMI.query["LineLineWidth"],
		LineDashStyle: webMI.query["LineDashStyle"]
	},	
	 
	// Column
	Column: {
		LabelPosition: webMI.query["ColumnLabelPosition"],
		StackEnabled: webMI.query["ColumnStackEnabled"]
	},
	
	// Pie
	Pie: {
		PieSize: webMI.query["PieSize"],
		PieLabelInside: webMI.query["PieLabelInside"] === "true", // Convert to boolean
        PieLabelDistance: webMI.query["PieLabelDistance"]
	},
	
	// SolidGauge
	SolidGauge: {
		Unit: webMI.query["SolidGaugeUnit"],
		MaxValue: webMI.query["SolidGaugeMaxValue"],
		OuterRadius: webMI.query["SolidGaugeOuterRadius"],
		InnerRadius: webMI.query["SolidGaugeInnerRadius"]
	},
	
	//Gauge
	Gauge: {
		Unit: webMI.query["GaugeUnit"],
		Min: webMI.query["GaugeMin"],
		Max: webMI.query["GaugeMax"],
		PaneColor:webMI.query["GaugePaneColor"],
		Band1Min: webMI.query["GaugeBand1Min"],
		Band1Max: webMI.query["GaugeBand1Max"],
		Band1Color:webMI.query["GaugeBand1Color"],
		Band2Min: webMI.query["GaugeBand2Min"],
		Band2Max: webMI.query["GaugeBand2Max"],
		Band2Color:webMI.query["GaugeBand2Color"],
		Band3Min: webMI.query["GaugeBand3Min"],
		Band3Max: webMI.query["GaugeBand3Max"],
		Band3Color:webMI.query["GaugeBand3Color"],
		OuterRadius: webMI.query["GaugeOuterRadius"],
		InnerRadius: webMI.query["GaugeInnerRadius"]
	},
	
	// Histogram
	Histogram: {
		NumberBins: webMI.query["HistogramNumberBins"]
	},
	
	
	// OEE
	OEE: {
		OEEID: webMI.query["OEEID"],
		//Main Counters
		OEEAvailabilityCounterNode:webMI.query["OEEAvailabilityCounterNode"],
		OEEProductivityCounterNode:webMI.query["OEEProductivityCounterNode"],
		OEEQualityCounterNode:webMI.query["OEEQualityCounterNode"],
		//Expected productivity
		OEEProductionSpeedMethod:webMI.query["OEEProductionSpeedMethod"],
		OEEProductionSpeed: webMI.query["OEEProductionSpeed"], 
		OEEProductionSpeedNode: webMI.query["OEEProductionSpeedNode"], 
		OEEProductionExpectedUnitsCounterNode:webMI.query["OEEProductionExpectedUnitsCounterNode"],
		OEEProductionSpeedUnit: webMI.query["OEEProductionSpeedUnit"],
		//Planned Downtime
		OEEPlannedDowntimeMethod:webMI.query["OEEPlannedDowntimeMethod"],
		OEEPlannedDowntimeEnum: webMI.query["OEEPlannedDowntimeEnum"],
		OEEPlannedDowntimeCounterNode:webMI.query["OEEPlannedDowntimeCounterNode"],
		//Quality Method
		OEEQualityMethod:webMI.query["OEEQualityMethod"]
	}
	
};


//Initialize Process
webMI.addOnload(function() {
	
	//Get Chart container
	chartContainter=document.getElementById("Chart_Container");
	
	//Create Chart Manager
    const singleChartManagerI=new singleChartManager(elementRawConfig);
    
    //Initialize Chart
    singleChartManagerI.initialize();


});


//Single Chart Manager
class singleChartManager {
	// Attributes
	elementRawConfig;
	elementConfig;
	elementID;
	elementData;
	elementNodes;
	operationMode;
	singleDataRequest;
	chartReference;
	specialParameters;	
	chartLabels;
	configConflicts;
	
	// Constructor
	constructor(elementRawConfig) {
		this.chartReference;
		this.elementData;
		this.limitData;
		this.elementDataRT;
		this.previousTooltip=[];
		this.elementID;
		this.chartLabels=[];
		this.configConflicts={};
		this.chartID=this.createChartID();
		this.chartTimeRange;
		this.elementRawConfig=elementRawConfig;   
		this.specialParameters=this.createSpecialParameters(); 
		this.operationMode="Hist"; //Real time by default
		this.elementConfig=this.elementConfigCreator(elementRawConfig);
		this.elementNodes=this.elementConfig.chartNodes;   
		this.dashboardReady=false;
		this.elementDataReady=false;
		this.firstTime=true;
		this.firstTimeRT=true;
		this.chartColors;	
		this.isPiePyramid=this.elementRawConfig.GeneralConfig.ChartType.toLowerCase() === "pie" || this.elementRawConfig.GeneralConfig.ChartType.toLowerCase() === "pyramid";		
		this.isSG=this.elementRawConfig.GeneralConfig.ChartType.toLowerCase() === "solidgauge";
		this.limitAnalysisEnabled = (this.elementRawConfig.LimitAnalysis.DataLimitEnabled=="true" && (this.elementRawConfig.LimitAnalysis.DataMaxLimit.length >0 || this.elementRawConfig.LimitAnalysis.DataMinLimit.length >0)) ;
		this.limitKey="_Limit"
	}
	
	//Initialize everything
	async initialize() {
		
		//Hide Label and Border
		webMI.gfx.setVisible("Label", false);
		webMI.gfx.setVisible("Border", false);	
		
		console.log("-----------Element Config------------");
		console.log(this.elementConfig);	
		console.log(this.chartLabels);
		
		//Add listeners           
		this.addListeners(); 
		
		//-----------------------------------------------//
		//----------For Single Chart Requests-----------//	
		
		if (this.elementRawConfig.GeneralConfig.DashboardID == "") {
						
			//Create Single Data Request
			this.singleDataRequest = await this.singleDataRequestCreator();
			console.log("-----------Single Data Request------------");
			console.log(this.singleDataRequest);
			
			//Call for data
			this.elementData = await this.singleelementDataCreator();
			console.log("-----------Single Element Data------------");

			//Initialize Chart
			this.initializeChart();
	
			//UpdateChart
			this.updateChart();
			
		}
			   
		//-----------------------------------------------//
		//----------In Dashboard Chart Requests---------//       
		else {   
			
			console.log("-----Registering from chart: "+this.chartID+"----------");
			
			//Wait for Dashboard ready
			await this.waitForDashboardReady();
			
			//First Register Elements
			this.registerElements();
			
			//Wait for Data Ready
			await this.waitForElementDataReady();	
			
			console.log("-----------Single Element Data------------");
			console.log(this.elementData);
			
			
			console.log("-----------this.elementRawConfig------------");
			console.log(JSON.stringify(this.elementRawConfig));
			
			var testElementData = await this.applyFormula(this.elementData.chartData.chartSeries); 
			console.log("-----------testElementData------------");
			console.log(testElementData);
			
			//Initialize Chart
			this.initializeChart();
	
			//UpdateChart
			this.updateChart();
			
		}
			 
		
	}
	
	//-----------------------------------------------//
	//----------------Data Methods-----------------//	
	//---------------------------------------------//
	
	// Adds Listeners
	addListeners() {
	
		//Dashboard Ready Listener
		webMI.trigger.connect("Dashboard_Ready_"+this.DashboardID, (e) => {
			this.dashboardReady=e;
			
			setTimeout((e) => {
				this.dashboardReady=false;
			},200);
		});	
		
		//Recieve Element Info		
		webMI.trigger.connect("Element_Data_"+this.chartID, (e) => {
			
			this.elementData=e.value;
			console.log("-------------this.elementData------------");	
			console.log(this.elementData);	
			
			//Historic Data
			if(this.elementData.RTInfo.OperationMode=="Hist"){
				
				//Update current Operation mode
				this.operationMode="Hist";
				
				//First time receives Element Data
				if(this.firstTime){
					this.elementDataReady=true;
					this.firstTime=false;
					
					//Toggle
					setTimeout((e) => {
						this.elementDataReady=false;
					},200);
				}
				
				//After Initialization
				else{
					
					console.log("-------------Updating Chart------------")
					//UpdateChart
					this.updateChart();
				
				}				
				
			}
			
			//Real Time Data
			else if(this.elementData.RTInfo.OperationMode=="RealTime"){
				
				//Update current Operation mode
				this.operationMode="RealTime";
				
				this.elementDataRT=this.elementData;
				console.log("this.elementDataRT");
				console.log(JSON.stringify(this.elementDataRT)); 
				console.log("-------------Updating RT Chart------------");				
				//UpdateChart RT
				this.updateRTChart();
			}
			
		});
		
		//Subcribe to Variable Changes	
		/*
		webMI.data.subscribe(this.elementNodes,(e) => {
			console.log("-------------New Value------------");
			console.log(e.address);
			
			// Updates chart with RT data
			this.updateChartRT(e.value); 
		});	*/
		
	}	
	
	// Registers Element in Menu
	registerElements() {
	
		//Register Element
		webMI.trigger.fire("Element_Config_Receiver_"+this.DashboardID, this.elementConfig); 
			
	}	
		
	// Creates Element Config
	elementConfigCreator() {  
	
		// ElementConfig Structure
		var elementConfig = {
			chartNodes: [],
			chartsConfig: {
				elementType: "Chart",
				chartID: this.chartID,
				chartType: this.elementRawConfig.GeneralConfig.ChartType,
				dataType: this.elementRawConfig.GeneralConfig.DataType,
				dataProcessingType: this.elementRawConfig.DataProcessing.DataProcessingEnabled == true ? this.elementRawConfig.DataProcessing.ProcessingType:"Simple-None",
				dataPrTUnit:this.elementRawConfig.DataProcessing.DataProcessingTimeInputUnit,
				dataReductionEnable: this.elementRawConfig.DataOptimization.DataReductionEnabled === "true",
				dataReductionMaxSize: Number(this.elementRawConfig.DataOptimization.DataReductionMaxSize),
				dataoutOfLimitEnable: this.elementRawConfig.LimitAnalysis.DataLimitEnabled === "true",
				categoryType: this.elementRawConfig.Category.CategoryType,
				categoryRound: this.elementRawConfig.Category.CategoryRound,
				categorCustomValue: this.elementRawConfig.Category.CategoryCustomText,				
				categoryCustomIntervalLength: this.elementRawConfig.Category.CategoryCustomIntervalLength,
				categoryCustomIntervalUnit: this.elementRawConfig.Category.CategoryCustomIntervalUnit,
				categoryTimeOffset:this.elementRawConfig.Category.CategoryTimeOffset,
				specialParameters:this.specialParameters
			}
		};
		
		//No Series Processing typ
		if(this.elementRawConfig.DataProcessing.ProcessingType==("FullRange-OEE")){
			if(this.elementRawConfig.OEE.OEEProductivityCounterNode!=undefined){
				elementConfig.chartNodes.push(this.elementRawConfig.OEE.OEEProductivityCounterNode);
				this.chartLabels.push("OEE");
			}
		}
		//Normal Processing type
		else {
			// Data Source Text
			if (this.elementRawConfig.GeneralConfig.SeriesSource === "Text") {		
			
			
				//Take source from parameters
				this.elementRawConfig.Series.forEach((seriesItem) => {
					if (seriesItem.SeriesNode && !elementConfig.chartNodes.includes(seriesItem.SeriesNode)) { // Check if SeriesNode is not undefined and not already included
						elementConfig.chartNodes.push(seriesItem.SeriesNode);
						this.chartLabels.push(seriesItem.SeriesLabel);
					}
					else if (elementConfig.chartNodes.includes(seriesItem.SeriesNode)){
						this.configConflicts["repeatedNode"]=true;
					}
				});
			}
			
			// Data Source Enum
			else if (this.elementRawConfig.GeneralConfig.SeriesSource === "EnumList") {
				for (const key in this.elementRawConfig.EnumList.EnumList) {
					if (this.elementRawConfig.EnumList.EnumList.hasOwnProperty(key)) {
						const enumItem = this.elementRawConfig.EnumList.EnumList[key];
						if (enumItem.Node && !elementConfig.chartNodes.includes(enumItem.Node)) { // Check if Node is not undefined and not already included
							elementConfig.chartNodes.push(enumItem.Node);
							this.chartLabels.push(enumItem.Label);
						}
						else if (elementConfig.chartNodes.includes(seriesItem.SeriesNode)){
							this.configConflicts["repeatedNode"]=true;
						}
					}
				}
			}
		}
			// Return elementConfig
			return elementConfig;
	}	
	
	// Creates ChartID based position and size
	createChartID() {
 		const thisElement = document.getElementById('Chart_Container');
		let index = thisElement.id.indexOf('_Chart_Container');
		return thisElement.id.substring(0, index);	
	}
		
	// Create Special Parameters
	createSpecialParameters() {
	
		var specialParametersI={};
		
		//Add Limit Nodes if enabled
		if (this.elementRawConfig.LimitAnalysis.DataLimitEnabled === "true") {
			//Add Max and Min Limit values
			if (this.elementRawConfig.LimitAnalysis.DataMaxType === "Fixed"){
				if (this.elementRawConfig.LimitAnalysis.DataMaxLimit != null && this.elementRawConfig.LimitAnalysis.DataMaxLimit.length > 0) {
					specialParametersI["dataMaxLimit"] = this.elementRawConfig.LimitAnalysis.DataMaxLimit;
				}
				else{
						specialParametersI["dataMaxLimit"]="";
				}
			}
			//Add Max Limit Node if type is Node
			else if (this.elementRawConfig.LimitAnalysis.DataMaxType === "Node" && this.elementRawConfig.LimitAnalysis.DataMaxNode != null) {
				specialParametersI["MaxLimitNode"] = this.elementRawConfig.LimitAnalysis.DataMaxNode;
			}
			
			if (this.elementRawConfig.LimitAnalysis.DataMinType === "Fixed"){
				if (this.elementRawConfig.LimitAnalysis.DataMinLimit != null && this.elementRawConfig.LimitAnalysis.DataMinLimit.length > 0) {
					specialParametersI["dataMinLimit"] = this.elementRawConfig.LimitAnalysis.DataMinLimit;
				}
				else{
						specialParametersI["dataMinLimit"]="";
				}
			}
			//Add Min Limit Node if type is Node
			else if (this.elementRawConfig.LimitAnalysis.DataMinType === "Node" && this.elementRawConfig.LimitAnalysis.DataMinNode != null) {
				specialParametersI["MinLimitNode"] = this.elementRawConfig.LimitAnalysis.DataMinNode;
			}			
			
			specialParametersI["dataMaxType"] = this.elementRawConfig.LimitAnalysis.DataMaxType;
			specialParametersI["dataMinType"] = this.elementRawConfig.LimitAnalysis.DataMinType;
		}
		
		if (this.elementRawConfig.DataProcessing.ProcessingType.includes("OEE")){
			
			//Add OEEID
			if (this.elementRawConfig.OEE.OEEID!=null && this.elementRawConfig.OEE.OEEID.length>0 ){
				specialParametersI["OEEID"]=this.elementRawConfig.OEE.OEEID;
			}
			
			//Only if is OEE Calculation
			if (this.elementRawConfig.DataProcessing.ProcessingType=="FullRange-OEE"){
			
				//-------------OEE Specific Variables	
							
				//Add Availability Counter Node
				if (this.elementRawConfig.OEE.OEEAvailabilityCounterNode!=null){
					specialParametersI["OEEAvN"]=this.elementRawConfig.OEE.OEEAvailabilityCounterNode;
				}
				if (this.elementRawConfig.OEE.OEEProductivityCounterNode!=null){
					specialParametersI["OEEPrN"]=this.elementRawConfig.OEE.OEEProductivityCounterNode;
				}
				if (this.elementRawConfig.OEE.OEEQualityCounterNode!=null){
					specialParametersI["OEEQuN"]=this.elementRawConfig.OEE.OEEQualityCounterNode;
				}
			}			

			//-------------Production Specific Variables
			
			if(this.elementRawConfig.DataProcessing.ProcessingType=="FullRange-OEEProductivity"|| this.elementRawConfig.DataProcessing.ProcessingType=="FullRange-OEE"){
			
				//Add Production Speed
				if (this.elementRawConfig.OEE.OEEProductionSpeedMethod=="FixedSpeed" && this.elementRawConfig.OEE.OEEProductionSpeed!=null){
					specialParametersI["OEEProSM"]=this.elementRawConfig.OEE.OEEProductionSpeedMethod;
					specialParametersI["OEEProSpeed"]=this.elementRawConfig.OEE.OEEProductionSpeed;
				}				
				//Add Production Speed Node
				else if (this.elementRawConfig.OEE.OEEProductionSpeedMethod=="VariableSpeed" && this.elementRawConfig.OEE.OEEProductionSpeedNode!=null){
					specialParametersI["OEEProSM"]=this.elementRawConfig.OEE.OEEProductionSpeedMethod;
					specialParametersI["OEEProdSpeedN"]=this.elementRawConfig.OEE.OEEProductionSpeedNode;
				}				
				//Add Production Expected Units Counter
				else if (this.elementRawConfig.OEE.OEEProductionSpeedMethod=="ExpectedUnitsCounter" && this.elementRawConfig.OEE.OEEProductionExpectedUnitsCounterNode!=null){
					specialParametersI["OEEProSM"]=this.elementRawConfig.OEE.OEEProductionSpeedMethod;
					specialParametersI["OEEProExUCN"]=this.elementRawConfig.OEE.OEEProductionExpectedUnitsCounterNode;
				}
				
				//Add Production Speed Unit
				if (this.elementRawConfig.OEE.OEEProductionSpeedUnit!=null){
					specialParametersI["OEEPSpU"]=this.elementRawConfig.OEE.OEEProductionSpeedUnit;
				}		
			
			}	
			
			
			//-------------Availability Specific Variables	
			if ((this.elementRawConfig.DataProcessing.ProcessingType=="FullRange-OEEAvailability"|| this.elementRawConfig.DataProcessing.ProcessingType=="FullRange-OEEProductivity"|| this.elementRawConfig.DataProcessing.ProcessingType=="FullRange-OEE")){
				
				//None Planned Downtime
				if (this.elementRawConfig.OEE.OEEPlannedDowntimeMethod=="None" && this.elementRawConfig.OEE.OEEPlannedDowntimeEnum!=null){
					specialParametersI["OEEPDownM"]="None" ;
					specialParametersI["OEEPDownE"]=[];
				}
				
				//Add Planned Downtime Enum 
				if (this.elementRawConfig.OEE.OEEPlannedDowntimeMethod=="PlannedDowntimeEnum" && this.elementRawConfig.OEE.OEEPlannedDowntimeEnum!=null){
					specialParametersI["OEEPDownM"]="PlannedDowntimeEnum" ;
					specialParametersI["OEEPDownE"]=this.extractTimeIntervals(this.elementRawConfig.OEE.OEEPlannedDowntimeEnum);
				}
				
					//Add Planned Downtime Counter 
				if (this.elementRawConfig.OEE.OEEPlannedDowntimeMethod=="PlannedDowntimeCounter" && this.elementRawConfig.OEE.OEEPlannedDowntimeCounterNode!=null){
					specialParametersI["OEEPDownM"]="PlannedDowntimeCounter" ;
					specialParametersI["OEEPDownCN"]=this.elementRawConfig.OEE.OEEPlannedDowntimeCounterNode;
				}
				
			}
			
			
			//-------------Quality Specific Variables
			
			//Add Productivity to OEEQuality
			if (this.elementRawConfig.OEE.OEEProductivityCounterNode!=null && (this.elementRawConfig.DataProcessing.ProcessingType=="FullRange-OEEQuality"|| this.elementRawConfig.DataProcessing.ProcessingType=="FullRange-OEE")){
				
				specialParametersI["OEEQM"]=this.elementRawConfig.OEE.OEEQualityMethod;
				if(this.elementRawConfig.DataProcessing.ProcessingType=="FullRange-OEEQuality"){
					specialParametersI["OEEPrN"]=this.elementRawConfig.OEE.OEEProductivityCounterNode;
				}
				
			}
		
		}
		else if (this.elementRawConfig.GeneralConfig.ChartType=="Histogram"){
			specialParametersI["HistogramNumberBins"]=this.elementRawConfig.Histogram.NumberBins;
		}
		
		return specialParametersI;
		
	}
	
	// Wait for Dashboard ready
	waitForDashboardReady() {
		return new Promise((resolve) => {
			const checkReady = () => {
				if (this.dashboardReady) {
					resolve();
				} else {
					setTimeout(checkReady, 100);
				}
			};
			checkReady();
		});
	}
	
	// Wait for Element Data ready
	waitForElementDataReady() {
		return new Promise((resolve) => {
			const checkReady = () => {
				if (this.elementDataReady) {
					console.log("-------Element Data Ready--------")
					resolve();
				} else {
					setTimeout(checkReady, 100);
				}
			};
			checkReady();
		});
	}
  
  
  
	//-----------------------------------------------//
	//----------------Chart Methods-----------------//	
	//---------------------------------------------//
	
	
	//-----------------------------------------------//
	//--------Historical Chart Functions------------//		
	
	// Initialize Chart
	initializeChart() {
		
		const labelFormatterR=this.dataLabelFormatter.bind(this);
		
		//Chart Options
		const chartOptions =  {
			chart: {
				type: (this.elementRawConfig.GeneralConfig.ChartType).toLowerCase(),
				backgroundColor: this.defineBackgroundColor(),
				chartManager: this
			},
			title: {
				text: this.elementRawConfig.Appearance.Title,
				align: this.elementRawConfig.Appearance.TitleAlign,  
				style: {
						fontSize: this.elementRawConfig.Appearance.FontSizeTitle + 'px',
						color: this.elementRawConfig.Appearance.ColorTitle
					}	
			},
			subtitle: {
				text: this.elementRawConfig.Appearance.Subtitle,
				style: {
					color: this.elementRawConfig.Appearance.ColorSubTitle
				}
			},
			xAxis: {
				title: {
					text: this.elementRawConfig.Appearance.XName,
					style: {
						color: this.elementRawConfig.Appearance.ColorYaxis,
						fontSize: this.elementRawConfig.Appearance.FontSizeYaxis + 'px'
					  }
				},
				labels: {
					style: {
						color: this.elementRawConfig.Appearance.ColorXaxis,  
						fontSize: this.elementRawConfig.Appearance.FontSizeXaxis + 'px' 
					}
				},						
			},
			yAxis: {
				title: {
					text: this.elementRawConfig.Appearance.YName,
					style: {
						color: this.elementRawConfig.Appearance.ColorYaxis,
						fontSize: this.elementRawConfig.Appearance.FontSizeYaxis + 'px'
					  }
				},
				visible: true,
				labels: {
				  style: {
					color: this.elementRawConfig.Appearance.ColorYaxis,
					fontSize: this.elementRawConfig.Appearance.FontSizeYaxis + 'px'
				  }
				}
			},
			legend: {
				itemStyle: {
				  color: this.elementRawConfig.Appearance.ColorLegend,
				  fontSize: this.elementRawConfig.Appearance.FontSizeLegend + 'px'
				}
			  },
		   	series: [{
				name: '',
				data: []
			}]
		}
		console.log("-----------Chart Selected Options------------");
		console.log(chartOptions);
	
		this.chartReference = Highcharts.chart(chartContainter, chartOptions);
		
	}
	
	// Updates chart 
	async updateChart() {
		
		console.log("-----------Update Chart------------");
				
		// --- Apply Formula if Enabled 
		if (this.elementRawConfig.FormulaFX.FormulaEnabled && this.elementData && this.elementData.chartData) {
			try {
				console.log("-----------Applying Formula to Historical Data------------");
				// Await the result of the formula application
				const modifiedChartSeries = await this.applyFormula(this.elementData.chartData.chartSeries);
				// IMPORTANT: Update the elementData with the modified series
				this.elementData.chartData.chartSeries = modifiedChartSeries;
				console.log("-----------Formula Applied, Modified Data:-----------");
				console.log(JSON.stringify(this.elementData.chartData.chartSeries)); // Log modified data for verification
			} catch (error) {
				 console.error("Failed to apply formula:", error);
			}
		}

		//Update chartRange
		this.chartTimeRange=this.elementData.RTInfo.ChartRange;	    
	    
	    //--------Update Categories-----//	
		this.updateCategories();
		
		//--------Update Series-----//	
		this.updateSeries();	
		
		//--------Specific Type Update-----//			
		this.specificUpdate();
		
		//--------Specific Type Update-----//	
		this.tooltipUpdater();			
		
	    console.log("-------Chart reference-----");		
		console.log(this.chartReference);
				
		
		//--------Specific Type Update-----//	
		this.chartReference.redraw();
		
		console.log("-------Chart reference-----");		
		console.log(this.chartReference);
		
	}
	
	//Update Categories
	updateCategories(){
		console.log("-----------Update Categories------------");
		
		//Prepare conditions
		const isDateTime = this.elementRawConfig.Category.CategoryType === "AllData-DateTime";
		const elementDataI = this.elementData.chartData;
		//--------Update Category-----//	
		
		//DateTime Category
		if (isDateTime) { 
			
			//Use Site Time Zone
			Highcharts.setOptions({
				global: {
					useUTC: false
				}
			});
			
			this.chartReference.xAxis[0].update({
				type: 'datetime',
			}, false);			
		} 
		
		// Other Category		
		else {
			if (elementDataI!=null) {

				//Special Categories for Singlepoint Processing
				if(this.elementRawConfig.DataProcessing.DataProcessingEnabled&&(this.elementRawConfig.DataProcessing.ProcessingType.includes("SinglePoint"))){
					
					let customCategories;
					
					//Apply Specific Config
					switch (this.elementRawConfig.GeneralConfig.ChartType) {
						case "Pie":
						case "Pyramid":
						case "Gauge":
						case "Solidgauge":
							let customCategories=elementDataI.chartCategories.map((category, index) => ({
								name:this.defineChartLabel(elementDataI.chartSeries[0].data[index].name),
								x:category
							}));
							this.chartReference.xAxis[0].setCategories(customCategories, false);							
						break;
						case "Column":
							 this.chartReference.xAxis[0].setCategories(elementDataI.chartCategories, false);
						break;
						
					}				
				} 
				//Common Categories
				else{
					this.chartReference.xAxis[0].setCategories(elementDataI.chartCategories, false);
				}
			}
		}
	}
	
	//Update Series
	updateSeries(){
	
		//This update the series based on the type
				
		//Prepare conditions
		const isDateTime = this.elementRawConfig.Category.CategoryType === "AllData-DateTime";
		const elementDataI = this.elementData.chartData;
		
		// Remove existing series 
		while (this.chartReference.series.length > 0) {
			this.chartReference.series[0].remove(false);
		}
		
		//Create Colors
		this.chartColors=this.createChartColors();
				
		//Add Series based on type
		switch (this.elementRawConfig.GeneralConfig.ChartType) {
			case "Pie":
			case "Pyramid":
				console.log("---------Is Pie or Pyramid-------");
				var seriesData;
				var seriesI={};
				
				//Add limits to the series
				if (this.limitAnalysisEnabled){ 
					console.log("-------Adding limits-----");	
					this.addLimitSeries();	
					
					seriesData=this.elementData.chartData.chartSeries[0].data;
					seriesI={
							name: this.elementRawConfig.GeneralConfig.ChartType,
							data: seriesData
							}
				}	
				
				else{
					console.log("elementDataI");
					console.log(elementDataI.chartSeries[0].data);
					seriesData = elementDataI.chartSeries[0].data.map((dataPoint, index) => ({
						y:dataPoint.y,
						color: this.chartColors[index],
						name: this.defineChartLabel(dataPoint.name)
					}));
					seriesI={
						name: this.elementRawConfig.GeneralConfig.ChartType,
						data: seriesData
					}
				}
				this.chartReference.addSeries(seriesI, false);
			break;		
				
			case "Solidgauge":
			case "Gauge":
				console.log("---------Is SG o Gauge-------");
				var seriesData;
				var seriesI={};
				
				//Add limits to the series
				if (this.limitAnalysisEnabled){ 
					console.log("-------Adding limits-----");	
					this.addLimitSeries();	

					seriesData= this.elementData.chartData.chartSeries[0].data;
					seriesI={
						name: this.defineChartLabel(elementDataI.chartSeries[0].name),
						data: seriesData,
						dial:this.elementData.chartData.chartSeries[0].dial
					}
				}				
				else{				
					seriesData = elementDataI.chartSeries[0].data.map((dataPoint, index) => ({
						y:dataPoint,
						color: this.chartColors[index],
					}));	
					seriesI={
						name: this.defineChartLabel(elementDataI.chartSeries[0].name),
						data: seriesData
					}				
				}	
				
				this.chartReference.addSeries(seriesI, false);
			break;			
			
			case "Line":
			case "Area":
			case "Spline":
				console.log("---------Is Line,Area or Spline-------");
				
				//Add limits to the series
				if (this.limitAnalysisEnabled){ 
					console.log("-------Adding limits-----");	
					this.addLimitSeries();		
				}
				
				console.log("-------Element Data-----");	
				console.log(elementDataI);	
				// Add new series for other chart types
				elementDataI.chartSeries.forEach((series, index) => {
				
					//It is a Limit Series (All Data only)
					if(series.custom==this.limitKey){
						this.chartReference.addSeries(series, false);
					}
					else { //It is not a Limit Series
						this.chartReference.addSeries({
							name: this.defineChartLabel(series.name),
							data: series.data,
							color: this.chartColors[index]
						}, false);
					}				
				});
				break;
						
				case "Column":
				case "Histogram":
				default:
					console.log("---------Is Column or Histogram-------");
					if (this.limitAnalysisEnabled){ 
							console.log("-------Adding limits-----");
							this.addLimitSeries();	
					}
							console.log("elementDataI.chartSeries");
							console.log(elementDataI.chartSeries);	
						// Add new series for other chart types
					elementDataI.chartSeries.forEach((series, index) => {
						if (this.limitAnalysisEnabled){ 				
							this.chartReference.addSeries(series, false);	
						}					
						//No limits
						else{
							
							this.chartReference.addSeries({
								name: this.defineChartLabel(series.name),
								data: series.data,
								color: this.chartColors[index]
							}, false);			
						}
					});
				break;				
		}
	}
	
	//Specific Chart Update
	specificUpdate() {

		console.log("----------Apply Specific Config------------");
		const labelFormatterR = this.dataLabelFormatter.bind(this); // Bind formatter function

        // --- Base Plot Line Configurations ---
        const minPlotLineConfig = {
            color: this.elementRawConfig.LimitAnalysis.ColorLimitLineMin || '#FF0000', // Default color
            value: parseFloat(this.elementRawConfig.LimitAnalysis.DataMinLimit), // Parse value
            width: 2,
            dashStyle: this.elementRawConfig.LimitAnalysis.TypeLimitLineMin || 'Solid', // Default style
            label: {
                text: this.elementRawConfig.LimitAnalysis.TextLimitLineMin || 'Min Limit', // Default text
                align: 'right',
                style: { color: this.elementRawConfig.LimitAnalysis.ColorLimitLineMin || '#FF0000', fontWeight: 'bold' }
            },
            zIndex: 5
        };
        const maxPlotLineConfig = {
            color: this.elementRawConfig.LimitAnalysis.ColorLimitLineMax || '#00FF00', // Default color
            value: parseFloat(this.elementRawConfig.LimitAnalysis.DataMaxLimit), // Parse value
            width: 2,
            dashStyle: this.elementRawConfig.LimitAnalysis.TypeLimitLineMax || 'Solid', // Default style
            label: {
                text: this.elementRawConfig.LimitAnalysis.TextLimitLineMax || 'Max Limit', // Default text
                align: 'right',
                style: { color: this.elementRawConfig.LimitAnalysis.ColorLimitLineMax || '#00FF00', fontWeight: 'bold' }
            },
            zIndex: 5
        };

        // --- Helper: Get Conditional Plot Lines for Y-Axis ---
        // Adds plot lines only if enabled, type is "Fixed", and value is valid.
        const getConditionalYAxisPlotLines = () => {
            const lines = [];
            if (this.limitAnalysisEnabled && this.elementRawConfig.LimitAnalysis.DataMinType === "Fixed" && !isNaN(minPlotLineConfig.value)) {
                lines.push(minPlotLineConfig);
            }
            if (this.limitAnalysisEnabled && this.elementRawConfig.LimitAnalysis.DataMaxType === "Fixed" && !isNaN(maxPlotLineConfig.value)) {
                lines.push(maxPlotLineConfig);
            }
            return lines;
        };

        // --- Helper: Get Conditional Plot Lines for X-Axis (for Bar charts) ---
        const getConditionalXAxisPlotLines = () => {
            const lines = [];
            if (this.limitAnalysisEnabled && this.elementRawConfig.LimitAnalysis.DataMinType === "Fixed" && !isNaN(minPlotLineConfig.value)) {
                lines.push(minPlotLineConfig); // Label alignment might need adjustment for X-axis
            }
            if (this.limitAnalysisEnabled && this.elementRawConfig.LimitAnalysis.DataMaxType === "Fixed" && !isNaN(maxPlotLineConfig.value)) {
                lines.push(maxPlotLineConfig); // Label alignment might need adjustment for X-axis
            }
            return lines;
        }

		//Apply Specific Config based on Chart Type
		switch (this.elementRawConfig.GeneralConfig.ChartType) {

			case "Line":
				this.chartReference.update({
					chart: {
						zooming: this.elementRawConfig.Zoom.ZoomEnabled === "true" ? { type: 'x' } : {},
						panning: this.elementRawConfig.Zoom.ZoomEnabled === "true",
						panKey: this.elementRawConfig.Zoom.ZoomEnabled === "true" ? 'shift' : ''
					},
					plotOptions: {
						line: {
							dashStyle: this.elementRawConfig.Line.LineDashStyle,
							lineWidth: parseInt(this.elementRawConfig.Line.LineLineWidth) || 2
						},
						series: { turboThreshold: 5000, dataGrouping: { enabled: true } }
					},
					yAxis: { plotLines: getConditionalYAxisPlotLines() },
					tooltip: { formatter: function () { return this.series.chart.options.chart.chartManager.tooltipCreator(this); } }
				}, false);
				break;

			case "Spline":
				this.chartReference.update({
					chart: {
						zooming: this.elementRawConfig.Zoom.ZoomEnabled === "true" ? { type: 'x' } : {},
						panning: this.elementRawConfig.Zoom.ZoomEnabled === "true",
						panKey: this.elementRawConfig.Zoom.ZoomEnabled === "true" ? 'shift' : ''
					},
					plotOptions: {
						spline: {
							dashStyle: this.elementRawConfig.Line.LineDashStyle,
							lineWidth: parseInt(this.elementRawConfig.Line.LineLineWidth) || 2
						},
                        series: { turboThreshold: 5000, dataGrouping: { enabled: true } }
					},
					yAxis: { plotLines: getConditionalYAxisPlotLines() },
					tooltip: { formatter: function () { return this.series.chart.options.chart.chartManager.tooltipCreator(this); } }
				}, false);
				break;

			case "Area":
				this.chartReference.update({
					chart: {
						zooming: this.elementRawConfig.Zoom.ZoomEnabled === "true" ? { type: 'x' } : {},
						panning: this.elementRawConfig.Zoom.ZoomEnabled === "true",
						panKey: this.elementRawConfig.Zoom.ZoomEnabled === "true" ? 'shift' : ''
					},
					plotOptions: {
						area: {
							fillOpacity: 0.5,
                            dashStyle: this.elementRawConfig.Line.LineDashStyle,
							lineWidth: parseInt(this.elementRawConfig.Line.LineLineWidth) || 2
						},
                        series: { turboThreshold: 5000, dataGrouping: { enabled: true } }
					},
					yAxis: { plotLines: getConditionalYAxisPlotLines() },
					tooltip: { formatter: function () { return this.series.chart.options.chart.chartManager.tooltipCreator(this); } }
				}, false);
				break;

			case "Column":
				this.chartReference.update({
					chart: {
						zooming: this.elementRawConfig.Zoom.ZoomEnabled === "true" ? { type: 'x' } : {},
						panning: this.elementRawConfig.Zoom.ZoomEnabled === "true",
						panKey: this.elementRawConfig.Zoom.ZoomEnabled === "true" ? 'shift' : ''
					},
					plotOptions: {
						column: {
							stacking: this.elementRawConfig.Column.StackEnabled === "true" ? 'normal' : undefined,
							borderWidth: 0,
							groupPadding: 0.2,
							dataLabels: {
								enabled: true, // Consider making configurable
								style: {
									color: this.elementRawConfig.Appearance.ColorDataLabels,
									fontSize: this.elementRawConfig.Appearance.FontSizeDataLabels + 'px',
                                    textOutline: 'none'
								},
								align: this.elementRawConfig.Column.LabelPosition || 'center',
								verticalAlign: 'bottom',
								formatter: function() { return labelFormatterR(this.y); } // Use bound formatter
							}
						}
					},
					yAxis: { plotLines: getConditionalYAxisPlotLines() },
					tooltip: { formatter: function () { return this.series.chart.options.chart.chartManager.tooltipCreator(this); } }
				}, false);
				break;

			case "Bar":
				 this.chartReference.update({
					plotOptions: {
						bar: {
                            stacking: this.elementRawConfig.Column.StackEnabled === "true" ? 'normal' : undefined,
							dataLabels: {
								enabled: true, // Consider making configurable
                                style: {
									color: this.elementRawConfig.Appearance.ColorDataLabels,
									fontSize: this.elementRawConfig.Appearance.FontSizeDataLabels + 'px',
                                    textOutline: 'none'
								},
                                formatter: function() { return labelFormatterR(this.y); }
							}
						}
					},
                    // Bar chart plot lines are on the X-Axis (value axis)
                    xAxis: { plotLines: getConditionalXAxisPlotLines() },
                    tooltip: { formatter: function () { return this.series.chart.options.chart.chartManager.tooltipCreator(this); } }
				}, false);
				break;

			case "Pie":
                // No Y-Axis plot lines for Pie charts
                const pieSizeParam = parseFloat(this.elementRawConfig.Pie.PieSize);
                const pieSize = (!isNaN(pieSizeParam) && pieSizeParam > 0) ? pieSizeParam + '%' : '100%';
                const labelInside = this.elementRawConfig.Pie.PieLabelInside === "true";
                const labelDistanceParam = parseFloat(this.elementRawConfig.Pie.PieLabelDistance);
                let labelDistance = labelInside ? -40 : 30;
                if (!isNaN(labelDistanceParam)) { labelDistance = labelInside ? -Math.abs(labelDistanceParam) : Math.abs(labelDistanceParam); }
                let labelOptions = {
                    enabled: true, distance: labelDistance, format: '<b>{point.name}</b>: {point.percentage:.1f} %',
                    overflow: 'justify', crop: false, style: { textOverflow: 'clip' },
                    connectorShape: labelInside ? 'connector' : 'crookedLine', crookDistance: '70%'
                };
				this.chartReference.update({
					plotOptions: { pie: { size: pieSize, allowPointSelect: true, cursor: 'pointer', dataLabels: labelOptions } },
					tooltip: { formatter: function () { return this.series.chart.options.chart.chartManager.tooltipCreator(this); } }
				}, false);
				break;

			case "Pyramid":
                // No Y-Axis plot lines for Pyramid charts
				this.chartReference.update({
					plotOptions: { pyramid: { reversed: false, width: '70%', height: '80%', dataLabels: { enabled: true, format: '<b>{point.name}</b>: {point.y:.1f}' } } },
					tooltip: { formatter: function () { return this.series.chart.options.chart.chartManager.tooltipCreator(this); } }
				}, false);
				break;

			case "Histogram":
				 this.chartReference.update({
					xAxis: [{}], // Basic xAxis, specific formatting if needed elsewhere
					yAxis: { plotLines: getConditionalYAxisPlotLines() }, // Apply plot lines to frequency axis
					plotOptions: {
						histogram: {
							dataLabels: {
								enabled: true,
								style: { color: this.elementRawConfig.Appearance.ColorDataLabels, fontSize: this.elementRawConfig.Appearance.FontSizeDataLabels + 'px', textOutline: 'none' },
                                formatter: function() { return this.y; } // Show frequency
							},
						}
					},
					tooltip: { // Specific tooltip for histogram bins
						formatter: function () { return `<b>Bin Range:</b> ${this.point.x.toFixed(2)} - ${this.point.x2.toFixed(2)}<br/><b>Frequency:</b> ${this.y}`; }
					}
				}, false);
				break;

			case "Solidgauge":
                // No Y-Axis plot lines for Solidgauge
                this.chartReference.update({
					chart: { height: '100%', marginTop: -10 },
					pane: {
						startAngle: 0, endAngle: 360,
						background: [{
							outerRadius: this.elementRawConfig.SolidGauge.OuterRadius + "%", innerRadius: this.elementRawConfig.SolidGauge.InnerRadius + "%",
							backgroundColor: Highcharts.color(this.chartColors ? this.chartColors[0] : '#81C6FF').setOpacity(0.3).get(), borderWidth: 0
						}]
					},
					yAxis: { min: 0, max: parseFloat(this.elementRawConfig.SolidGauge.MaxValue) || 100, lineWidth: 0, tickPositions: [] },
					plotOptions: {
						solidgauge: {
							innerRadius: this.elementRawConfig.SolidGauge.InnerRadius + "%", radius: this.elementRawConfig.SolidGauge.OuterRadius + "%",
							dataLabels: {
								enabled: true, borderWidth: 0, color: this.elementRawConfig.Appearance.ColorDataLabels,
								style: { fontSize: (parseInt(this.elementRawConfig.Appearance.FontSizeDataLabels) || 12) + 10 + 'px', textOutline: 'none' },
								y: -18, formatter: function () { return labelFormatterR(this.y); }
							},
							linecap: 'round', stickyTracking: false,
						}
					},
					tooltip: { formatter: function () { return this.series.chart.options.chart.chartManager.tooltipCreator(this); } }
				}, false);
				break;

			case "Gauge":
                 // Limits shown by plotBands in Gauge
                 const gaugeMin = parseFloat(this.elementRawConfig.Gauge.Min) || 0;
                 const gaugeMax = parseFloat(this.elementRawConfig.Gauge.Max) || 100;
                 this.chartReference.update({
					chart: { height: '80%' },
					pane: {
						startAngle: -90, endAngle: 89.9, background: [{ backgroundColor: this.elementRawConfig.Gauge.PaneColor || 'transparent', borderWidth: 0 }],
						center: ['50%', '75%'], size: '110%'
					},
					yAxis: {
						min: gaugeMin, max: gaugeMax, tickPixelInterval: 72, tickPosition: 'inside', tickColor: Highcharts.defaultOptions.chart.backgroundColor || '#FFFFFF',
                        tickLength: 20, tickWidth: 2, minorTickInterval: null, labels: { distance: 20, style: { fontSize: this.elementRawConfig.Appearance.FontSizeYaxis + 'px' } }, lineWidth: 0,
						plotBands: [ // Filter ensures only valid bands are added
                            { from: parseFloat(this.elementRawConfig.Gauge.Band1Min), to: parseFloat(this.elementRawConfig.Gauge.Band1Max), color: this.elementRawConfig.Gauge.Band1Color, thickness: 20, borderRadius: '50%' },
                            { from: parseFloat(this.elementRawConfig.Gauge.Band2Min), to: parseFloat(this.elementRawConfig.Gauge.Band2Max), color: this.elementRawConfig.Gauge.Band2Color, thickness: 20 },
                            { from: parseFloat(this.elementRawConfig.Gauge.Band3Min), to: parseFloat(this.elementRawConfig.Gauge.Band3Max), color: this.elementRawConfig.Gauge.Band3Color, thickness: 20, borderRadius: '50%' }
                        ].filter(band => !isNaN(band.from) && !isNaN(band.to))
					},
					plotOptions: {
						gauge: {
							dataLabels: {
								borderWidth: 0, color: this.elementRawConfig.Appearance.ColorDataLabels,
								style: { fontSize: (parseInt(this.elementRawConfig.Appearance.FontSizeDataLabels) || 12) + 4 + 'px', textOutline: 'none' },
                                formatter: function () { return labelFormatterR(this.y); }
							},
							dial: { radius: '80%', backgroundColor: 'gray', baseWidth: 12, baseLength: '0%', rearLength: '0%' },
							pivot: { backgroundColor: 'gray', radius: 6 }
						}
					},
					tooltip: { formatter: function () { return this.series.chart.options.chart.chartManager.tooltipCreator(this); } }
				}, false);
			    break;

			default:
				console.log(`No specific configurations implemented for chart type: ${this.elementRawConfig.GeneralConfig.ChartType}`);
		}
	}
	
	//Creates tooltip when called it
	tooltipCreator (thisI) {						
	
	
		const chartManager = thisI.series.chart.options.chart.chartManager;
		const operationMode = chartManager.operationMode;
		let tooltipInfo=chartManager.previousTooltip;
		var tooltip;
		var foundTooltip;

		switch (this.elementRawConfig.GeneralConfig.ChartType) {
			//Pie Chart
			case "Line":
			case "Spline":
			case "Area":
				const date = new Date(thisI.x).toLocaleString(); // Converts x-value to a formatted date string
							return `<b style="color: ${thisI.series.color};">${"Date"}</b>: ${date}<br><b style="color: ${thisI.series.color};">${thisI.series.name}</b>: ${(thisI.y).toFixed(3)}`;			
				break;
			//Pie Chart
			case "Pie":
			case "Pyramid":
				foundTooltip = tooltipInfo.find(obj => chartManager.defineChartLabel(obj.name) === thisI.key);
				if(chartManager.elementRawConfig.DataProcessing.ProcessingType.includes("SinglePoint")) {				
					tooltip = `<b style="color: ${thisI.series.color};">Date</b>: ${foundTooltip.tooltipInfo}<br><b style="color: ${thisI.series.color};">${thisI.key}</b>: ${thisI.y.toFixed(3)}`;
				}
				else if(chartManager.elementRawConfig.DataProcessing.ProcessingType.includes("FullRange")) {
					tooltip = `<b style="color: ${thisI.series.color};">Initial Date</b>: ${foundTooltip.tooltipInfo.start}<br><b style="color: ${thisI.series.color};">Final Date</b>: ${foundTooltip.tooltipInfo.end}<br><b style="color: ${thisI.series.color};">${thisI.key}</b>: ${thisI.y.toFixed(3)}`;
				}
				if(chartManager.elementRawConfig.DataProcessing.ProcessingType.includes("Simple")) {				
					tooltip = `<b style="color: ${thisI.series.color};">Date</b>: ${foundTooltip.tooltipInfo}<br><b style="color: ${thisI.series.color};">${thisI.key}</b>: ${thisI.y.toFixed(3)}`;
				}
				break;
			case "Solidgauge":
			case "Gauge":
				foundTooltip = tooltipInfo.find(obj => chartManager.defineChartLabel(obj.name) === thisI.series.name);
				if(chartManager.elementRawConfig.DataProcessing.ProcessingType.includes("SinglePoint")) {				
					tooltip = `<b style="color: ${thisI.series.color};">Date</b>: ${foundTooltip.tooltipInfo}<br><b style="color: ${thisI.series.color};">${thisI.series.name}</b>: ${thisI.y.toFixed(3)}`;
				}
				else if(chartManager.elementRawConfig.DataProcessing.ProcessingType.includes("FullRange")) {
					tooltip = `<b style="color: ${thisI.series.color};">Initial Date</b>: ${foundTooltip.tooltipInfo.start}<br><b style="color: ${thisI.series.color};">Final Date</b>: ${foundTooltip.tooltipInfo.end}<br><b style="color: ${thisI.series.color};">${thisI.series.name}</b>: ${thisI.y.toFixed(3)}`;
				}
				if(chartManager.elementRawConfig.DataProcessing.ProcessingType.includes("Simple")) {				
					tooltip = `<b style="color: ${thisI.series.color};">Date</b>: ${foundTooltip.tooltipInfo}<br><b style="color: ${thisI.series.color};">${thisI.series.name}</b>: ${thisI.y.toFixed(3)}`;
				}
				break;
			case "Column":			
				foundTooltip = tooltipInfo.find(obj => chartManager.defineChartLabel(obj.name) === thisI.series.name);
				//Simple Processing type
				if(chartManager.elementRawConfig.DataProcessing.ProcessingType.includes("SinglePoint")) {
					tooltip = `<b style="color: ${thisI.series.color};">Date</b>: ${foundTooltip.tooltipInfo}<br><b style="color: ${thisI.series.color};">${thisI.series.name}</b>: ${thisI.y.toFixed(3)}`;	
				}
				else if(chartManager.elementRawConfig.DataProcessing.ProcessingType.includes("FullRange")) {
					tooltip = `<b style="color: ${thisI.series.color};">Initial Date</b>: ${foundTooltip.tooltipInfo.start}<br><b style="color: ${thisI.series.color};">Final Date</b>: ${foundTooltip.tooltipInfo.end}<br><b style="color: ${thisI.series.color};">${thisI.series.name}</b>: ${thisI.y.toFixed(3)}`;	
				}
				else if(chartManager.elementRawConfig.DataProcessing.ProcessingType.includes("Interval")) {
					const index = thisI.point.index;
					tooltip = `<b style="color: ${thisI.series.color};">Initial Date</b>: ${foundTooltip.tooltipInfo[index].start}<br><b style="color: ${thisI.series.color};">Final Date</b>: ${foundTooltip.tooltipInfo[index].end}<br><b style="color: ${thisI.series.color};">${thisI.series.name}</b>: ${thisI.y.toFixed(3)}`;	
				}
				
				
				break;
		}
		return tooltip;
	}
	
	//Update tooltip
	tooltipUpdater(){
	
		const operationMode = this.operationMode;
		let tooltipInfo;
		var tooltip;
		var foundTooltip;
		var newInterval=false;
		
		//Historic Operation
		if (operationMode === "Hist") {								
			
			// Save the updated previousTooltip back to chartManager
			this.previousTooltip = this.elementData.chartData.tooltipInfo;

		}
		
		// Real-time Operation
		else if (operationMode === "RealTime") {
			
	
			const currentTooltip = this.elementDataRT.chartData.tooltipInfo;
			const previousTooltip = this.previousTooltip;
	
			// Step 2: Iterate through previousTooltip and check if there's new info in currentTooltip
			previousTooltip.forEach((prevTooltip, i) => {
				const currentTooltipfound = currentTooltip.find(curr => curr.name === prevTooltip.name);
	
				// Step 3: Update if there's a match
				if (currentTooltipfound) {
					if (this.elementConfig.chartsConfig.categoryType.includes("Single")) {
						// Direct update for "Single" category type
						previousTooltip[i].tooltipInfo = currentTooltipfound.tooltipInfo;
	
						// Also check if any currentTooltip element has a new name not present in previousTooltip
						const currentTooltipdifferent = currentTooltip.find(curr => !previousTooltip.some(prev => prev.name === curr.name));
						if (currentTooltipdifferent) {
							// Push new element to previousTooltip
							previousTooltip.push(currentTooltipdifferent);
						}
	
					} 
					else if (this.elementConfig.chartsConfig.categoryType.includes("Interval") && !(this.elementConfig.chartsConfig.categoryType==("Interval-Histogram"))) {
						
						//Check if it's a new interval
						const intervalInfo = this.elementDataRT.chartData.informationRT;
						newInterval = intervalInfo.some(info => info.IntervalInfo.newInterval);
						
						if (!newInterval){
							// Step 4: Update the last element if not a new interval
							previousTooltip[i].tooltipInfo[previousTooltip[i].tooltipInfo.length - 1] = currentTooltipfound.tooltipInfo;		}
					}
					else if (this.elementConfig.chartsConfig.categoryType.includes("Histogram")) {
					
					}
				}
			});
	
			// Step 5: Handle new interval (this is done separately, outside the previousTooltip loop)
			if (this.elementConfig.chartsConfig.categoryType.includes("Interval") && newInterval) {
				previousTooltip.forEach((prevTooltip) => {
					// Find the corresponding tooltip in currentTooltip
					const currentTooltipfound = currentTooltip.find(curr => curr.name === prevTooltip.name);
	
					if (currentTooltipfound) {
						// Push new info and shift (remove first element)
						prevTooltip.tooltipInfo.push(currentTooltipfound.tooltipInfo);
						prevTooltip.tooltipInfo.shift();
	
					} else {
						// If no match, use the first element from currentTooltip and shift
						const firstTooltip = currentTooltip[0];
						prevTooltip.tooltipInfo.push(firstTooltip.tooltipInfo);
						prevTooltip.tooltipInfo.shift();
					}
				});
			}
			this.previousTooltip = previousTooltip;			
		}		
	}	
	
	//Add limits	
	addLimitSeries() {
		if (!this.elementData || !this.elementData.chartData || !this.elementData.chartData.LimitDashboardData) {
			console.error("Element data is not available or does not contain limit data.");
			return;
		}
	
		const chartSeries = this.elementData.chartData.chartSeries;
		this.limitData = this.elementData.chartData.LimitDashboardData;
	
		// Check the category type
		if (this.elementConfig.chartsConfig.categoryType === "AllData-DateTime") {
			
			this.limitData.forEach(limitData => {
				let limitSeries; // Declare limitSeries variable
					console.log("MinLimit Line Color Parameter:", this.elementRawConfig.LimitAnalysis.ColorLimitLineMin); // DEBUG: Log the color value
				// Check if the name ends with _MaxLimPlot or _MinLimPlot
				if (limitData.name.endsWith('_MaxLimPlot')) {
					limitSeries = {
						type: 'line',
						name: 'MaxLimit', // Set name to MaxLimit
						data: limitData.data, // Keep original data format [[ts, val], ...]
						color: this.elementRawConfig.LimitAnalysis.ColorLimitLineMax, // Use Max limit line color
						dashStyle: this.elementRawConfig.LimitAnalysis.TypeLimitLineMax, // Use Max limit line style
						lineWidth: 2, // Set line width
						custom: this.limitKey, // Keep custom key
						marker: {
							enabled: false, // Disable markers
							radius: 0, // Explicitly set radius to 0
							states: { // Ensure hover state doesn't enable markers
								hover: {
									enabled: false
								}
							}
						},
						enableMouseTracking: false // Optional: Disable tooltips for these lines
					};
				} else if (limitData.name.endsWith('_MinLimPlot')) {
					limitSeries = {
						type:'line',
						name: 'MinLimit', // Set name to MinLimit
						data: limitData.data, // Keep original data format [[ts, val], ...]					
						color: this.elementRawConfig.LimitAnalysis.ColorLimitLineMin, // Use Min limit Line
						dashStyle: this.elementRawConfig.LimitAnalysis.TypeLimitLineMin, // Use Min limit line style
						lineWidth: 2, // Set line width
						custom: this.limitKey, // Keep custom key
						marker: {
							enabled: false, // Disable markers
							radius: 0, // Explicitly set radius to 0
							states: { // Ensure hover state doesn't enable markers
								hover: {
									enabled: false
								}
							}
						},
						enableMouseTracking: false // Optional: Disable tooltips for these lines
					};
				} else {
					// Existing logic for scatter points (names not ending with _MaxLimPlot/_MinLimPlot)
					limitSeries = {
						type: 'scatter',
						name: this.defineChartLabel(limitData.name), // Keep existing name logic
						custom: this.limitKey, // Keep custom key
						data: limitData.data.map(limitPoint => ({
							x: limitPoint[0],
							y: limitPoint[1],
							color: limitPoint[1] > this.elementRawConfig.LimitAnalysis.DataMaxLimit
								? this.elementRawConfig.LimitAnalysis.ColorLimitPointMax
								: limitPoint[1] < this.elementRawConfig.LimitAnalysis.DataMinLimit
									? this.elementRawConfig.LimitAnalysis.ColorLimitPointMin
									: undefined // Default color if within limits
						})),
						marker: {
							enabled: true,
							symbol: 'circle'
						},
						lineWidth: 0 // No connecting line for scatter
					};
				}
	
				// Add the configured limit series to the chart series array
				chartSeries.push(limitSeries);
			});
		} 
		
		else if (this.elementConfig.chartsConfig.categoryType.includes("Interval")) {
			// New action for "Interval" category type
			chartSeries.forEach((series, indexS) => {
				// Find the corresponding limitData by name
				const limitData = this.limitData.find(limit => limit.name === (series.name)+this.limitKey);
				const colorIndex = this.elementNodes.findIndex(node => node === (series.name));
				
				if(this.elementRawConfig.GeneralConfig.ChartType== "Column"){				
					if (limitData) {
						series.name= this.defineChartLabel(series.name);
						series.color= this.chartColors[colorIndex];
						
						series.data = series.data.map((dataPoint, index) => {
							if (limitData.data[index] === 1) {
								return {
									y: dataPoint,
									color: dataPoint > this.elementRawConfig.LimitAnalysis.DataMaxLimit
										? this.elementRawConfig.LimitAnalysis.ColorLimitPointMax
										: dataPoint < this.elementRawConfig.LimitAnalysis.DataMinLimit
											? this.elementRawConfig.LimitAnalysis.ColorLimitPointMin
											: this.chartColors[colorIndex] // Default color if within limits
								};
							} else {
								return {
									y: dataPoint,
									color:this.chartColors[colorIndex] // Default color if within limits
								};
							}
						});
					}
				}
				
				else if(this.elementRawConfig.GeneralConfig.ChartType== "Histogram"){
					console.log("Entering to Histogram")
					series.name= this.defineChartLabel(series.name);
					series.type="histogram";
					series.data = series.data.map((dataPoint, index) => {						
						return {
							y: dataPoint,
							color: dataPoint > this.elementRawConfig.LimitAnalysis.DataMaxLimit
								? this.elementRawConfig.LimitAnalysis.ColorLimitPointMax
								: dataPoint < this.elementRawConfig.LimitAnalysis.DataMinLimit
									? this.elementRawConfig.LimitAnalysis.ColorLimitPointMin
									: this.chartColors[colorIndex] // Default color if within limits
						};
					});
				}
			});
		}
		
		else if (this.elementConfig.chartsConfig.categoryType.includes("Single")) {
			console.log("Excecuting Single logic")
			// Find the corresponding limitData by name		
			
			const colorIndex = this.elementNodes.findIndex(node => node === (chartSeries[0].name));
			var chartSeriesI={};
				
			if (this.elementRawConfig.GeneralConfig.ChartType== "Gauge"||this.elementRawConfig.GeneralConfig.ChartType== "Solidgauge"){			
				chartSeriesI["data"] = chartSeries[0].data.map((dataPoint, index) => ({
					y:dataPoint,
					color: dataPoint > this.elementRawConfig.LimitAnalysis.DataMaxLimit
									? this.elementRawConfig.LimitAnalysis.ColorLimitPointMax
									: dataPoint < this.elementRawConfig.LimitAnalysis.DataMinLimit
									? this.elementRawConfig.LimitAnalysis.ColorLimitPointMin
									: this.chartColors[colorIndex], // Default color if within limits,
				}));
				
				//Special Dial Update
				if (this.elementRawConfig.GeneralConfig.ChartType== "Gauge"){
					const limitDialColor=chartSeriesI.data[0].color==this.chartColors[colorIndex] ? "#808080":chartSeriesI.data[0].color;
					chartSeriesI["dial"]= {
						backgroundColor: limitDialColor, // Custom color for the needle
						borderColor: limitDialColor // Border color for the needle
					
					}
					chartSeries[0]["dial"]=chartSeriesI.dial;				
				}

			}
		
			else if	(this.elementRawConfig.GeneralConfig.ChartType== "Pie"||this.elementRawConfig.GeneralConfig.ChartType== "Pyramid")
			{
				chartSeriesI["data"] = chartSeries[0].data.map((dataPoint, index) => ({
						y:dataPoint.y,
						color: dataPoint.y > this.elementRawConfig.LimitAnalysis.DataMaxLimit
										? this.elementRawConfig.LimitAnalysis.ColorLimitPointMax
										: dataPoint.y < this.elementRawConfig.LimitAnalysis.DataMinLimit
										? this.elementRawConfig.LimitAnalysis.ColorLimitPointMin
										: this.chartColors[this.elementNodes.findIndex(node => node === (dataPoint.name))], // Default color if within limits,
						name: this.defineChartLabel(dataPoint.name)
				}));
			}	
			chartSeries[0].data=chartSeriesI.data;						
						
		}
		// Update this.elementData.chartData.chartSeries
		this.elementData.chartData.chartSeries = chartSeries;		
	}
	
	
	//-----------------------------------------------//
	//--------RT Chart Functions------------//

	async updateRTChart() {						
	
		// --- Apply Formula if Enabled (BEFORE processing RT updates) ---
		if (this.elementRawConfig.FormulaFX.FormulaEnabled && this.elementDataRT && this.elementDataRT.chartData) {
			 try {
				console.log("-----------Applying Formula to RT Data------------");
				// Await the result
				const modifiedChartSeries = await this.applyFormula(this.elementDataRT.chartData.chartSeries);
				// Update elementDataRT with modified series
				this.elementDataRT.chartData.chartSeries = modifiedChartSeries;
				 console.log("-----------Formula Applied to RT, Modified Data:-----------");
				 console.log(JSON.stringify(this.elementDataRT.chartData.chartSeries));
			} catch (error) {
				 console.error("Failed to apply formula to RT data:", error);
			}
		}

		const dataProcessingType = this.elementConfig.chartsConfig.dataProcessingType;
		const elementDataRT = this.elementDataRT;
		
		//Update tooltips
		this.tooltipUpdater();		
		
		//Add limits to the series
		if (this.limitAnalysisEnabled){ 
			console.log("-------Adding limits-----");	
			this.addLimitSeriesRT();		
		}
		
		//Simple Processing (All Data)
		if (dataProcessingType.includes("Simple")) {
				this.updateSimpleData();
		} 
		//FullRange/SinglePoint Processing (One Point)
		else if (dataProcessingType.includes("FullRange") || dataProcessingType.includes("SinglePoint")) {
		
			console.log("-----Updating Full Range--------")
			if (this.firstTimeRT)	{
				setTimeout((e) => {	
					this.updateFullRangeOrSinglePointData();
				},500);
			}
			else{				
				this.updateFullRangeOrSinglePointData();				
			}
		} 
		//Interval Processing (Intervals)
		else if (dataProcessingType.includes("Interval")) {
			if (this.firstTimeRT)	{
				setTimeout((e) => {	
					this.updateIntervalData();
				},200);
			}
			else{				
				this.updateIntervalData();				
			}
			
		} 
		else {
			console.error("Unsupported dataProcessingType: ", dataProcessingType);
		}
	
	}	
	
	addLimitSeriesRT() {
		console.log(this.elementDataRT);
		if (!this.elementDataRT || !this.elementDataRT.chartData || !this.elementDataRT.chartData.LimitDashboardData) {
			console.error("Element data is not available or does not contain limit data.");
			return;
		}
		
		const chartSeries = this.elementDataRT.chartData.chartSeries;
		this.limitData = this.elementDataRT.chartData.LimitDashboardData;
	
		// Check the category type
		if (this.elementConfig.chartsConfig.categoryType === "AllData-DateTime") {					
			
			let limitSeries=[];
			this.limitData.forEach(limitData => {
			
			// Check if the name ends with _MaxLimPlot or _MinLimPlot
			if (limitData.name.endsWith('_MaxLimPlot')) {
				limitSeries = {
					name: 'MaxLimit', // Set name to MaxLimit
					custom: this.limitKey,
					data: limitData.data, 
					color: this.elementRawConfig.LimitAnalysis.ColorLimitLineMax, // Use Max limit line color
					dashStyle: this.elementRawConfig.LimitAnalysis.TypeLimitLineMax, // Use Max limit line style
					lineWidth: 2, // Set line width
					marker: {
						enabled: false, // Disable markers
						radius: 0, // Explicitly set radius to 0
						states: { // Ensure hover state doesn't enable markers
							hover: {
								enabled: false
							}
						}
					},
					enableMouseTracking: false // Optional: Disable tooltips for these lines
				};
			}
			
		   else if (limitData.name.endsWith('_MinLimPlot')) {
					limitSeries = {
						name: 'MinLimit', // Set name to MinLimit
						custom: this.limitKey, // Keep custom key
						data: limitData.data.map(limitPoint => ({
								x: limitPoint[0],
								y: limitPoint[1]
							})),				
						color: this.elementRawConfig.LimitAnalysis.ColorLimitLineMin, // Use Min limit Line
						dashStyle: this.elementRawConfig.LimitAnalysis.TypeLimitLineMin, // Use Min limit line style
						lineWidth: 2, // Set line width
						marker: {
							enabled: false, // Disable markers
							radius: 0, // Explicitly set radius to 0
							states: { // Ensure hover state doesn't enable markers
								hover: {
									enabled: false
								}
							}
						},
						enableMouseTracking: false // Optional: Disable tooltips for these lines
					};
			}
			
			else{				
				// Create a new series for the limit data
				 limitSeries = {
					name: this.defineChartLabel(limitData.name),
					custom: this.limitKey,
					data: limitData.data.map(limitPoint => ({
						x: limitPoint[0],
						y: limitPoint[1],
						color: limitPoint[1] > this.elementRawConfig.LimitAnalysis.DataMaxLimit
							? this.elementRawConfig.LimitAnalysis.ColorLimitPointMax
							: limitPoint[1] < this.elementRawConfig.LimitAnalysis.DataMinLimit
								? this.elementRawConfig.LimitAnalysis.ColorLimitPointMin
								: undefined // Default color if within limits
					})),
					marker: {
						enabled: true,
						symbol: 'circle'
					},
					lineWidth: 0 // No connecting line
				};
				
			 }
		
					// Add the limit series to the chart series
					chartSeries.push(limitSeries);
					
			});
			console.log("chartSeries after");
			console.log(chartSeries);
		} 
		
		else if (this.elementConfig.chartsConfig.categoryType.includes("Interval")) {
			console.log("For Interval")
			// Process interval data
			chartSeries.forEach((series, indexS) => {
				// Find the corresponding limitData by name
				const limitData = this.limitData.find(limit => limit.name === (series.name + this.limitKey));
				const colorIndex = this.elementNodes.findIndex(node => node === (series.name));
				
				if(this.elementRawConfig.GeneralConfig.ChartType== "Column"){	
					if (limitData) {
						console.log("Entered Limit Data");
						series.data = series.data.map((dataPoint, index) => {
							if (limitData.data[index] === 1) {
								return {
									y: dataPoint,
									color: dataPoint > this.elementRawConfig.LimitAnalysis.DataMaxLimit
										? this.elementRawConfig.LimitAnalysis.ColorLimitPointMax
										: dataPoint < this.elementRawConfig.LimitAnalysis.DataMinLimit
											? this.elementRawConfig.LimitAnalysis.ColorLimitPointMin
											: this.chartColors[colorIndex] // Default color if within limits
								};
							} else {
								return {
									y: dataPoint,
									color:this.chartColors[colorIndex] // Default color if within limits
								};
							}
						});
					}					
				}	
				
				else if(this.elementRawConfig.GeneralConfig.ChartType== "Histogram"){
					console.log("Entering to Histogram")
					series.name= this.defineChartLabel(series.name);
					series.type="histogram";
					series.data = series.data.map((dataPoint, index) => {						
						return {
							y: dataPoint,
							color: dataPoint > this.elementRawConfig.LimitAnalysis.DataMaxLimit
								? this.elementRawConfig.LimitAnalysis.ColorLimitPointMax
								: dataPoint < this.elementRawConfig.LimitAnalysis.DataMinLimit
									? this.elementRawConfig.LimitAnalysis.ColorLimitPointMin
									: this.chartColors[colorIndex] // Default color if within limits
						};
					});
				}			
			});
		}
		else if (this.elementConfig.chartsConfig.categoryType.includes("Single")) {
						
			// Find the corresponding limitData by name		
			const colorIndex = this.elementNodes.findIndex(node => node === (chartSeries[0].name));			
			var chartSeriesI={};

			if (this.elementRawConfig.GeneralConfig.ChartType== "Gauge"||this.elementRawConfig.GeneralConfig.ChartType== "Solidgauge"){						
				chartSeriesI["data"] = chartSeries[0].data.map((dataPoint, index) => ({
					y:dataPoint,
					color: dataPoint > this.elementRawConfig.LimitAnalysis.DataMaxLimit
									? this.elementRawConfig.LimitAnalysis.ColorLimitPointMax
									: dataPoint < this.elementRawConfig.LimitAnalysis.DataMinLimit
										? this.elementRawConfig.LimitAnalysis.ColorLimitPointMin
										: this.chartColors[colorIndex], // Default color if within limits,
				}));
				
				if (this.elementRawConfig.GeneralConfig.ChartType== "Gauge"){
					const limitDialColor=chartSeriesI.data[0].color==this.chartColors[colorIndex] ? "#808080":chartSeriesI.data[0].color;
					chartSeriesI["dial"]= {
						backgroundColor: limitDialColor, // Custom color for the needle
						borderColor: limitDialColor // Border color for the needle
					}	
					chartSeries[0]["dial"]=chartSeriesI.dial;			
				}
			}
			else if	(this.elementRawConfig.GeneralConfig.ChartType== "Pie"||this.elementRawConfig.GeneralConfig.ChartType== "Pyramid")
			{
				chartSeriesI["data"] = chartSeries[0].data.map((dataPoint, index) => ({
						y:dataPoint.y,
						color: dataPoint.y > this.elementRawConfig.LimitAnalysis.DataMaxLimit
										? this.elementRawConfig.LimitAnalysis.ColorLimitPointMax
										: dataPoint.y < this.elementRawConfig.LimitAnalysis.DataMinLimit
										? this.elementRawConfig.LimitAnalysis.ColorLimitPointMin
										: this.chartColors[this.elementNodes.findIndex(node => node === (dataPoint.name))], // Default color if within limits,
						name: this.defineChartLabel(dataPoint.name)
				}));
			}
			
			chartSeries[0].data=chartSeriesI.data;			
		}	
	
		// Update this.elementDataRT.chartData.chartSeries
		this.elementDataRT.chartData.chartSeries = chartSeries;
	}
	
	// Process data for "Simple" type
	updateSimpleData() {
		// Check if the category type is "AllData-DateTime"
		if (this.elementConfig.chartsConfig.categoryType === "AllData-DateTime") {
			// Processing simple data
			console.log("---------Updating Simple Data-----------");
	
			// Get the series from the chart reference
			const chartSeries = this.chartReference.series;
			console.log("chartSeries");
			console.log(chartSeries);
			
			// Iterate through the updatingData to find the matching series by name
			this.elementDataRT.chartData.chartSeries.forEach(updatingSeries => {
			
				console.log("updatingSeries=======");
				console.log(updatingSeries);	
				// Find the corresponding series in the chart
				const chartSeriesItem = chartSeries.find(series => series.name === this.defineChartLabel(updatingSeries.name));
				const chartrange = this.chartTimeRange;
	
				if (chartSeriesItem) {
					console.log("chartSeriesItem before=======");
					console.log(chartSeriesItem);	
				
					if (this.limitAnalysisEnabled) {
						updatingSeries.data = [updatingSeries.data];
					}
	
					// Check if there are new data points to add
					if (updatingSeries.data.length > 0) {
						// Add new data points to the series
						updatingSeries.data.forEach(dataPoints => {
							// Ensure dataPoints is an array of points
							if (Array.isArray(dataPoints) && dataPoints.length > 0) {
								dataPoints.forEach(dataPoint => {
									console.log("Adding new points");
									console.log(dataPoint);
									chartSeriesItem.addPoint(dataPoint, false); // Set redraw to false
								});
							}
						});
						
						
						console.log("chartSeriesItem after==========");
						console.log(chartSeriesItem);
	
						// Calculate minTime after adding new points
						const dataLength = chartSeriesItem.data.length;
						if (dataLength > 1 && chartSeriesItem.data[dataLength - 1] != null) {
							const lastPointTime = chartSeriesItem.data[dataLength - 1].x;
							const minTime = lastPointTime - chartrange;
							
						console.log("chartSeries after==========");
						console.log(chartSeries);
							
							// Remove points outside the range from all series
							chartSeries.forEach(series => {
								console.log("(series.data[0]==========");
								console.log((series.data[0]));
								if (series.data[0].x!=null){
									while (series.data.length > 0 && (series.data[0].x < minTime)) {
										series.data[0].remove(false); // Set redraw to false
									}
								}							
							});
						}
					}
				}
			});
			
			// Redraw the chart after updates
			this.chartReference.redraw();
		}
	}
	
	// Process data for "Simple" type
	updateSimpleData1() {
		// Check if the category type is "AllData-DateTime"
		if (this.elementConfig.chartsConfig.categoryType === "AllData-DateTime") {
			// Processing simple data
			console.log("---------Updating Simple Data-----------");
	
			// Get the series from the chart reference
			const chartSeries = this.chartReference.series;
			console.log("chartSeries");
			console.log(chartSeries);
	
			// Iterate through the updatingData to find the matching series by name
			this.elementDataRT.chartData.chartSeries.forEach(updatingSeries => {
	
				console.log("updatingSeries=======");
				console.log(updatingSeries);
				// Find the corresponding series in the chart
				const chartSeriesItem = chartSeries.find(series => series.name === this.defineChartLabel(updatingSeries.name));
				const chartrange = this.chartTimeRange;
	
				if (chartSeriesItem) {
					console.log("chartSeriesItem before=======");
					console.log(chartSeriesItem);
	
					if (this.limitAnalysisEnabled) {
						updatingSeries.data = [updatingSeries.data];
					}
	
					// Check if there are new data points to add
					if (updatingSeries.data.length > 0) {
						// Add new data points to the series
						updatingSeries.data.forEach(dataPoints => {
							// Ensure dataPoints is an array of points
							if (Array.isArray(dataPoints) && dataPoints.length > 0) {
								dataPoints.forEach(dataPoint => {
									console.log("Adding new points");
									console.log(dataPoint);
									chartSeriesItem.addPoint(dataPoint, false); // Set redraw to false
								});
							}
						});
	
	
						console.log("chartSeriesItem after==========");
						console.log(chartSeriesItem);
	
						// Calculate minTime after adding new points
						const dataLength = chartSeriesItem.data.length;
						// Ensure there's at least one valid point to calculate range from
						let lastPointTime = null;
						for(let i = dataLength - 1; i >= 0; i--) {
							if (chartSeriesItem.data[i] && typeof chartSeriesItem.data[i].x === 'number') {
								lastPointTime = chartSeriesItem.data[i].x;
								break;
							}
						}
	
						if (lastPointTime !== null) {
							const minTime = lastPointTime - chartrange;
	
							console.log("chartSeries after==========");
							console.log(chartSeries);
	
							// Remove points outside the range from all series
							chartSeries.forEach(series => {
								// Loop while there are points AND the first point is either null or older than minTime
								while (series.data.length > 0) {
									const firstPoint = series.data[0];
									// Check if the first point is null OR if it exists and its timestamp is less than minTime
									if (firstPoint === null || (firstPoint && typeof firstPoint.x === 'number' && firstPoint.x < minTime)) {
										 // If it's null or too old, remove the point at index 0 using the series' method
										 series.removePoint(0, false); // removePoint(index, redraw)
									} else {
										// If the first point exists, has a valid timestamp, and is not too old, stop removing points for this series
										break;
									}
								}
							});
						}
					}
				}
			});
	
			// Redraw the chart after updates
			this.chartReference.redraw();
		}
	}
	
	// Process data for "FullRange Or SinglePoint" type
	updateFullRangeOrSinglePointData() {
		// Processing full range or single point data
		console.log("---------Updating Full Range or Single Point Data-----------");
		// Get the series from the chart reference
		const chartSeries = this.chartReference.series;
		
		//Pie and Pyramid Case
		if (this.isPiePyramid) {  //For Pie chart Data		
			
			// Update each data point in the pie chart based on the name
			const updatingData = this.elementDataRT.chartData.chartSeries[0].data;	
			const elementDataI=this.elementDataRT.chartData;
			
			//Special Categories for Singlepoint Processing
			if(this.elementRawConfig.DataProcessing.DataProcessingEnabled&&(this.elementRawConfig.DataProcessing.ProcessingType.includes("SinglePoint"))){
				
				let updatedCategories=this.chartReference.xAxis[0].categories.map((category, index) => {

					const foundIndex = elementDataI.chartSeries[0].data.findIndex(dataPoint => this.defineChartLabel(dataPoint.name) === category.name);;
					const foundcategory =elementDataI.chartCategories[foundIndex];
		
					//Updated category
					if(foundcategory!=undefined){
						return ({
							name:this.defineChartLabel(category.name),
							x:foundcategory
						})				
					}
					//Keep the same category
					else{
						return category;
					}
					
				});
				
				this.chartReference.xAxis[0].setCategories(updatedCategories, false);
			}
			
			//Updating points
			updatingData.forEach(updatingPoint => {
				const dataPoint = chartSeries[0].data.find(point => point.name === this.defineChartLabel(updatingPoint.name));
				if (dataPoint) {							
					if (this.limitAnalysisEnabled){
						dataPoint.update(updatingPoint, false); // Update the data point, no redraw yet
					}
					else{										
						dataPoint.update(updatingPoint.y, false); // Update the data point, no redraw yet
					}								
				}
			});
		}
		
		//Any other case
		else{		
			// Iterate through the updatingData to find the matching series by name
			this.elementDataRT.chartData.chartSeries.forEach(updatingSeries => {

				// Find the corresponding series in the chart
				const chartSeriesItem = chartSeries.find(series => series.name === this.defineChartLabel(updatingSeries.name));
				
				if (chartSeriesItem) {
					// Check if there is a new data point to add
					if (updatingSeries.data.length > 0) {
						// Update the series with the new data point
						const newValue = updatingSeries.data[0];
						const lastPoint = chartSeriesItem.data[chartSeriesItem.data.length - 1];
						// Update the last point with the new value or add the point if the series is empty
						if (lastPoint) {
							lastPoint.update(newValue, false); // Update last point, no redraw		
												
							if(this.elementRawConfig.GeneralConfig.ChartType== "Gauge" &&this.limitAnalysisEnabled){
								chartSeriesItem.update({
										dial:updatingSeries.dial
								});
							} 
						} 						
					}
				}
			});
			
			//Update categories
			let updatedCategories=this.elementDataRT.chartData.chartCategories;
			this.chartReference.xAxis[0].setCategories(updatedCategories, false);

			//Update Tooltip
			
		}
	
		// Redraw the chart after updates
		this.chartReference.redraw();
	}
	
	// Process data for "Interval" type
    updateIntervalData() {
		console.log("---------Processing Interval Data-----------");
	
		const elementDataI = this.elementDataRT.chartData;
		const intervalInfo = elementDataI.informationRT;
	
		// Check if it is necessary to go to a new interval
		const newInterval = intervalInfo.some(info => info.IntervalInfo.newInterval);
	
		// If the chart type is Histogram
		if (this.elementRawConfig.GeneralConfig.ChartType === "Histogram") {
			console.log("---------Processing Histogram Data-----------");
	
			// Get existing categories from the xAxis
			const existingCategories = this.chartReference.xAxis[0].categories;
			const newCategories = elementDataI.chartCategories;
	
			 // Merge existing and new categories, ensuring they are in the correct order
			newCategories.forEach((category) => {
				if (!existingCategories.includes(category)) {
					existingCategories.push(category);
				}
			});
	
			// Sort the categories
			existingCategories.sort((a, b) => {
				const aStart = parseFloat(a.split('-')[0]);
				const bStart = parseFloat(b.split('-')[0]);
				return aStart - bStart;
			});
			
			// Update the xAxis with the new categories
			this.chartReference.xAxis[0].setCategories(existingCategories, false);
	
			// Update series data
			elementDataI.chartSeries.forEach(updatingSeries => {
				// Find the corresponding series in the chart by name
				const chartSeriesItem = this.chartReference.series.find(series => series.name === this.defineChartLabel(updatingSeries.name));
				if (chartSeriesItem) {
				
					// Check and update each data point in the series
					updatingSeries.data.forEach((dataPoint, index) => {
						if (chartSeriesItem.data[index] && chartSeriesItem.data[index].y !== dataPoint) {
							chartSeriesItem.data[index].update(dataPoint, false);
						} else if (!chartSeriesItem.data[index]) {
							chartSeriesItem.addPoint(dataPoint, false);
						}
					});
				}
			});
			
			// Redraw the chart after updates
			this.chartReference.redraw(true);
		}
		
		//NON-Histogram charts
		 else {		
	
			// Update series data
			elementDataI.chartSeries.forEach(updatingSeries => {
				// Find the corresponding series in the chart by name
				const chartSeriesItem = this.chartReference.series.find(series => series.name === this.defineChartLabel(updatingSeries.name));
				if (chartSeriesItem) {
					const newValue = updatingSeries.data[0];
	
					if (newInterval) {
						// Add new data point and remove the first point						
						chartSeriesItem.addPoint(newValue, false);
						if (chartSeriesItem.data.length > 1) {
							chartSeriesItem.data[0].remove(false); // Remove the first point
						}
					} else {
						// Update the last point with the new value
						const lastPoint = chartSeriesItem.data[chartSeriesItem.data.length - 1];
						lastPoint.update(newValue, false);
					}
				}
			});
	
			if (newInterval) {
				// Add missing series with a value of 0
				this.chartReference.series.forEach(chartSeriesItem => {
					const isSeriesPresent = elementDataI.chartSeries.some(updatingSeries => this.defineChartLabel(updatingSeries.name) === chartSeriesItem.name);
					if (!isSeriesPresent) {
						chartSeriesItem.addPoint(0, false);
						if (chartSeriesItem.data.length > 1) {
							chartSeriesItem.data[0].remove(false); // Remove the first point
						}
					}
				});
			}
	
			// Update categories
			const xAxis = this.chartReference.xAxis[0];
			let updatedCategories;
	
			if (newInterval) {
				// Remove the first category and add the new one using elementDataI.chartCategories[0]
				xAxis.categories.push(elementDataI.chartCategories[0]);
				updatedCategories = xAxis.categories;
				this.chartReference.redraw(true); // Enable animation on redraw    
			} else {
				// Update the last category with the new one
				updatedCategories = xAxis.categories;
				updatedCategories[updatedCategories.length - 1] = elementDataI.chartCategories[0];
				this.chartReference.redraw(false); // Disable animation on redraw
			}
		}
	}
	
	//-----------------------------------------------//
	//----------For Single Chart Requests-----------//	
	
	// Single Chart Request
	async singleDataRequestCreator() {
	
		// Final Time
		const Final_Time = new Date();
	
		// Initial Time
		let Initial_Time = new Date(Final_Time); // Clone Final_Time
	
		switch (this.elementRawConfig.GeneralConfig.InitialRangeUnit) {
			case 's': // Seconds
				Initial_Time.setSeconds(Final_Time.getSeconds() - this.elementRawConfig.GeneralConfig.InitialRange);
			break;
			case 'min': // Minutes
				Initial_Time.setMinutes(Final_Time.getMinutes() - this.elementRawConfig.GeneralConfig.InitialRange);
			break;
			case 'h': // Hours
				Initial_Time.setHours(Final_Time.getHours() - this.elementRawConfig.GeneralConfig.InitialRange);
			break;
			case 'day': // Days
				Initial_Time.setDate(Final_Time.getDate() - this.elementRawConfig.GeneralConfig.InitialRange);
				break;
			case 'month': // Months
				Initial_Time.setMonth(Final_Time.getMonth() - this.elementRawConfig.GeneralConfig.InitialRange);
				break;
			default:
			console.error('Unsupported InitialRangeUnit:', this.elementRawConfig.GeneralConfig.InitialRangeUnit);
			break;
		}
	
		// SingledataRequest completed
		const singledataRequest = {
		  chartsNodes: [{
			chartID: this.chartID,
			chartNodes: this.elementConfig.chartNodes
		  }],
		  chartsConfig: [{
			elementType: this.elementConfig.chartsConfig.elementType,
			chartID: this.chartID,
			chartType: this.elementConfig.chartsConfig.chartType,
			dataType: this.elementConfig.chartsConfig.dataType,
			dataProcessingType: this.elementConfig.chartsConfig.dataProcessingType,
			dataPrTUnit:this.elementRawConfig.DataProcessing.DataProcessingTimeInputUnit,
			dataReductionEnable: this.elementConfig.chartsConfig.dataReductionEnable,
			dataReductionMaxSize: this.elementConfig.chartsConfig.dataReductionMaxSize,
			dataoutOfLimitEnable: this.elementConfig.chartsConfig.dataoutOfLimitEnable,
			dataMaxLimit: this.elementConfig.chartsConfig.dataMaxLimit,
			dataMinLimit: this.elementConfig.chartsConfig.dataMinLimit,
			categoryType: this.elementConfig.chartsConfig.categoryType,
			categoryRound: this.elementConfig.chartsConfig.categoryRound,
			categorCustomValue: this.elementConfig.chartsConfig.categorCustomValue,
			categoryCustomIntervalLength: this.elementConfig.chartsConfig.categoryCustomIntervalLength,
			categoryCustomIntervalUnit: this.elementConfig.chartsConfig.categoryCustomIntervalUnit,
			categoryTimeOffset:this.elementConfig.chartsConfig.categoryTimeOffset,
			singleDataRequest: true,
			specialParameters:this.specialParameters
		  }],
		  updateRequest: [{
			OperationMode: "Hist",
			initialTime: Initial_Time,
			finalTime: Final_Time,
			customFilterType: "",
			cacheConfig:{
				CacheEnabled:"false",
				CacheIntervalSize:0,
				CacheMaxSize:0},
			chartID: this.chartID
		  }]
		};
	
		return singledataRequest;
	}	
	
	//Single Data Calling
	async singleelementDataCreator() {
		return new Promise((resolve, reject) => {			
			//Custom Request
			webMI.data.customRequest("GET", "Advanced_Dashboard_Data_Creator?DataRequest="+JSON.stringify(this.singleDataRequest)+"&format=binary", "responseType=string", function(e){
				try {  
					console.log("----------Single Request Answered--------");
					
					//Read dashboardData
					let dashboardData=e;
					
					//Check if its valid
					if (!dashboardData || !dashboardData.chartsData || !Array.isArray(dashboardData.chartsData) || dashboardData.chartsData.length === 0) {
						throw new Error("Invalid or empty chartsData array");
					}
				
					//Adapt Structure to single Element Data
					const elementDataI = {
						chartData: {
							chartID: dashboardData.chartsData[0].chartID,
							chartSeries: dashboardData.chartsData[0].chartSeries,
							chartCategories: dashboardData.chartsData[0].chartCategories
						},
						Errors: dashboardData.Errors
					};
					resolve (elementDataI);
				} 
				catch (error) {
					console.log("Error found with custom request")
					console.log(error);
				}
			});
		});
	}
	
	//-----------------------------------------------//
	//-------------Auxiliary Functions--------------//
	
	 // Creates Chart Colors
    createChartColors() {
    		
        // Ensure Highcharts.color method is available for color manipulation
        if (typeof Highcharts === 'undefined' || typeof Highcharts.color !== 'function') {
            throw new Error("Highcharts library or Highcharts.color method is not available.");
        }

		//Color case for SolidGauge in particular
		if (this.elementRawConfig.GeneralConfig.ChartType== "Solidgauge" ){

			this.elementRawConfig.Appearance.ColorSeriesPalette= this.elementRawConfig.Appearance.ColorSeriesPalette == "" ? "#81C6FF" :this.elementRawConfig.Appearance.ColorSeriesPalette;

		}
		const baseColor = this.elementRawConfig.Appearance.ColorSeriesPalette;
        const dataLength = this.isPiePyramid ? this.elementData.chartData.chartSeries[0].data.length : this.elementData.chartData.chartSeries.length;
        const colors = [];        
        
        //Color from Color Pallete
        if ( this.elementRawConfig.Appearance.ColorSeriesType=="Color-Pallete") {
			for (let i = 0; i < dataLength; i++) {
				// Calculate color variation
				const variation = 0.4 * i;
				const newColor = Highcharts.color(baseColor).brighten(variation).get();
				colors.push(newColor);
			}        
        }
        
        
        else if( this.elementRawConfig.Appearance.ColorSeriesType=="Color-Custom") {
        
			// Data Source Text
			if (this.elementRawConfig.GeneralConfig.SeriesSource === "Text") {		
				//Take source from parameters
				this.elementRawConfig.Series.forEach(function(seriesItem) {
					if (seriesItem.SeriesNode) { // Check if SeriesNode is not undefined
						colors.push(seriesItem.SeriesColor);
					}
				});
			}
			
			// Data Source Enum
			else if (this.elementRawConfig.GeneralConfig.SeriesSource === "EnumList") {
				for (const key in this.elementRawConfig.EnumList.EnumList) {
					if (this.elementRawConfig.EnumList.EnumList.hasOwnProperty(key)) {
						const enumItem = this.elementRawConfig.EnumList.EnumList[key];
						if (enumItem.Color) { // Check if Node is not undefined
							colors.push(enumItem.Color);
						}
					}
				}
			}
        
        }
        return colors;
    }
    
    defineBackgroundColor(){
		//If transparen Enabled
		if (this.elementRawConfig.Appearance.ColorBackgroundTranspartentEnable=="true"||this.elementRawConfig.Appearance.ColorBackground.length<=0){
			return 'transparent';
	    }
	    else{
			return this.elementRawConfig.Appearance.ColorBackground;
	    }
    
    }
    
    defineChartLabel(SeriesName) {

		//Series name comming from Dashboard Data Creator
		if (SeriesName.endsWith(this.limitKey)) { //Series for Limits

			const index_Limit = this.elementNodes.findIndex(node => {
				return node === SeriesName.slice(0, SeriesName.length-this.limitKey.length);
			}); 

			// Return the corresponding label from this.chartLabels or the SeriesName if the label is empty
			if (index_Limit !== -1) {

				const label = this.chartLabels[index_Limit] !== '' ? this.chartLabels[index_Limit]+this.limitKey: '';
				return label !== '' ? label : SeriesName.split('.').pop();
			} else {
				return SeriesName; // return SeriesName if index is not found
			}
			
		}
		
		else {
		
			console.log("Excecuting chart label logic");
			// Find the index of the element in this.elementNodes where SeriesName is the last part
			const index = this.elementNodes.findIndex(node => {
				return node === SeriesName;
			});			
			// Return the corresponding label from this.chartLabels or the SeriesName if the label is empty
			if (index !== -1) {
				const label = this.chartLabels[index];
				return label !== '' ? label : SeriesName.split('.').pop();
			} else {
				return SeriesName; // return SeriesName if index is not found
			}
        }
    }
	
	dataLabelFormatter(rawLabel) {

		const labelType = this.elementRawConfig.Appearance.DatalabelType;
		const customFormat = this.elementRawConfig.Appearance.DatalabelCustomTimeFormat;
		const numberDecimals = this.elementRawConfig.Appearance.DatalabelNumberDecimals;
		const DatalabelUnit = this.elementRawConfig.Appearance.DatalabelUnit;


		if (labelType === "Value-Simple") {
			// Number formatting logic when handling 'Value'
			if (rawLabel >= 1000000) {
				return (rawLabel / 1000000).toFixed(numberDecimals) + 'M '+ DatalabelUnit; // millions
			} else if (rawLabel >= 1000) {
				return (rawLabel / 1000).toFixed(numberDecimals) + 'k '+DatalabelUnit; // thousands
			} else {
				return rawLabel.toFixed(numberDecimals)+DatalabelUnit; // less than 1000
			}
		} 
		else if (labelType === "Time-Dynamic") {
			let time = rawLabel;
	
			if (time <= 3600000) {
				const minutes = Math.floor(time / 60000);
				const seconds = Math.floor((time % 60000) / 1000);
				return `${minutes} m ${seconds} s`;
			} else if (time < 86400000) {
				const hours = Math.floor(time / 3600000);
				const minutes = Math.floor((time % 3600000) / 60000);
				return `${hours} h ${minutes} m`;
			} else if (time < 2592000000) {
				const days = Math.floor(time / 86400000);
				const hours = Math.floor((time % 86400000) / 3600000);
				return `${days} days ${hours} h`;
			} else {
				const months = Math.floor(time / 2592000000);
				const days = Math.floor((time % 2592000000) / 86400000);
				return `${months} M ${days} d`;
			}
		} 
		else if (labelType === "Time-Custom") {
			let time = rawLabel;
		
			// Extract components for all time hierarchies
			let years = Math.floor(time / 31536000000); // Total milliseconds in a year
			time %= 31536000000;
		
			let months = Math.floor(time / 2592000000); // Total milliseconds in a month
			time %= 2592000000;
		
			let days = Math.floor(time / 86400000); // Total milliseconds in a day
			time %= 86400000;
		
			let hours = Math.floor(time / 3600000); // Total milliseconds in an hour
			time %= 3600000;
		
			let minutes = Math.floor(time / 60000); // Total minutes (including hours)
			let seconds = Math.floor((time % 60000) / 1000); // Remaining seconds
		
			// Determine the highest hierarchy present in the custom format
			const hierarchy = ['YYYY', 'MM', 'DD', 'hh', 'mm', 'ss'];
			const presentHierarchy = hierarchy.filter(unit => customFormat.includes(unit));
			
			console.log("presentHierarchy: "+presentHierarchy);
			
			
			if (presentHierarchy.length > 0) {
				const highestHierarchy = presentHierarchy[0];
		
				// Convert higher units to the highest present unit
				switch (highestHierarchy) {
					case 'YYYY':
						// No higher unit to convert
						break;
					case 'MM':
						months = years * 12 + months; // Convert years to months;
						break;
					case 'DD':
						days = years * 365 + months * 30 + days;
						break;
					case 'hh':
						hours = (years * 365 + months * 30 + days) * 24 + hours; // Convert years, months, days to hours
						break;
					case 'mm':
						minutes = ((years * 365 + months * 30 + days) * 24 + hours) * 60 + minutes; // Convert everything to minutes
						break;
					case 'ss':
						seconds = (((years * 365 + months * 30 + days) * 24 + hours) * 60 + minutes) * 60 + seconds; // Convert everything to seconds;
						break;
				}
		
				// Now, for the second highest hierarchy, if it exists, we convert the higher values into that unit as well
				for (let i = 1; i < presentHierarchy.length; i++) {
					const currentHierarchy = presentHierarchy[i];
					const previousHierarchy = presentHierarchy[i - 1];
		
					switch (currentHierarchy) {
						case 'DD':
							if (previousHierarchy === 'YYYY') {
								days += months * 30; // Convert years to days if YYYY is missing but DD is present
							}
							break;
						case 'hh':

							if (previousHierarchy === 'MM') {
								hours += (days * 24); // Convert months to hours if MM is missing but hh is present
							}
							if (previousHierarchy === 'YYYY') {
								hours += (days* 24)+(months* 30 * 24); // Convert years to hours if YYYY is missing but hh is present
							}
							break;
						case 'mm':
							if (previousHierarchy === 'DD') {
								minutes += (hours * 60); // Convert days to minutes if DD is missing but mm is present
							}
							if (previousHierarchy === 'MM') {
								minutes += (hours * 60) + (days* 24 * 60); // Convert months to minutes if MM is missing but mm is present
							}
							if (previousHierarchy === 'YYYY') {
								minutes += (hours * 60) + (days* 24 * 60)+(months* 30 * 24 * 60); // Convert years to minutes if YYYY is missing but mm is present
								years = 0;
							}
							break;
						case 'ss':
							if (previousHierarchy === 'hh') {
								seconds += minutes * 60; // Convert hours to seconds if hh is missing but ss is present
							}
							if (previousHierarchy === 'DD') {
								seconds += (minutes * 60) + (hours* 60 * 60); // Convert days to seconds if DD is missing but ss is present
							}
							if (previousHierarchy === 'MM') {
								seconds += (minutes * 60) + (hours* 60 * 60) + (days* 24 * 60 * 60); // Convert months to seconds if MM is missing but ss is present
							}
							if (previousHierarchy === 'YYYY') {
								seconds += (minutes * 60) + (hours* 60 * 60) + (days* 24 * 60 * 60)+(months* 30 * 24 * 60 * 60); // Convert years to seconds if YYYY is missing but ss is present
							}
							break;
					}
				}
				let formattedTime = customFormat;
				
				// Format the custom string with the remaining values
				formattedTime = customFormat.replace('YYYY', years.toString().padStart(4, '0'));
				formattedTime = formattedTime.replace('MM', months.toString().padStart(2, '0'));
				formattedTime = formattedTime.replace('DD', days.toString().padStart(2, '0'));
				formattedTime = formattedTime.replace('hh', hours.toString().padStart(2, '0'));
				formattedTime = formattedTime.replace('mm', minutes.toString().padStart(2, '0'));
				formattedTime = formattedTime.replace('ss', seconds.toString().padStart(2, '0'));
		
				return formattedTime;
			} 
		}	
		 else {
			return rawLabel; // Default case: return raw label without formatting
		}	
	} 
	
	extractTimeIntervals(data) {
		const result = [];
		
		for (let key in data) {
			if (data.hasOwnProperty(key)) {
				const initialTime = data[key]["1_Initial_Time"];
				const finalTime = data[key]["2_Final_Time"];
				result.push([initialTime, finalTime]);
			}
		}
		
		return result;
	}
	
	async applyFormula(chartSeries) {
		const formulaConfig = this.elementRawConfig.FormulaFX;
	
		// --- 1. Check Prerequisites ---
		if (!formulaConfig.FormulaEnabled) {
			console.log("Formula is disabled.");
			return chartSeries; // Return original data if formula is not enabled
		}
		if (!formulaConfig.FormulaDescription || typeof formulaConfig.FormulaDescription !== 'string' || formulaConfig.FormulaDescription.trim() === '') {
			console.warn("Formula is enabled but description is missing or invalid. Skipping formula application.");
			return chartSeries; // Return original data if description is invalid
		}
		 if (!Array.isArray(chartSeries)) {
			console.warn("applyFormula received invalid chartSeries input. Skipping.");
			return chartSeries; // Return original if input is bad
		}
	
		console.log("Applying formula:", formulaConfig.FormulaDescription);
	
		// --- 2. Prepare for Asynchronous Node Reading ---
		return new Promise((resolve, reject) => {
			const paramConfigs = {}; // To store type, value, node for A-E
			const nodesToRead = []; // List of node addresses to read
			const nodeToParamMap = {}; // Map node address back to param letter { "AGENT...": "A", ... }
	
			// --- 3. Identify Parameter Types and Collect Nodes ---
			for (const p of ['A', 'B', 'C', 'D', 'E']) {
				const config = {
					type: formulaConfig[`${p}ParameterType`],
					valueStr: formulaConfig[`${p}ParameterValue`], // Keep as string initially
					node: formulaConfig[`${p}ParameterNode`]
				};
				paramConfigs[p] = config;
	
				if (config.type === 'Node' && config.node && typeof config.node === 'string' && config.node.trim() !== '') {
					const nodeAddr = config.node.trim();
					if (!nodesToRead.includes(nodeAddr)) {
						nodesToRead.push(nodeAddr);
					}
					nodeToParamMap[nodeAddr] = p; // Map node address to parameter letter
				}
			}
	
			console.log("Nodes to read for formula parameters:", nodesToRead);
	
			// --- 4. Define Function to Process Data (Core Logic) ---
			// This function will be called after node values are potentially read.
			const processDataWithParams = (resolvedParamValues) => {
				console.log("Final formula parameters:", resolvedParamValues);
				try {
					// --- 4a. Deep copy the chartSeries to avoid modifying the original ---
					// Using JSON parse/stringify for a simple deep copy suitable for this structure
					const modifiedChartSeries = JSON.parse(JSON.stringify(chartSeries));
	
					// --- 4b. Prepare the formula executor function ---
					// Using Function constructor is slightly safer than direct eval
					// User writes formula using X, A, B, C, D, E
					 const formulaBody = `
						try {
							// Math functions should be available (e.g., Math.cos, Math.sqrt)
							return ${formulaConfig.FormulaDescription};
						} catch (e) {
							// Log error and return original value to avoid breaking chart
							console.error('Error executing formula for value ' + X + ':', e, ' Formula:', '${formulaConfig.FormulaDescription.replace(/'/g, "\\'")}');
							return X; // Return original value on execution error
						}
					`;
					let formulaExecutor;
					 try {
						formulaExecutor = new Function('X', 'A', 'B', 'C', 'D', 'E', formulaBody);
					 } catch (syntaxError) {
						 console.error("Syntax error in formula description:", syntaxError, "Formula:", formulaConfig.FormulaDescription);
						 reject(new Error(`Syntax error in formula: ${formulaConfig.FormulaDescription}`)); // Reject Promise on syntax error
						 return; // Stop execution
					 }
	
	
					// --- 4c. Iterate through series and data points to apply the formula ---
					modifiedChartSeries.forEach(series => {
						// Skip potentially added limit series or series without data
						if (!series || series.custom === this.limitKey || !Array.isArray(series.data)) {
							return;
						}
	
						series.data = series.data.map(point => {
							let originalValue = NaN;
							let canApply = false;
	
							// Handle different point formats
							if (point === null) {
								 return null; // Keep nulls as nulls
							} else if (typeof point === 'number') {
								originalValue = point;
								canApply = true;
							} else if (typeof point === 'object' && point !== null && typeof point.y === 'number') {
								originalValue = point.y;
								 canApply = true;
							} else if (Array.isArray(point) && point.length >= 2 && typeof point[1] === 'number') {
								originalValue = point[1]; // Assuming [timestamp, value]
								 canApply = true;
							}
	
							// Apply formula if we extracted a valid number
							if (canApply && !isNaN(originalValue)) {
								const newValue = formulaExecutor(
									originalValue,
									resolvedParamValues.A,
									resolvedParamValues.B,
									resolvedParamValues.C,
									resolvedParamValues.D,
									resolvedParamValues.E
								);
	
								// Check if the result is a valid number before updating
								if (typeof newValue === 'number' && !isNaN(newValue)) {
									// Update the point based on its original format
									if (typeof point === 'number') {
										return newValue;
									} else if (typeof point === 'object' && point !== null) {
										point.y = newValue;
										return point;
									} else if (Array.isArray(point)) {
										point[1] = newValue;
										return point;
									}
								} else {
									console.warn(`Formula result is NaN or not a number for X=${originalValue}. Keeping original value.`);
									return point; // Keep original point if formula result is invalid
								}
							} else {
								// If point format is unknown or original value isn't a number, keep it as is
								return point;
							}
						});
					});
	
					console.log("Formula application complete.");
					resolve(modifiedChartSeries); // Resolve the promise with the modified data
	
				} catch (processingError) {
					console.error("Error during formula data processing:", processingError);
					reject(processingError); // Reject if processing fails catastrophically
				}
			};
	
			// --- 5. Get Parameter Values (Fixed + Async Node Read) ---
			const finalParamValues = {};
	
			// --- 5a. Assign Fixed values first, respecting the default '1' rule ---
			for (const p of ['A', 'B', 'C', 'D', 'E']) {
				if (paramConfigs[p].type === 'Fixed') {
					let val = parseFloat(paramConfigs[p].valueStr);
					// Default to 1 if string is empty or parsing results in NaN
					finalParamValues[p] = (paramConfigs[p].valueStr === null || paramConfigs[p].valueStr.trim() === '' || isNaN(val)) ? 1 : val;
				} else {
					 // Default Node values to 0 for now, will be overwritten if read succeeds
					 finalParamValues[p] = 0;
				}
			}
	
			// --- 5b. Read Node values if needed ---
            if (nodesToRead.length === 0) {
                // No nodes to read, process data directly with fixed/default values
                console.log("No nodes required for formula, proceeding directly.");
                processDataWithParams(finalParamValues);
            } else {
                console.log("Reading nodes for formula:", nodesToRead);
                webMI.data.read(nodesToRead, (results) => {
                    console.log("Node read results:", results);
                    const nodeValueMap = {}; // Store values keyed by address
                    const readResultsArray = Array.isArray(results) ? results : (results ? [results] : []); // Handle null/undefined results too

                    // Iterate through the nodes we *requested* to ensure correct mapping
                    nodesToRead.forEach((requestedNodeAddr, index) => {
                        let foundResult = null;

                        if (nodesToRead.length === 1 && readResultsArray.length === 1) {
                            // If only one node requested, the result is the first (and only) item
                            // regardless of whether it has an 'address' property
                            foundResult = readResultsArray[0];
                        } else {
                            // If multiple nodes requested, find the result by matching address
                            foundResult = readResultsArray.find(res => res && res.address === requestedNodeAddr);
                        }

                        // Process the found result (or handle if not found)
                        if (foundResult) {
                            if (foundResult.status === 0 && typeof foundResult.value === 'number' && !isNaN(foundResult.value)) {
                                nodeValueMap[requestedNodeAddr] = foundResult.value;
                            } else {
                                console.warn(`Failed to read or invalid value for node ${requestedNodeAddr}. Status: ${foundResult.status}, Value: ${foundResult.value}. Using 0.`);
                                nodeValueMap[requestedNodeAddr] = 0; // Default on error/bad value
                            }
                        } else {
                            // No result found for this requested node
                            console.warn(`No result returned for requested node ${requestedNodeAddr}. Using 0.`);
                            nodeValueMap[requestedNodeAddr] = 0; // Default if result is missing
                        }
                    });

                    // Fill in the finalParamValues with read node values using nodeToParamMap
                    for (const nodeAddr in nodeToParamMap) {
                        const paramLetter = nodeToParamMap[nodeAddr];
                        // Check if the value exists in our correctly mapped nodeValueMap
                        if (nodeValueMap.hasOwnProperty(nodeAddr)) {
                            finalParamValues[paramLetter] = nodeValueMap[nodeAddr];
                        }
                        // If nodeAddr wasn't in map (read failed badly or wasn't requested?), it keeps the default 0 assigned earlier
                    }

                    // --- 5c. Now that all params are resolved, process the data ---
                    processDataWithParams(finalParamValues);
                });
            }
			
		});
	}	
	
}

]]></script>
</svg>
