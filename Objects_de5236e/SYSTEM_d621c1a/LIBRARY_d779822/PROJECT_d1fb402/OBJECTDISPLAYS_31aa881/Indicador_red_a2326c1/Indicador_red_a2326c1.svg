<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<svg height="300" version="1.2" width="400" xmlns="http://www.w3.org/2000/svg" xmlns:atv="http://webmi.atvise.com/2007/svgext" xmlns:xlink="http://www.w3.org/1999/xlink">
 <defs/>
 <metadata>
  <atv:gridconfig enabled="true" gridstyle="lines" height="20" width="20"/>
  <atv:snapconfig enabled="true" height="10" width="10"/>
 </metadata>
 <rect atv:refpx="200" atv:refpy="150" fill="none" height="300" id="border" stroke="#000000" stroke-width="2" width="400" x="0" y="0"/>
 <text atv:refpx="190" atv:refpy="150" fill="none" font-family="Arial" font-size="16" id="label" x="152" y="154.5">Indicador Red</text>
 <foreignObject height="300" id="id_2" width="400" x="0" y="0">
  <div style="width:100%;height:100%" xmlns="http://www.w3.org/1999/xhtml">
   <div id="Indicador" style="width: 100%; height: 100%;"/>
  </div>
 </foreignObject>
 <script atv:desc="" atv:name="" type="text/ecmascript"><![CDATA[

//Internal Variables
var address="AGENT.OBJECTS.SCADA";
var ip_Array;
var Web_Segment="168.248";

//Reference HTML elements
const elementdiv=document.getElementById('Indicador');


//Initial conditions
webMI.addOnload(function() {
	
	//Hide Development aids
	webMI.gfx.setVisible("label", false);
	webMI.gfx.setVisible("border", false);

	ip_Array=groupByWebSegment(address,Web_Segment);
	

});


//------------------Functions-------------------//


//-----------------------Functions
function groupByWebSegment(address,Web_Segment) {

	webMI.data.call("Variables_Parser", {address:address,Web_Segment:Web_Segment}, function(e) {

		var result=e;	
		
		const segmentMap = new Map();
	
		result.forEach(item => {
			// Assuming there's only one key per object
			const key = Object.keys(item)[0];
			const ip = item[key];
			let segment;
	
			// Special handling for IPs starting with '10.'
			if (ip.startsWith("10.")) {
				segment = ip.split('.').slice(0, 2).join('.');
			} else if (ip.match(/^\d+\.\d+\.\d+\.\d+$/)) {
				// For other IPs, extract the first three elements
				segment = ip.split('.').slice(0, 3).join('.');
			} else {
				// Use the entire IP as segment if it's not in expected format
				segment = ip;
			}
	
			// Remove the last element from the key
			const modifiedKey = key.split('.').slice(0, -1).join('.');
	
			// Group keys by segment
			if (!segmentMap.has(segment)) {
				segmentMap.set(segment, []);
			}
			segmentMap.get(segment).push(modifiedKey);
		});
	
		// Convert the Map into the required array format
		return Array.from(segmentMap, ([segment, keys]) => ({ [segment]: keys }));
    });
}
]]></script>
</svg>
