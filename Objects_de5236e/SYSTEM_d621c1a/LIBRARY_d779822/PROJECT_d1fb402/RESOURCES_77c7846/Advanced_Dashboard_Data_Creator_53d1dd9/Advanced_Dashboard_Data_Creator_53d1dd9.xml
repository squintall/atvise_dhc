<?xml version="1.0" encoding="UTF-8"?>
<script>
  <metadata>
    <priority>0</priority>
    <owner>root</owner>
    <runcontext>caller</runcontext>
  </metadata>
  <parameter name="Parameters" type="http" trigger="false" relative="false" value=""/>
  <code><![CDATA[//-------------------------------------------------------------// 
//-------------------Dashboard Data Creator-------------------//
/*   The Dashboard Data creator takes instructions called 
	 Data Request and returns Dashboard Data.
	 
	 This is en example of the Data Request Format 
	 
	 chartsNodes: [{chartID: 0,
				   chartNodes: ["AGENT.OBJECTS.Simulacion.Counter.Line_Counter_1",
							   "AGENT.OBJECTS.Simulacion.Counter.Line_Counter_2"]
				  },
				  {chartID: 1,
				   chartNodes: ["AGENT.OBJECTS.Simulacion.Counter.Line_Counter_1"]
				  }],
    chartsConfig: [
					{chartID: 0,
					 chartType: "Pie",
					 dataProcessingType: "SimpleAddition",
					 dataReductionEnable: true,
					 dataReductionMaxSize: 1000,
					 dataoutOfLimitEnable: false,
					 dataMaxLimit:"",
					 dataMinLimit:"",
					 categoryType: "AllData-DateTime",
					 categorCustomValue: "",
					 specialParameters: ""
					},
					{chartID: 1,
					 chartType: "Line",
					 dataProcessingType: "Integration",
					 dataReductionEnable: true,
					 dataReductionMaxSize: 1000,
					 dataoutOfLimitEnable: false,
					 dataMaxLimit:"",
					 dataMinLimit:"",
					 categoryType: "Interval-Dynamic",
					 categoryRound: "true",
					 categorCustomValue: "",
					 categoryCustomIntervalLength: 1
					 categoryCustomIntervalUnit: "h"
					 categoryTimeOffset: "30"
					 specialParameters: ""
					},
				], 
	updateRequest: { 
					OperationMode: "Hist",
					initialTime: Initial_Time,
					finalTime: Final_Time,
					customFilterType: "",
					cacheConfig:{					
						CacheEnabled:true
						CacheIntervalSize:0
						CacheMaxSize:0
						}
				   }
}
	 
*/



//Variables Declaration

console.log("-----------------Excecuting--------------");
console.log("---------------------------------------------");
console.log("---------------------------------------------");
console.log("---------------------------------------------");


var ParametersI= Parameters.request.getvalues;
var dataRequest=Parameters.request.getvalues["DataRequest"].replace(/'/g, '"');

//Time Constants
const ONE_MINUTE = 60 * 1000;
const HALF_HOUR = 30 * ONE_MINUTE;
const ONE_HOUR = 60 * ONE_MINUTE;
const ONE_DAY = 24 * ONE_HOUR;



//---------------Dashboard Data Processor----------------//
//-----------------------------------------------------//
class dashboardDataProcessor {
	
	//Attributes
	processedData;
	dynamicCategory;
	
	constructor(dashboardCreatorNotifier) {
		this.processedData = null; // Initialize processedData 
		this.dataRequest;
		this.rawData;
		this.timeRange;
		this.OperationMode;
		this.intervalLength;
		this.uniqueCategoriesConfig=[]; // Initialize unique Config
		this.uniqueCategoriesConfigRT=[];
		this.uniqueCategories=[]; // Initialize unique Categories complete
		this.LimitInfo = [];
		this.LimitInfoRT = [];
		this.uniqueCategoriesRT=[];
		this.DCNotfier;
		
		//For each Element Config
		this.uniqueCategoriesConfigI;
		this.intervalLengthI;
		this.processedDataI;
		this.chartConfigI;
		this.updateRequestI;
		this.chartNodesI;
		this.chartCategoriesI=[];
		this.categoryTimeOffsetI;
		this.rawDataI;
		this.nodeI;
		this.indexNodeI;
		this.reductionExcecutedI=false;
		this.partialDashboardDataI;
		this.LimitDashboardDataI;
		this.TooltipDashboardDataI;
		this.DataInfoRTIClient;
		
		this.DataInfoRTIServer;
		
		this.informationRTI;
		this.reductionStepSizeI=0;
		this.reductionreductioniterationsBeforeNextStepRTI=0;
		this.limitAnalysisEnabledI=false;
		this.OEEinfoRTI={};
		this.HistInfoRTI={};
		this.DCNotfier=dashboardCreatorNotifier;
		
		this.newIntervalI=false;
		this.processedDataII;
		this.relevantTimestampII;
		this.processedDataStruct;
		
		this.dashboardCacheManager;
	}

	//Initialize Elements
	initialize(dataRequest,rawData,dashboardCacheManager) { 
		
		this.DCNotfier.dgConsole("----------Initialize Processor----------");		
		this.dataRequest=dataRequest;
		this.OperationMode=this.dataRequest.updateRequest[0].OperationMode;
		this.rawData=rawData;
		this.timeRange=(new Date(this.dataRequest.updateRequest[0].finalTime)).getTime() - (new Date(this.dataRequest.updateRequest[0].initialTime)).getTime();
		this.dashboardCacheManager=dashboardCacheManager;


		//Operation in Hist Mode
		if (this.OperationMode==="Hist"){
			
			this.DCNotfier.dgConsole("Initial Time");
			this.DCNotfier.dgConsole((new Date(this.dataRequest.updateRequest[0].initialTime)).getTime());
			this.DCNotfier.dgConsole((new Date(this.dataRequest.updateRequest[0].initialTime)).toString());
			this.DCNotfier.dgConsole("Final Time");
			this.DCNotfier.dgConsole((new Date(this.dataRequest.updateRequest[0].finalTime)).getTime());
			this.DCNotfier.dgConsole((new Date(this.dataRequest.updateRequest[0].finalTime)).toString());
				
			//Find all the unique Chart Categories
			this.uniqueCategoriesConfig=this.uniqueChartCategoriesFinder();
			this.DCNotfier.dgConsole("----------Unique Config Categories----------");
			this.DCNotfier.dgConsole(this.uniqueCategoriesConfig);
			
			//Create all unique Chart Categories
			this.uniqueCategories=this.uniqueCategoriesCreator();
			this.DCNotfier.dgConsole("----------Unique Categories Created----------");
			this.DCNotfier.dgConsole(this.uniqueCategories);
			
			//Create all unique Limit info if valid
			this.LimitInfo =this.uniqueLimitDataCreator();
			this.DCNotfier.dgConsole("----------LimitInfo Created----------");
			this.DCNotfier.dgConsole(this.LimitInfo);
		}
		else if (this.OperationMode==="RealTime"){
			
			//Condition RT Data from web
			this.DCNotfier.dgConsole("----------Conditioning RT Info from web---------");
			this.dataInfoRTWebConditioner();
			
			//Find all the unique Chart Categories
			this.uniqueCategoriesConfigRT=this.uniqueChartCategoriesFinder();
			this.DCNotfier.dgConsole("----------Unique RT Config Categories----------");
			this.DCNotfier.dgConsole(this.uniqueCategoriesConfigRT);
			
			//Create all unique Chart Categories
			this.uniqueCategoriesRT=this.uniqueCategoriesCreatorRT();
			this.DCNotfier.dgConsole("----------Unique RT Categories Created----------");
			this.DCNotfier.dgConsole(this.uniqueCategoriesRT);
			
			//Update Cache for new Intervals
			this.DCNotfier.dgConsole("----------Updating Cross Series Updates---------");
			this.dataInfoRTCacheCrossSeriesUpdater("newInterval");
			
			//Create all unique Limit info if valid
			this.LimitInfoRT =this.uniqueLimitDataCreator();
			this.DCNotfier.dgConsole("----------LimitInfoRT Created----------");
			this.DCNotfier.dgConsole(this.LimitInfoRT);
			
		}
		
	}

	// Method to handle the processing of requests
	processRequestHandler(dataRequest,rawData) { 
		
		//Process each chartConfig request
		this.processedData = this.dataRequest.chartsConfig.map((chartConfigI, index) => {
		
		
			//Define current chartConfig
			this.chartConfigI=this.dataRequest.chartsConfig[index];
			
			//Define current UpdateRequest
			this.updateRequestI=this.dataRequest.updateRequest[index];

			//Find Nodes of ChartConfig
			this.chartNodesI=this.chartNodesIFinder();
			
			//Process each Data Series (each node)
			this.processedDataI=this.chartNodesI.map((nodeI,indexNodeI) => {
			
				//Current Node
				this.nodeI=nodeI;
				this.indexNodeI=indexNodeI;
				this.DCNotfier.dgConsole("------------this.nodeI--------------");	
				this.DCNotfier.dgConsole(this.nodeI);
				
				//Operation in Hist Mode
				if (this.updateRequestI.OperationMode==="Hist"){	
				
					//Current rawData
					this.rawDataI=rawData[rawData.findIndex(data => data.Nodeaddress === this.nodeI)];	
	
					//Category Handling				
					this.chartCategoriesI=this.categoryHandling();				
					this.DCNotfier.dgConsole("------------Selecting Categories------------");
					this.DCNotfier.dgConsole(this.chartCategoriesI);
					 
					//Data Reduction
					this.partialDashboardDataI=this.dataReductor().reducedData;
					this.updateChartCategory();
					this.DCNotfier.dgConsole("------------Partial Dahsboard Data------------");
					this.DCNotfier.dgConsole(this.partialDashboardDataI);					
		
					//Data Processing
					this.processedDataII=this.dataProcessingHandling();
					this.DCNotfier.dgConsole("------------Processed Data------------");
					this.DCNotfier.dgConsole(this.processedDataII);
					
					//Limits
					this.LimitDashboardDataI=this.limitCalculator();
					this.DCNotfier.dgConsole("------------Limits Found------------");
					this.DCNotfier.dgConsole(this.LimitDashboardDataI);	
					
					//Tooltip
					this.TooltipDashboardDataI=this.tooltipInfoCreator();
					this.DCNotfier.dgConsole("------------Tooltip Created------------");
					this.DCNotfier.dgConsole(this.TooltipDashboardDataI);			
					
					//Data for RT Creation 
					this.DataInfoRTIServer=this.dataInfoRTCreator().informationRTIServer;
					this.DataInfoRTIClient=this.dataInfoRTCreator().informationRTIWeb;
					this.DCNotfier.dgConsole("------------Data for RT------------");
					this.DCNotfier.dgConsole(this.DataInfoRTIClient);				
					this.DCNotfier.dgConsole("------------Data for DataInfoRTIServer------------");
					this.DCNotfier.dgConsole(this.DataInfoRTIServer);	
				    this.dataInfoRTCacheStore();
					
					//Create Structure for processed Data				
					this.processedDataStruct=this.createProcessedDataStruct();
					this.DCNotfier.dgConsole("------------Processed Structure------------");
					this.DCNotfier.dgConsole(this.processedDataStruct);
					
					
					return this.processedDataStruct
				}
					
				//Operation in Real time Mode
				else if (this.updateRequestI.OperationMode==="RealTime"){
					
					
					this.informationRTI=this.dataInfoRTFinder();
					this.DCNotfier.dgConsole("----------Information RT----------");
					this.DCNotfier.dgConsole(this.informationRTI);
					
					//Category Handling				
					this.chartCategoriesI=this.categoryHandling();				
					this.DCNotfier.dgConsole("------------Selecting RT Categories------------");
					this.DCNotfier.dgConsole(this.chartCategoriesI);
					
					//Data Reduction
					this.partialDashboardDataI=this.dataReductor().reducedData;
					this.DCNotfier.dgConsole("------------Partial RT Dahsboard Data------------");
					this.DCNotfier.dgConsole(this.partialDashboardDataI);
					
					//Data Processing
					this.processedDataII=this.dataProcessingHandling();
					this.DCNotfier.dgConsole("------------Processed RT Data------------");
					this.DCNotfier.dgConsole(this.processedDataII);	
					
					//Limits					
					this.LimitDashboardDataI=this.limitCalculator();
					this.DCNotfier.dgConsole("------------Limits RT Found------------");
					this.DCNotfier.dgConsole(this.LimitDashboardDataI);	
					
					//Tooltip
					this.TooltipDashboardDataI=this.tooltipInfoCreator();
					this.DCNotfier.dgConsole("------------Tooltip Created------------");
					this.DCNotfier.dgConsole(this.TooltipDashboardDataI)						
					
					//Data for RT Creation 
					this.DataInfoRTIClient=this.dataInfoRTCreator().informationRTIWeb;
					this.DataInfoRTIServer=this.dataInfoRTCreator().informationRTIServer;
					this.DCNotfier.dgConsole("------------Data for RT in RT------------");
					this.DCNotfier.dgConsole(this.DataInfoRTIClient);	
					this.DCNotfier.dgConsole("------------Data for RTTesting------------");
					this.DCNotfier.dgConsole(this.DataInfoRTIServer);	
				    this.dataInfoRTCacheStore();			
					
					//Create Structure for processed Data				
					this.processedDataStruct=this.createProcessedDataStruct();
					this.DCNotfier.dgConsole("------------Processed Structure------------");
					this.DCNotfier.dgConsole(this.processedDataStruct);
					
					const processedDataStruc=this.processedDataStruct;
					
					return processedDataStruc;
				}	
			});
			

			return {chartID:this.chartConfigI.chartID,
					processedDataStruct:this.processedDataI,
					chartType:this.chartConfigI.chartType,
					elementType:this.chartConfigI.elementType,
					categoryType:this.chartConfigI.categoryType}
		});	
	
		return this.processedData;
	} 
  
	//----------Auxiliary Functions---------------------//
	//--------------------------------------------------//
  
	//Handles Category Per node
	categoryHandling() {
		try {
			const categoryFound=this.chartCategoryIFinder();
			return categoryFound;		  
		} catch (error) {
		  console.error("Error handling category: ", error);
		  console.error(error.message);
		  return { categories: [] }; // Return an empty categories array or handle the error as needed
		}
	}
  
    //Chart Nodes Finder
	chartNodesIFinder() {
	  try {
		// Find index of matching ID
		const nodesIndex = this.dataRequest.chartsNodes.findIndex(chart => chart.chartID === this.chartConfigI.chartID);
	
		if (nodesIndex === -1) {
		  throw new Error(`Chart ID ${this.chartConfigI.chartID} not found`);
		}
	
		// Get the nodes corresponding to the chartID
		let chartNodesI = [...this.dataRequest.chartsNodes[nodesIndex].chartNodes];
	
		// Check for FullRange-OEEProductivity case using nodesIndex
		const chartConfig = this.dataRequest.chartsConfig[nodesIndex];
		
		// Remove limit nodes if limit analysis is enabled
		if (chartConfig.dataoutOfLimitEnable) {
			// Remove max limit node if it exists
			if (chartConfig.specialParameters?.MaxLimitNode) {
				const maxLimitNode = chartConfig.specialParameters.MaxLimitNode;
				chartNodesI = chartNodesI.filter(node => node !== maxLimitNode);
			}
			
			// Remove min limit node if it exists
			if (chartConfig.specialParameters?.MinLimitNode) {
				const minLimitNode = chartConfig.specialParameters.MinLimitNode;
				chartNodesI = chartNodesI.filter(node => node !== minLimitNode);
			}
		}
		
		if (chartConfig.dataProcessingType === "FullRange-OEEProductivity") {		
			if (chartConfig.specialParameters.OEEProSM=="VariableSpeed"&&chartConfig.specialParameters.OEEProdSpeedN !== "") {
			  const prodSpeedNode = chartConfig.specialParameters?.OEEProdSpeedN;
			  if (prodSpeedNode) {
				// Remove the node if it exists in chartNodesI
				chartNodesI = chartNodesI.filter(node => node !== prodSpeedNode);
			  }
			 }
			 else if (chartConfig.specialParameters.OEEProSM=="ExpectedUnitsCounter"&&chartConfig.specialParameters.OEEProExUCN !== "") {
			  const proExUNode = chartConfig.specialParameters?.OEEProExUCN;
			  if (proExUNode) {
				// Remove the node if it exists in chartNodesI
				chartNodesI = chartNodesI.filter(node => node !== proExUNode);
			  }
			 }	
		}
		
		if (chartConfig.dataProcessingType === "FullRange-OEEQuality") {
		  const prodNode = chartConfig.specialParameters?.OEEPrN;
		  if (prodNode) {
			// Remove the node if it exists in chartNodesI
			chartNodesI = chartNodesI.filter(node => node !== prodNode);
		  }
		}
		
		if (chartConfig.dataProcessingType === "FullRange-OEE") {
			//Only keep Prod Node		
		
		  //Remove Production Speed
		 if (chartConfig.specialParameters.OEEProSM=="VariableSpeed"&&chartConfig.specialParameters.OEEProdSpeedN !== "") {
			  const prodSpeedNode = chartConfig.specialParameters?.OEEProdSpeedN;
			  if (prodSpeedNode) {
				// Remove the node if it exists in chartNodesI
				chartNodesI = chartNodesI.filter(node => node !== prodSpeedNode);
			  }
		  }
		  //Remove Expected Units Counter
		  else if (chartConfig.specialParameters.OEEProSM=="ExpectedUnitsCounter"&&chartConfig.specialParameters.OEEProExUCN !== "") {
			  const proExUNode = chartConfig.specialParameters?.OEEProExUCN;
			  if (proExUNode) {
				// Remove the node if it exists in chartNodesI
				chartNodesI = chartNodesI.filter(node => node !== proExUNode);
			  }
		  }	
		  
		   //Remove Avaliability
		  const AvailNode = chartConfig.specialParameters?.OEEAvN;
		  if (AvailNode) {
			// Remove the node if it exists in chartNodesI
			chartNodesI = chartNodesI.filter(node => node !== AvailNode);
		  }
		  
		   //Remove Quality Node
		  const QualNode = chartConfig.specialParameters?.OEEQuN;
		  if (QualNode) {
			// Remove the node if it exists in chartNodesI
			chartNodesI = chartNodesI.filter(node => node !== QualNode);
		  } 
		  
		}
	
		return chartNodesI;
	  } catch (error) {
		console.error("Error finding chart nodes: ", error);
		console.error(error.message);
		return []; // Return an empty array or handle the error as needed
	  }
    }
	
	//Find current Chart Category 
	chartCategoryIFinder() {
		
		var uniqueCategories;
		
		if (this.OperationMode==="Hist"){
			const uniqueCategoriesI=this.uniqueCategories;
			uniqueCategories=uniqueCategoriesI;
		}
		else if (this.OperationMode==="RealTime"){
			const uniqueCategoriesI=this.uniqueCategoriesRT;
			uniqueCategories=uniqueCategoriesI;
		}				
		
        // Find the category entry where the current chartID is included in the chartIDs array
        const categoryEntry = uniqueCategories.find(category => category.chartIDs.includes(this.chartConfigI.chartID));
        
        // Return the categories array if an entry is found, otherwise return null or an empty array
        return categoryEntry ? categoryEntry: null;
    }
  
	//Data Processing Handling
	dataProcessingHandling(){
	
		this.DCNotfier.dgConsole("------------Processing Type------------")
		this.DCNotfier.dgConsole(this.chartConfigI.dataProcessingType);
		
		switch (this.chartConfigI.dataProcessingType) {
			case "Simple-None": //No change
				this.DCNotfier.dgConsole("Not changed");
				if (this.chartConfigI.elementType === "Chart") {
					if (this.OperationMode === "Hist") {
						return {ProcessedData:this.partialDashboardDataI.Values};
					}
					else if (this.OperationMode === "RealTime") {
						let ProcessedDataI=this.informationRTI.LastDataPointRT.map(DataPointRT=>DataPointRT.Value)
						return {ProcessedData:ProcessedDataI};
					}
				}
				else if (this.chartConfigI.elementType === "Table"){
					this.DCNotfier.dgConsole("Simple-None Table")
					return this.SimpleNoneTableProcessing();
				}
				break;	
			case "SinglePoint-LastValue": 	//Use Last Value
				this.DCNotfier.dgConsole("Last Value")
				return this.SinglePoint_lastValue(this.partialDashboardDataI);
				break;	
			case "SinglePoint-FirstValue": 	//Use Last Value
				this.DCNotfier.dgConsole("First Value")
				return this.SinglePoint_firstValue(this.partialDashboardDataI);
				break;
			case "SinglePoint-Max": 	//Use Last Value
				this.DCNotfier.dgConsole("Single Point Max")
				return this.SinglePoint_Max(this.rawDataI);
				break;
			case "SinglePoint-Min": 	//Use Last Value
				this.DCNotfier.dgConsole("Single Point Min")
				return this.SinglePoint_Min(this.rawDataI);
				break;
			case "Interval-Addition": 	//Add all the elements within intervals	
				this.DCNotfier.dgConsole("Adding Intervals")
				return this.Interval_Addition(this.partialDashboardDataI,this.chartCategoriesI.chartCategory.intervals);
				break;
			case "Interval-CountChanges":  //Count Number of Changes
				this.DCNotfier.dgConsole("Counting Changes")
				return this.Interval_ChangesCounter(this.partialDashboardDataI,this.chartCategoriesI.chartCategory.intervals);
				break;
			case "Interval-CountTimeOn":  //Count Number of Changes
				this.DCNotfier.dgConsole("Count Time On")
				return this.Interval_CountTimeOn(this.partialDashboardDataI,this.chartCategoriesI.chartCategory.intervals);
				break;
			case "Interval-Difference": 	//Add all the elements	
				this.DCNotfier.dgConsole("Interval Difference");
				return this.Interval_Difference(this.partialDashboardDataI,this.chartCategoriesI.chartCategory.intervals);
				break;
			case "Interval-Integration":  //Integrate Data
				this.DCNotfier.dgConsole("Integrated Data")
				return this.Interval_Integration(this.partialDashboardDataI,this.chartCategoriesI.chartCategory.intervals);
				break;	
			case "Interval-Average":  //Interval Average
				this.DCNotfier.dgConsole("Interval Average Data")
				return this.Interval_Average(this.partialDashboardDataI,this.chartCategoriesI.chartCategory.intervals);
				break;		
			case "Interval-Histogram": 	//Use Histogram Calculatio
				this.DCNotfier.dgConsole("Interval Histogram")
				return this.Interval_Histogram(this.partialDashboardDataI,this.chartCategoriesI.chartCategory.categories);
				break;	
			case "FullRange-Addition": 	//Add all the elements	
				this.DCNotfier.dgConsole("Simple Addition")
				return this.FullRange_Addition(this.partialDashboardDataI);
				break;
			case "FullRange-Average": 	//Add all the elements	
				this.DCNotfier.dgConsole("FullRange Average")
				return this.FullRange_Average(this.partialDashboardDataI);
				break;			
			case "FullRange-Integration": 	//Integrate all data
				this.DCNotfier.dgConsole("FullRange Integration")
				return this.FullRange_Integration(this.partialDashboardDataI,this.informationRTI,this.chartConfigI.dataPrTUnit,[]);
				break;				
			case "FullRange-Difference": 	//Add all the elements	
				this.DCNotfier.dgConsole("Interval Difference")
				return this.FullRange_Difference(this.partialDashboardDataI,this.informationRTI);
				break;																		
			case "FullRange-OEEProductivity": 	//OEE Productivity
				this.DCNotfier.dgConsole("OEE Productivity")
				return this.FullRange_OEEProductivity(this.partialDashboardDataI,this.informationRTI);
				break;	
			case "FullRange-OEEAvailability": 	//OEE Productivity
				this.DCNotfier.dgConsole("OEE Availability")
				return this.FullRange_OEEAvailability(this.partialDashboardDataI,this.informationRTI);
				break;	
			case "FullRange-OEEQuality": 	//OEE Quality
				this.DCNotfier.dgConsole("OEE Quality")
				return this.FullRange_OEEQuality(this.partialDashboardDataI,this.informationRTI);
				break;
			case "FullRange-OEE": 	//OEE 
				this.DCNotfier.dgConsole("OEE")
				return this.FullRange_OEE(this.partialDashboardDataI);
				break;																			
			default: //No processing done
				this.DCNotfier.dgConsole("No processing done")
				return {ProcessedData:this.partialDashboardDataI.Values};
				break;
		}
	
	}
	
	//Creating Process Data Structure
	createProcessedDataStruct() {
	
		//Create structure based on if it has limits or not
		if(this.limitAnalysisEnabledI)
			{
				return {processedDataI:this.processedDataII.ProcessedData,
									 chartCategories:this.chartCategoriesI.chartCategory.categories,
									 LimitDashboardData:this.LimitDashboardDataI,
									 tooltipInfo:this.TooltipDashboardDataI,
									 informationRT: this.DataInfoRTIClient,
									 processedNode:this.nodeI
									 }
			}
			else{
				return {processedDataI:this.processedDataII.ProcessedData,
									 chartCategories:this.chartCategoriesI.chartCategory.categories,
									 informationRT: this.DataInfoRTIClient,
									 tooltipInfo:this.TooltipDashboardDataI,
									 processedNode:this.nodeI
									 }
			}  
	}
		
	//----------Optimization Functions---------------------//
	//--------------------------------------------------//
	
	
	// Method to reduce data as needed
	dataReductor() {
        try {
            this.DCNotfier.dgConsole("----------Reducing Data--------------");
            let reducedData = { Values: [], status: [], timestamps: [] };
			if (this.rawDataI != undefined) {
				if (this.OperationMode === "Hist") {
					const step = this.rawDataI.DataSize > this.chartConfigI.dataReductionMaxSize ? Math.ceil(this.rawDataI.DataSize / this.chartConfigI.dataReductionMaxSize) : 0;
					this.reductionStepSizeI=step;
					
					//Reduction needed
					if (this.chartConfigI.dataReductionEnable === true && step > 0) {
						// Reduce the data to MaxSize by removing elements
						for (let i = 0; i < this.rawDataI.Values.length; i += step) {
							reducedData.Values.push(this.rawDataI.Values[i]);
							reducedData.status.push(this.rawDataI.status[i]);
							reducedData.timestamps.push(this.rawDataI.timestamps[i]);
	
							// Track the iterations needed for the next step
							this.iterationsBeforeNextStep = i + step - this.rawDataI.Values.length;        
						}                   
						this.reductionExcecutedI = true;
						// Update DataSize for both objects
						reducedData.DataSize = reducedData.Values.length;                    
					}               
					else {
						this.reductionExcecutedI = false;
						reducedData = this.rawDataI;
					}				      
				} else if (this.OperationMode === "RealTime") {
					if (this.chartConfigI.dataReductionEnable === true) {
						let reductionStepSize = this.informationRTI.ReduceInfo.reductionStepSize;
						let reductionIterationsBeforeNextStepRT = this.informationRTI.ReduceInfo.reductionIterationsBeforeNextStepRT;
						
						if (this.informationRTI.ReduceInfo.reductionStepSize<=0){
								this.informationRTI.LastDataPointRT.forEach(dataPoint => {
								reducedData.Values.push(dataPoint.Value);
								reducedData.status.push(dataPoint.status);
								reducedData.timestamps.push(dataPoint.timestamps)
							});
						}
						else{
							this.informationRTI.LastDataPointRT.forEach(dataPoint => {
								if (reductionIterationsBeforeNextStepRT === 0) {
									reducedData.Values.push(dataPoint.Value);
									reducedData.status.push(dataPoint.status);
									reducedData.timestamps.push(dataPoint.timestamps);
			
									reductionIterationsBeforeNextStepRT = reductionStepSize;
								} else {
									reductionIterationsBeforeNextStepRT--;
								}
							});
						}
		
						this.iterationsBeforeNextStep = reductionIterationsBeforeNextStepRT;
	
						this.reductionExcecutedI = true;
						reducedData.DataSize = reducedData.Values.length;
					}
					//Reduction Disabled
					else{
						this.reductionExcecutedI = false;
						reducedData = this.informationRTI.LastDataPointRT;            
					}
				}
            }

            //this.DCNotfier.dgConsole({reducedData});
            this.DCNotfier.dgConsole("Iterations before next step: ", this.iterationsBeforeNextStep);

            return { reducedData};
        } catch (error) {
            console.error("Error reducing data: ", error);
            console.error(error.message);
            return { reducedData: {}, filteredData: [] }; // Return empty objects or handle the error as needed
        }
    }
    
    tableCategoryProcessor(categoriesData) {
    
    try {
        this.DCNotfier.dgConsole("----------Processing Table Categories--------------");
        this.DCNotfier.dgConsole(this.uniqueCategoriesConfigI.categoryConfig);
		this.DCNotfier.dgConsole(this.uniqueCategoriesConfigI.categoryConfig.dataReductionEnable);
        if (this.uniqueCategoriesConfigI.categoryConfig.dataReductionEnable === true) {
			this.DCNotfier.dgConsole("----------Redudcing categories---------");
            const maxSize = this.uniqueCategoriesConfigI.categoryConfig.dataReductionMaxSize;
            const categories = categoriesData[0].categories;
            const chartNode = categoriesData[0].chartNode;

            // Calculate the step size for reduction
            const step = categories.length > maxSize ? Math.ceil(categories.length / maxSize) : 0;
            let reducedCategories = [];
            let reducedChartNode = chartNode; // Assuming chartNode remains the same

            if (step > 0) {
                // Reduce the categories array
                for (let i = 0; i < categories.length; i += step) {
                    reducedCategories.push(categories[i]);
                }
                this.DCNotfier.dgConsole("Categories reduced from", categories.length, "to", reducedCategories.length);
            } else {
                // No reduction needed
                reducedCategories = categories;
            }

            // Return the reduced data
            return { categories: reducedCategories, chartNode: reducedChartNode };

        } else {
            // Data reduction not enabled, return original data
            return categoriesData;
        }
    } catch (error) {
        console.error("Error in tableCategoryProcessor: ", error);
        console.error(error.message);
        return { categories: [], chartNode: [] };
    }
	}
    
    //----------Limit Functions---------------------//
	//--------------------------------------------------//
	
	//Calculate Unique Limit info
	uniqueLimitDataCreator() {
        this.DCNotfier.dgConsole("----------Initialize Limit Info Creator----------");
        let limitInfo=new Array();
		
        if (this.OperationMode == "Hist") {
			
			if (!this.rawData || this.rawData.length === 0) {
				this.DCNotfier.dgConsole("Raw data is missing or empty. Cannot create Limit Info.");
				return;
			}
	
			// Get the overall start and end times for clipping trends
			// Use the request's time range as the global context
			const globalStartTime = new Date(this.dataRequest.updateRequest[0].initialTime).getTime();
			const globalEndTime = new Date(this.dataRequest.updateRequest[0].finalTime).getTime();
			
			this.uniqueCategoriesConfig.forEach(config => {
				try {
					this.DCNotfier.dgConsole("Iterating in ");
					this.DCNotfier.dgConsole(config);
					const categoryConfig = config.categoryConfig;
					const params = categoryConfig.specialParameters;
					const chartIDs = config.chartIDs;
	
					// --- Check Eligibility ---
					const useMaxNodeLimit = categoryConfig.dataoutOfLimitEnable === true &&
											params?.dataMaxType === "Node" &&
											params?.MaxLimitNode;
					const useMinNodeLimit = categoryConfig.dataoutOfLimitEnable === true &&
											params?.dataMinType === "Node" &&
											params?.MinLimitNode;
	
					if (!useMaxNodeLimit && !useMinNodeLimit) {
						// This configuration doesn't use node-based limits, skip.
						return; // Continue to next config
					}
	
					this.DCNotfier.dgConsole(`Processing Limit Info for Chart IDs: ${chartIDs.join(', ')}`);
	
					// --- Initialize ---
					let rawMaxLimitData = null;
					let rawMinLimitData = null;
					let plotLimitData = {
						MaxLimitTrendData: { Values: [], timestamps: [] },
						MinLimitTrendData: { Values: [], timestamps: [] }
					};
	
					// --- Process Max Limit ---
					if (useMaxNodeLimit) {
						rawMaxLimitData = this.rawData.find(d => d.Nodeaddress === params.MaxLimitNode);
						if (!rawMaxLimitData || !rawMaxLimitData.Values || !rawMaxLimitData.timestamps || rawMaxLimitData.Values.length === 0) {
							this.DCNotfier.dgConsole(`WARN: Max limit node data (${params.MaxLimitNode}) not found, incomplete, or empty.`);
							rawMaxLimitData = null; // Ensure it's null if invalid
						} else {
							this.DCNotfier.dgConsole(`Found Raw Max Limit Data for ${params.MaxLimitNode}`);
							// --- Generate MaxLimitTrendData (Clipped to global time range) ---
							const startValueMax = this.findClosestValueByTimestamp(globalStartTime, rawMaxLimitData);
							const endValueMax = this.findClosestValueByTimestamp(globalEndTime, rawMaxLimitData);
	
							if (startValueMax !== null && endValueMax !== null) {
								let combinedPoints = [];
								// 1. Filter original points within the global time range
								for (let j = 0; j < rawMaxLimitData.timestamps.length; j++) {
									const ts = rawMaxLimitData.timestamps[j];
									if (ts >= globalStartTime && ts <= globalEndTime) {
										combinedPoints.push({ timestamp: ts, value: rawMaxLimitData.Values[j] });
									}
								}
								// 2. Add/Update Start Point
								const startIndex = combinedPoints.findIndex(p => p.timestamp === globalStartTime);
								if (startIndex !== -1) {
									combinedPoints[startIndex].value = startValueMax;
								} else {
									combinedPoints.push({ timestamp: globalStartTime, value: startValueMax });
								}
								// 3. Add/Update End Point
								const endIndex = combinedPoints.findIndex(p => p.timestamp === globalEndTime);
								if (endIndex !== -1) {
									combinedPoints[endIndex].value = endValueMax;
								} else {
									combinedPoints.push({ timestamp: globalEndTime, value: endValueMax });
								}
								// 4. Sort
								combinedPoints.sort((a, b) => a.timestamp - b.timestamp);
								// 5. Populate
								plotLimitData.MaxLimitTrendData.timestamps = combinedPoints.map(p => p.timestamp);
								plotLimitData.MaxLimitTrendData.Values = combinedPoints.map(p => p.value);
								this.DCNotfier.dgConsole(`Generated MaxLimitTrendData with ${plotLimitData.MaxLimitTrendData.Values.length} points.`);
							} else {
								 this.DCNotfier.dgConsole(`WARN: Could not determine start/end values for MaxLimitTrendData.`);
							}
						}
					}
	
					// --- Process Min Limit ---
					if (useMinNodeLimit) {
						rawMinLimitData = this.rawData.find(d => d.Nodeaddress === params.MinLimitNode);
						if (!rawMinLimitData || !rawMinLimitData.Values || !rawMinLimitData.timestamps || rawMinLimitData.Values.length === 0) {
							 this.DCNotfier.dgConsole(`WARN: Min limit node data (${params.MinLimitNode}) not found, incomplete, or empty.`);
							rawMinLimitData = null; // Ensure it's null if invalid
						} else {
							 this.DCNotfier.dgConsole(`Found Raw Min Limit Data for ${params.MinLimitNode}`);
							// --- Generate MinLimitTrendData (Clipped to global time range) ---
							const startValueMin = this.findClosestValueByTimestamp(globalStartTime, rawMinLimitData);
							const endValueMin = this.findClosestValueByTimestamp(globalEndTime, rawMinLimitData);
	
							if (startValueMin !== null && endValueMin !== null) {
								let combinedPoints = [];
								// 1. Filter
								for (let j = 0; j < rawMinLimitData.timestamps.length; j++) {
									const ts = rawMinLimitData.timestamps[j];
									if (ts >= globalStartTime && ts <= globalEndTime) {
										combinedPoints.push({ timestamp: ts, value: rawMinLimitData.Values[j] });
									}
								}
								// 2. Add/Update Start
								 const startIndex = combinedPoints.findIndex(p => p.timestamp === globalStartTime);
								 if (startIndex !== -1) {
									 combinedPoints[startIndex].value = startValueMin;
								 } else {
									 combinedPoints.push({ timestamp: globalStartTime, value: startValueMin });
								 }
								 // 3. Add/Update End
								 const endIndex = combinedPoints.findIndex(p => p.timestamp === globalEndTime);
								 if (endIndex !== -1) {
									 combinedPoints[endIndex].value = endValueMin;
								 } else {
									 combinedPoints.push({ timestamp: globalEndTime, value: endValueMin });
								 }
								// 4. Sort
								combinedPoints.sort((a, b) => a.timestamp - b.timestamp);
								// 5. Populate
								plotLimitData.MinLimitTrendData.timestamps = combinedPoints.map(p => p.timestamp);
								plotLimitData.MinLimitTrendData.Values = combinedPoints.map(p => p.value);
								this.DCNotfier.dgConsole(`Generated MinLimitTrendData with ${plotLimitData.MinLimitTrendData.Values.length} points.`);
							} else {
								 this.DCNotfier.dgConsole(`WARN: Could not determine start/end values for MinLimitTrendData.`);
							}
						}
					}
	
					// --- Store Result ---				
					limitInfo.push({
						chartIDs: chartIDs,
						LimitInfo: {
							rawLimitData: [rawMaxLimitData, rawMinLimitData], // Store raw data found
							plotLimitData: plotLimitData                      // Store processed plot data
						}
					});		
					
				} catch (error) {
					console.error(`Error processing limit info for config with chartIDs ${config.chartIDs.join(', ')}: `, error);
					 this.DCNotfier.dgConsole(`Error details: ${error.message}`);
				}
			});
	
			return limitInfo;
			
			this.DCNotfier.dgConsole("----------Finished Limit Info Creator----------");
			this.DCNotfier.dgConsole("Generated LimitInfo:", JSON.parse(JSON.stringify(this.LimitInfo))); // Deep copy for logging complex objects
        }
        
        else if (this.OperationMode === "RealTime") {
            // --- REALTIME MODE LOGIC ---
            this.DCNotfier.dgConsole("Processing Limit Info for RealTime Mode");

            if (!this.uniqueCategoriesConfigRT || this.uniqueCategoriesConfigRT.length === 0) {
                 this.DCNotfier.dgConsole("No uniqueCategoriesConfigRT found for RealTime. Skipping Limit Info creation.");
                 this.LimitInfo = [];
                 return this.LimitInfo;
            }

            this.uniqueCategoriesConfigRT.forEach(config => {
                try {
                    const categoryConfig = config.categoryConfig;
                    const params = categoryConfig.specialParameters;
                    const chartIDs = config.chartIDs;

                    // --- Check Eligibility (RT) ---
                    const useMaxNodeLimit = categoryConfig.dataoutOfLimitEnable === true &&
                                            params?.dataMaxType === "Node" &&
                                            params?.MaxLimitNode;
                    const useMinNodeLimit = categoryConfig.dataoutOfLimitEnable === true &&
                                            params?.dataMinType === "Node" &&
                                            params?.MinLimitNode;

                    if (!useMaxNodeLimit && !useMinNodeLimit) {
                        return; // Continue to next config
                    }

                    this.DCNotfier.dgConsole(`Processing RT Limit Info for Chart IDs: ${chartIDs.join(', ')}`);

                    // --- Initialize RT ---
                    let rawMaxLimitDataRT = null;
                    let rawMinLimitDataRT = null;
                    let plotLimitDataRT = {
                        MaxLimitTrendData: { Values: [], timestamps: [] },
                        MinLimitTrendData: { Values: [], timestamps: [] }
                    };

                   
                    // --- Process Max Limit (RT) using readCurrentValue ---
                    if (useMaxNodeLimit) {
                        rawMaxLimitDataRT = this.readCurrentValue(params.MaxLimitNode);
                        if (rawMaxLimitDataRT && rawMaxLimitDataRT.Value !== null && typeof rawMaxLimitDataRT.Value === 'number' && !isNaN(rawMaxLimitDataRT.Value)) {
                            this.DCNotfier.dgConsole(`Read Max Limit Value (RT) for ${params.MaxLimitNode}: ${rawMaxLimitDataRT.Value}`);
                            // Use the read value for the plot, spanning the interval
                            plotLimitDataRT.MaxLimitTrendData.Values = [rawMaxLimitDataRT.Value];
                            plotLimitDataRT.MaxLimitTrendData.timestamps =  [rawMaxLimitDataRT.timestamps];
                        } else {
                            this.DCNotfier.dgConsole(`WARN: Failed to read or invalid Max Limit Value (RT) for ${params.MaxLimitNode}. Read result:`, rawMaxLimitDataRT);
                            rawMaxLimitDataRT = null;
                        }
                    }
         

                    // --- Process Min Limit (RT) using readCurrentValue ---
                    if (useMinNodeLimit) {
                        rawMinLimitDataRT = this.readCurrentValue(params.MinLimitNode);
                         if (rawMinLimitDataRT && rawMinLimitDataRT.Value !== null && typeof rawMinLimitDataRT.Value === 'number' && !isNaN(rawMinLimitDataRT.Value)) {
                            this.DCNotfier.dgConsole(`Read Min Limit Value (RT) for ${params.MinLimitNode}: ${rawMinLimitDataRT.Value}`);
                             // Use the read value for the plot, spanning the interval
                            plotLimitDataRT.MinLimitTrendData.Values = [rawMinLimitDataRT.Value];
                            plotLimitDataRT.MinLimitTrendData.timestamps = [rawMinLimitDataRT.timestamps];
                        } else {
                            this.DCNotfier.dgConsole(`WARN: Failed to read or invalid Min Limit Value (RT) for ${params.MinLimitNode}. Read result:`, rawMinLimitDataRT);
                            rawMinLimitDataRT = null;
                        }
                    }

                    // --- Store Result (RT) ---
                    limitInfo.push({
                        chartIDs: chartIDs,
                        LimitInfo: {
                            rawLimitData: [rawMaxLimitDataRT, rawMinLimitDataRT],
                            plotLimitData: plotLimitDataRT
                        }
                    });

                } catch (error) {
                     console.error(`Error processing RT limit info for config with chartIDs ${config.chartIDs.join(', ')}: `, error);
                     this.DCNotfier.dgConsole(`Error details: ${error.message}`);
                }
            });

           
            this.DCNotfier.dgConsole("----------Finished RealTime Limit Info Creator----------");
		    return limitInfo;
            // --- END REALTIME MODE LOGIC ---
        }
    }	
    
    //Find precalculated Limit Info    
    findPrecalculatedLimitInfo(chartID) {
		if (this.OperationMode === "Hist") {
			const entry = this.LimitInfo.find(info => info.chartIDs.includes(chartID));
			return entry ? entry.LimitInfo : null;
          }
		else if (this.OperationMode === "RealTime") {
			const entry = this.LimitInfoRT.find(info => info.chartIDs.includes(chartID));
			return entry ? entry.LimitInfo : null;
          }
	
    }
	
	//Limit Calculator Handling
	limitCalculator(){
		
		this.DCNotfier.dgConsole("------------Calculating limits------------");
		this.DCNotfier.dgConsole(this.chartConfigI);
		this.DCNotfier.dgConsole("------------This raw data------------");
		this.DCNotfier.dgConsole(this.rawData);
					
		// Determine if Analysis is Enabled based on limits and limit types

		// Extract limit values and types
		const minLimit = this.chartConfigI?.specialParameters?.dataMinLimit || "";
		const maxLimit = this.chartConfigI?.specialParameters?.dataMaxLimit || "";
		const minLimitType = this.chartConfigI?.specialParameters?.dataMinType || "";
		const maxLimitType = this.chartConfigI?.specialParameters?.dataMaxType || "";
		const minLimitNode = this.chartConfigI?.specialParameters?.MinLimitNode || null;
		const maxLimitNode = this.chartConfigI?.specialParameters?.MaxLimitNode || null;
		
		// Update limit parameters
		this.chartConfigI.specialParameters.dataMinLimit = minLimit;
		this.chartConfigI.specialParameters.dataMaxLimit = maxLimit;
		
		// Validate fixed limits
		const minLimitValid = minLimit.length > 0;
		const maxLimitValid = maxLimit.length > 0;
		
		// Validate node-based limits
		const minLimitNodeValid = minLimitType === "Node" && minLimitNode !== null;
		const maxLimitNodeValid = maxLimitType === "Node" && maxLimitNode !== null;
		
		// Determine if limit analysis should be enabled
		this.limitAnalysisEnabledI = this.chartConfigI?.dataoutOfLimitEnable === true &&
			(minLimitValid || maxLimitValid || minLimitNodeValid || maxLimitNodeValid);
		
		this.DCNotfier.dgConsole("------------limitAnalysisEnabledI------------");
		this.DCNotfier.dgConsole(this.limitAnalysisEnabledI);	
			
			
		let filteredData;
		let plotLimitData;
		
		
		if (this.limitAnalysisEnabledI ){
		
			//For Data processing Simple-None
			if(this.chartConfigI.dataProcessingType.includes("Simple")){
				let limitResult=this.limitCalculatorAllData();
				filteredData=limitResult.filteredData;
				plotLimitData =limitResult.plotLimitData;
			}
			else if(this.chartConfigI.dataProcessingType.includes("Interval")){
				filteredData=this.limitCalculatorInterval().filteredData;
			}
			else if(this.chartConfigI.dataProcessingType.includes("SinglePoint")||this.chartConfigI.dataProcessingType.includes("FullRange")){
				filteredData=this.limitCalculatorSingleElement().filteredData;
			}
		}
		else{
			let filteredData = {"Enabled":this.limitAnalysisEnabledI};
		} 
		 return {filteredData:filteredData,plotLimitData:plotLimitData};		
	}
   
	//Limit Calculator All data
	limitCalculatorAllData() {
		this.DCNotfier.dgConsole("-----------Executing limitCalculatorAllData--------");

		// Initialize outputs
		let filteredData = { Values: [], status: [], timestamps: [], Enabled: false, DataSize: 0 };
        // Initialize plotLimitData with empty structure, will be replaced if found
        let plotLimitData = {
			MaxLimitTrendData: { Values: [], timestamps: [] },
			MinLimitTrendData: { Values: [], timestamps: [] }
		};

		const params = this.chartConfigI.specialParameters;
        filteredData.Enabled = this.limitAnalysisEnabledI; // Set enabled status based on earlier check in limitCalculator

        // Only proceed if limit analysis is actually enabled for this chart
        if (!filteredData.Enabled) {
             this.DCNotfier.dgConsole("Limit analysis not enabled for this chart config. Skipping limit checks.");
            return { filteredData, plotLimitData }; // Return empty/default structures
        }

		if (this.OperationMode === "Hist") {
			if (!this.rawDataI || !this.rawDataI.Values || this.rawDataI.Values.length === 0) { // Check length explicitly
				this.DCNotfier.dgConsole("WARN: Historical rawDataI for the current node is missing or empty.");
				return { filteredData, plotLimitData }; // Return empty structures
			}

			const mainTimestamps = this.rawDataI.timestamps;
			const mainValues = this.rawDataI.Values;
			const mainStatus = this.rawDataI.status;

            // --- Retrieve Pre-calculated Limit Info ---
            const precalculatedInfo = this.findPrecalculatedLimitInfo(this.chartConfigI.chartID);
            let rawMaxLimitData = null;
            let rawMinLimitData = null;

            if (precalculatedInfo) {
                rawMaxLimitData = precalculatedInfo.rawLimitData[0]; // Can be null
                rawMinLimitData = precalculatedInfo.rawLimitData[1]; // Can be null
                // Directly use the pre-calculated plot data
                plotLimitData = precalculatedInfo.plotLimitData;
            } else {
                 this.DCNotfier.dgConsole("No pre-calculated LimitInfo found for this chartID. Limit checks involving nodes might fail.");
            }


			// --- Filtering Logic (using rawDataI and potentially rawLimitData) ---
			const fixedMaxLimitValue = (params.dataMaxType === "Fixed" && params.dataMaxLimit && typeof params.dataMaxLimit === 'string' && params.dataMaxLimit.length > 0)
				? parseFloat(params.dataMaxLimit) : NaN;
			const fixedMinLimitValue = (params.dataMinType === "Fixed" && params.dataMinLimit && typeof params.dataMinLimit === 'string' && params.dataMinLimit.length > 0)
				? parseFloat(params.dataMinLimit) : NaN;

            if (mainTimestamps && mainValues) { // Ensure main data arrays exist
                for (let i = 0; i < mainTimestamps.length; i++) {
                    const currentTimestamp = mainTimestamps[i];
                    const currentValue = mainValues[i];
                    let isAboveMax = false;
                    let isBelowMin = false;

                    // Max Check
                    if (params.dataMaxType === "Fixed") {
                        if (!isNaN(fixedMaxLimitValue) && currentValue > fixedMaxLimitValue) isAboveMax = true;
                    } else if (params.dataMaxType === "Node" && rawMaxLimitData) { // Check if rawMaxLimitData was found
                        const maxLimitValue = this.findClosestValueByTimestamp(currentTimestamp, rawMaxLimitData);
                        // Check if maxLimitValue is a valid number before comparison
                        if (maxLimitValue !== null && typeof maxLimitValue === 'number' && !isNaN(maxLimitValue) && currentValue > maxLimitValue) isAboveMax = true;
                    }

                    // Min Check
                    if (params.dataMinType === "Fixed") {
                        if (!isNaN(fixedMinLimitValue) && currentValue < fixedMinLimitValue) isBelowMin = true;
                    } else if (params.dataMinType === "Node" && rawMinLimitData) { // Check if rawMinLimitData was found
                        const minLimitValue = this.findClosestValueByTimestamp(currentTimestamp, rawMinLimitData);
                         // Check if minLimitValue is a valid number before comparison
                        if (minLimitValue !== null && typeof minLimitValue === 'number' && !isNaN(minLimitValue) && currentValue < minLimitValue) isBelowMin = true;
                    }

                    // Add to filteredData if out of limits
                    if (isAboveMax || isBelowMin) {
                        filteredData.Values.push(currentValue);
                        // Ensure status exists before pushing
                        filteredData.status.push(mainStatus && mainStatus[i] !== undefined ? mainStatus[i] : null);
                        filteredData.timestamps.push(currentTimestamp);
                    }
                }
                 filteredData.DataSize = filteredData.Values.length;
            } else {
                 this.DCNotfier.dgConsole("WARN: mainTimestamps or mainValues missing for filtering.");
            }


		} 
		else if (this.OperationMode === "RealTime1") {

			 if (!this.informationRTI || !this.informationRTI.LastDataPointRT) {
				this.DCNotfier.dgConsole("WARN: RealTime informationRTI missing or LastDataPointRT undefined.");
				return { filteredData, plotLimitData }; // Return empty structures
			}
            if(Array.isArray(this.informationRTI.LastDataPointRT)){ // Check if it's an array
                this.informationRTI.LastDataPointRT.forEach((dataPoint) => {
                    if (dataPoint && dataPoint.hasOwnProperty('Value')) {
                        const pointValue = dataPoint.Value;
                        
                        // Use parseFloat for comparison if limits are strings
                        const maxFixedLimitRT = (params.dataMaxType === "Fixed" && params.dataMaxLimit && typeof params.dataMaxLimit === 'string' && params.dataMaxLimit.length > 0)
                            ? parseFloat(params.dataMaxLimit) : NaN;
                        const minFixedLimitRT = (params.dataMinType === "Fixed" && params.dataMinLimit && typeof params.dataMinLimit === 'string' && params.dataMinLimit.length > 0)
                            ? parseFloat(params.dataMinLimit) : NaN;
                            
                       console.log("maxFixedLimitRT")
                       console.log(maxFixedLimitRT)
                       

                        const maxFixedConditionRT = !isNaN(maxFixedLimitRT) && pointValue > maxFixedLimitRT;
                        const minFixedConditionRT = !isNaN(minFixedLimitRT) && pointValue < minFixedLimitRT;
                        
                         console.log("maxFixedConditionRT")
                       console.log(maxFixedConditionRT)
                   
                        if (maxFixedConditionRT || minFixedConditionRT) {
                            filteredData.Values.push(pointValue);
                            filteredData.status.push(dataPoint.hasOwnProperty('status') ? dataPoint.status : null);
                            filteredData.timestamps.push(dataPoint.hasOwnProperty('timestamps') ? dataPoint.timestamps : null);
                        }
                        
                        console.log("filteredData");
                        console.log(filteredData);
                    } else {
                         this.DCNotfier.dgConsole("WARN: Skipping invalid dataPoint in RealTime processing:", dataPoint);
                    }
                });
                filteredData.DataSize = filteredData.Values.length;
            } else {
                this.DCNotfier.dgConsole("WARN: LastDataPointRT is not an array.");
            }
		}
		
		 else if (this.OperationMode === "RealTime") {
            // --- REALTIME MODE LOGIC (Modified) ---
			 if (!this.informationRTI || !this.informationRTI.LastDataPointRT) {
				this.DCNotfier.dgConsole("WARN: RealTime informationRTI missing or LastDataPointRT undefined.");
				return { filteredData, plotLimitData };
			}

            // --- Retrieve Pre-calculated Limit Info (RT) ---
            const precalculatedInfoRT = this.findPrecalculatedLimitInfo(this.chartConfigI.chartID);
            let rawMaxLimitDataRT = null;
            let rawMinLimitDataRT = null;

             if (precalculatedInfoRT) {
                 // These contain the *current* limit value object: {Value, status, timestamps}
                 rawMaxLimitDataRT = precalculatedInfoRT.rawLimitData[0];
                 rawMinLimitDataRT = precalculatedInfoRT.rawLimitData[1];
                 plotLimitData = precalculatedInfoRT.plotLimitData;
                 this.DCNotfier.dgConsole("Using pre-calculated LimitInfo (RT):", precalculatedInfoRT);
             } else {
                  this.DCNotfier.dgConsole("No pre-calculated LimitInfo found for this chartID (RT). Limit checks involving nodes might fail.");
                  // Initialize plotLimitData to prevent errors if precalculatedInfoRT is null
                  plotLimitData = { MaxLimitTrendData: { Values: [], timestamps: [] }, MinLimitTrendData: { Values: [], timestamps: [] } };
             }

            // --- Filtering Logic (RT) ---
            const fixedMaxLimitValueRT = (params.dataMaxType === "Fixed" && params.dataMaxLimit && typeof params.dataMaxLimit === 'string' && params.dataMaxLimit.length > 0)
                ? parseFloat(params.dataMaxLimit) : NaN;
            const fixedMinLimitValueRT = (params.dataMinType === "Fixed" && params.dataMinLimit && typeof params.dataMinLimit === 'string' && params.dataMinLimit.length > 0)
                ? parseFloat(params.dataMinLimit) : NaN;

            // Current Node Limit Values from precalculated info (New logic)
            const currentMaxLimitValueRT = (rawMaxLimitDataRT && rawMaxLimitDataRT.Value !== null && typeof rawMaxLimitDataRT.Value === 'number' && !isNaN(rawMaxLimitDataRT.Value))
                ? rawMaxLimitDataRT.Value
                : NaN;
            const currentMinLimitValueRT = (rawMinLimitDataRT && rawMinLimitDataRT.Value !== null && typeof rawMinLimitDataRT.Value === 'number' && !isNaN(rawMinLimitDataRT.Value))
                ? rawMinLimitDataRT.Value
                : NaN;
		 
		  console.log("precalculatedInfoRT")
		console.log(precalculatedInfoRT)
		 console.log("rawMaxLimitDataRT")
		console.log(rawMaxLimitDataRT)

            if(Array.isArray(this.informationRTI.LastDataPointRT)){
                this.informationRTI.LastDataPointRT.forEach((dataPoint) => {
                    if (dataPoint && dataPoint.hasOwnProperty('Value')) {
                        const pointValue = dataPoint.Value;
                        let isAboveMaxRT = false;
                        let isBelowMinRT = false;

                        // Max Check (RT - Fixed and Node)
                        if (params.dataMaxType === "Fixed") {
                            // Existing Fixed Check
                            if (!isNaN(fixedMaxLimitValueRT) && pointValue > fixedMaxLimitValueRT) {
                                isAboveMaxRT = true;
                            }
                        } else if (params.dataMaxType === "Node") {
							console.log("pointValue")
							console.log(pointValue)
							
							console.log("currentMaxLimitValueRT")
							console.log(currentMaxLimitValueRT)
                            // New Node Check using current limit value
                            if (!isNaN(currentMaxLimitValueRT) && pointValue > currentMaxLimitValueRT) {
                                isAboveMaxRT = true;
                                this.DCNotfier.dgConsole(`RT Node Max Limit Check: ${pointValue} > ${currentMaxLimitValueRT}`);
                            }
                        }

                        // Min Check (RT - Fixed and Node)
                        if (params.dataMinType === "Fixed") {
                            // Existing Fixed Check
                           if (!isNaN(fixedMinLimitValueRT) && pointValue < fixedMinLimitValueRT) {
                                isBelowMinRT = true;
                           }
                        } else if (params.dataMinType === "Node") {
                             // New Node Check using current limit value
                             if (!isNaN(currentMinLimitValueRT) && pointValue < currentMinLimitValueRT) {
                                 isBelowMinRT = true;
                                 this.DCNotfier.dgConsole(`RT Node Min Limit Check: ${pointValue} < ${currentMinLimitValueRT}`);
                             }
                        }

                        // Add to filteredData if out of limits
                        if (isAboveMaxRT || isBelowMinRT) {
                            filteredData.Values.push(pointValue);
                            filteredData.status.push(dataPoint.hasOwnProperty('status') ? dataPoint.status : null);
                            filteredData.timestamps.push(dataPoint.hasOwnProperty('timestamps') ? dataPoint.timestamps : null);
                        }

                    } else {
                         this.DCNotfier.dgConsole("WARN: Skipping invalid dataPoint in RealTime processing:", dataPoint);
                    }
                });
                filteredData.DataSize = filteredData.Values.length;
            } else {
                this.DCNotfier.dgConsole("WARN: LastDataPointRT is not an array.");
            }
            // --- END REALTIME MODE LOGIC (Modified) ---
		}
		return { filteredData, plotLimitData }; // Return both filtered data and potentially pre-calculated plot data
	}
		   
	// Limit Calculator for Intervals
	limitCalculatorInterval() {
		let filteredData = { Values: [] };
		
		// Iterate through processedDataII.ProcessedData and check limits
		this.processedDataII.ProcessedData.forEach((value, i) => {
			if (value !== null) {
				if ((this.chartConfigI.specialParameters.dataMaxLimit.length > 0 && value >= this.chartConfigI.specialParameters.dataMaxLimit) || 
					(this.chartConfigI.specialParameters.dataMinLimit.length > 0 && value <= this.chartConfigI.specialParameters.dataMinLimit)) {
					filteredData.Values.push(1);
				} else {
					filteredData.Values.push(0);
				}
			} else {
				filteredData.Values.push(null);
			}
		});

		// Add additional attributes
		filteredData.Enabled = this.limitAnalysisEnabledI;
		filteredData.DataSize = filteredData.Values.length;
			
		return { filteredData };
	}
	
	// Limit Calculator for Intervals
	limitCalculatorSingleElement() {
		let filteredData = { Values: [] };
		
		// Iterate through processedDataII.ProcessedData and check limits
		this.processedDataII.ProcessedData.forEach((value, i) => {
			if (value !== null) {
				if ((this.chartConfigI.specialParameters.dataMaxLimit.length > 0 && value >= this.chartConfigI.specialParameters.dataMaxLimit) || 
					(this.chartConfigI.specialParameters.dataMinLimit.length > 0 && value <= this.chartConfigI.specialParameters.dataMinLimit)) {
					filteredData.Values.push(1);
				} else {
					filteredData.Values.push(0);
				}
			} else {
				filteredData.Values.push(null);
			}
		});

		// Add additional attributes
		filteredData.Enabled = this.limitAnalysisEnabledI;
		filteredData.DataSize = filteredData.Values.length;
			
		return { filteredData };
	}

	//----------Interval/Category Functions--------------//
	//--------------------------------------------------//
	
	//Find all unique categories
	uniqueChartCategoriesFinder() {
        const categoriesMap = new Map();
        const isRealTimeMode = this.OperationMode === "RealTime";

        // Analyze each chart configuration and group by unique category settings
        this.dataRequest.chartsConfig.forEach(chartConfig => {
            const {
				chartType,
				elementType,
                categoryType,
                categoryRound,
                categorCustomValue,
                dataReductionEnable,
                dataReductionMaxSize,
                dataoutOfLimitEnable,
                categoryCustomIntervalLength,
                categoryCustomIntervalUnit,
                categoryTimeOffset,
                specialParameters,
                chartID
            } = chartConfig;

            // Find the nodes associated with the chartID
            const chartNodes = this.dataRequest.chartsNodes.find(chart => chart.chartID === chartID)?.chartNodes || [];    

			var informationRT=[];
			
			if(isRealTimeMode){
				
				const informationRTweb =this.dataRequest.updateRequest.find(update => update.chartID === chartID)?.informationRT || [] ;
				
				//informationRT=informationRTweb;
				
				for(var i=0; i<chartNodes.length; i++){
					 //Find the informationRT from the cache
					const infoQuery={chartIDs:[chartID],nodes:[chartNodes[i]]}
					const dataInfoRTweb = informationRTweb.find(info => info.Node === chartNodes[i]); 

					let dataInfoRTquery=this.dashboardCacheManager.queryCacheData(infoQuery,"infoData");

					if(dataInfoRTquery.length>0){
						let dataInfoRTServer=dataInfoRTquery[0].Info[0];
					
						dataInfoRTServer.LastDataPointRT= dataInfoRTweb.LastDataPointRT;
					
						informationRT.push(dataInfoRTServer);
					}				
				}
			
				
		
              

			}		
		

            // Create a key for the category configuration including the nodes (and informationRT if in RealTime mode)
            const categoryKey = JSON.stringify({
				chartType,
				elementType,
                categoryType,
                categoryRound,
                categorCustomValue,
                dataReductionEnable,
                dataReductionMaxSize,
                dataoutOfLimitEnable,
                categoryCustomIntervalLength,
                categoryCustomIntervalUnit,
                categoryTimeOffset,
                specialParameters,
                chartNodes,  // Include nodes in the category key
                ...(isRealTimeMode && { informationRT })  // Conditionally include informationRT in the category key
            });

            if (categoriesMap.has(categoryKey)) {
                categoriesMap.get(categoryKey).chartIDs.push(chartID);
            } else {
                categoriesMap.set(categoryKey, {
                    categoryConfig: {
						chartType,
						elementType,
                        categoryType,
                        categoryRound,
                        categorCustomValue,
                        dataReductionEnable,
						dataReductionMaxSize,
						dataoutOfLimitEnable,
                        categoryCustomIntervalLength,
                        categoryCustomIntervalUnit,
                        categoryTimeOffset,
                        specialParameters,
                        chartNodes,  // Include nodes in the category configuration
                        ...(isRealTimeMode && { informationRT })  // Conditionally include informationRT in the category configuration
                    },
                    chartIDs: [chartID]
                });
            }
        });

        // Convert the map to an array of category configurations
        return Array.from(categoriesMap.values());
    }
	
	//Create All Unique Categories
	uniqueCategoriesCreator() {
	
		this.DCNotfier.dgConsole("----------Creating Categories--------")
		return this.uniqueCategoriesConfig.map(config => {
			
			//Update Current Category Config
			this.uniqueCategoriesConfigI=config;			
			
			//Create Specific Interval
			this.intervalLengthI= this.intevalLengthcreator();
			
			this.DCNotfier.dgConsole("-----------This Interval Length----------");
			this.DCNotfier.dgConsole(this.intervalLengthI);
			
			let chartCategory;
			var intervalInfo;
			
			switch (config.categoryConfig.categoryType) {
				case "AllData-DateTime":  // DateTime
					if(config.categoryConfig.elementType=="Chart"){
						chartCategory=this.allDataCategoryCreator();
						intervalInfo={start:this.dataRequest.updateRequest[0].initialTime,end:this.dataRequest.updateRequest[0].finalTime, newInterval:this.newIntervalI};
					}
					else if(config.categoryConfig.elementType=="Table"){
						chartCategory=this.allDataTableCategoryCreator();
						intervalInfo={start:this.dataRequest.updateRequest[0].initialTime,end:this.dataRequest.updateRequest[0].finalTime, newInterval:this.newIntervalI};
					}					
					break;
				case "Interval-Dynamic": //Dynamic					
					chartCategory = this.intervalCategoryCreator();
					var intervalInfoI=chartCategory.intervals[chartCategory.intervals.length-1];
					intervalInfo={start:intervalInfoI.start,end:intervalInfoI.end, newInterval:this.newIntervalI};
					break;
				case "Interval-CustomInterval": //Custom Interval
					chartCategory = this.intervalCategoryCreator();
					var intervalInfoI=chartCategory.intervals[chartCategory.intervals.length-1];
					intervalInfo={start:intervalInfoI.start,end:intervalInfoI.end, newInterval:this.newIntervalI};				
					break;
				case "Interval-CustomText": //Custom 
					chartCategory = {categories:config.categoryConfig.categorCustomValue};
					intervalInfo={start:this.dataRequest.updateRequest[0].initialTime,end:this.dataRequest.updateRequest[0].finalTime,newInterval:this.newIntervalI};
					break;
				case "Interval-Histogram":  // Histogram
				    chartCategory = this.histogramCategoryCreator();
				    intervalInfo={start:this.dataRequest.updateRequest[0].initialTime,end:this.dataRequest.updateRequest[0].finalTime,newInterval:this.newIntervalI};
				    break;
				case "Single-Simple":  // Simple
					if(config.categoryConfig.elementType=="Chart"){
						if(config.categoryConfig.chartType=="Column"){
							
							chartCategory= { categories: [this.getCategory(this.timeRange,new Date(this.dataRequest.updateRequest[0].initialTime))+" - "+ this.getCategory(this.timeRange,new Date(this.dataRequest.updateRequest[0].finalTime))] };
							intervalInfo={start:this.dataRequest.updateRequest[0].initialTime,end:this.dataRequest.updateRequest[0].finalTime,newInterval:this.newIntervalI};
						}
						else{
							chartCategory= { categories: [] };
							intervalInfo={start:this.dataRequest.updateRequest[0].initialTime,end:this.dataRequest.updateRequest[0].finalTime,newInterval:this.newIntervalI};
						}
				    }
				    else if(config.categoryConfig.elementType=="Table"){
						chartCategory= { categories: [] };
						intervalInfo={start:this.dataRequest.updateRequest[0].initialTime,end:this.dataRequest.updateRequest[0].finalTime, newInterval:this.newIntervalI};
					}
					else{
						chartCategory= { categories: [] };
						intervalInfo={start:this.dataRequest.updateRequest[0].initialTime,end:this.dataRequest.updateRequest[0].finalTime, newInterval:this.newIntervalI};
					}		    
				    break;
				default:
					// Handle other types or do nothing if not applicable
					chartCategory = { categories: [] };
					intervalInfo={start:this.dataRequest.updateRequest[0].initialTime,end:this.dataRequest.updateRequest[0].finalTime,newInterval:this.newIntervalI};
					break;
			}
			
			//Add Interval Length
			intervalInfo["intervalLength"]=this.intervalLengthI;
			
			if (chartCategory) {
				return {
					chartCategory,
					intervalInfo: intervalInfo,
					chartIDs: config.chartIDs
				};
			}
		}).filter(entry => entry !== undefined); // Filter out any undefined entries due to unsupported category types
	}
	
	//Update Category If reduction
    updateChartCategory() {
		if (this.reductionExcecutedI) {
			// Iterate over the categories to find the matching chartNode
			this.chartCategoriesI.chartCategory.categories.forEach(category => {
				if (this.chartConfigI.elementType === "Chart") {
					if (category.chartNode === this.nodeI) {
						category.categories = this.partialDashboardDataI.timestamps;
						this.DCNotfier.dgConsole(`Chart categories for node ${this.nodeI} updated successfully`);
					}
				}
				else if(this.chartConfigI.elementType === "Table") {
					
				}
			}); 
		}
		else {
			this.DCNotfier.dgConsole("Reduction not executed. Chart categories not updated.");
		}
		
	}
		
	//Method to create interval length
	intevalLengthcreator(){			
		
		
		//Dynamic Interval Length	
		if(this.uniqueCategoriesConfigI.categoryConfig.categoryType=="Interval-Dynamic")	{	
			if (this.timeRange <= ONE_MINUTE) {
				return 5 * 1000; // 5 seconds
			} else if (this.timeRange <= HALF_HOUR) {
				return ONE_MINUTE;
			} else if (this.timeRange <= ONE_HOUR) {
				return 5 * ONE_MINUTE;
			} else if (this.timeRange <= ONE_DAY) {
				return ONE_HOUR;
			} else if (this.timeRange <= 31 * ONE_DAY) { // Assuming an average month length
				return ONE_DAY;
			} else if (this.timeRange <= 365 * ONE_DAY) { // Assuming an average year length
				return 'month'; // Dynamic handling for months
			} else {
				return 'year'; // Dynamic handling for years
			}
		}
		
		// Custom Interval Length
		else if(this.uniqueCategoriesConfigI.categoryConfig.categoryType=="Interval-CustomInterval")	{
			const { categoryCustomIntervalLength, categoryCustomIntervalUnit } = this.uniqueCategoriesConfigI.categoryConfig;
			switch (categoryCustomIntervalUnit) {
				case 's':   // seconds
					return categoryCustomIntervalLength * 1000;
					break;
				case 'min': // minutes
					return categoryCustomIntervalLength * 60 * 1000;
					break;
				case 'h':   // hours
					return categoryCustomIntervalLength * 3600 * 1000;
					break;
				case 'day':   // day
					return categoryCustomIntervalLength * 24 * 3600 * 1000;
					break;
				case 'month':   // month
					return categoryCustomIntervalLength * 30 * 24 * 3600 * 1000;
				break;
				default:
					throw new Error('Unsupported interval unit');
			}
		}
		
		//DateTime Interval Length	
		else if(this.uniqueCategoriesConfigI.categoryConfig.categoryType=="AllData-DateTime")	{	
			return this.timeRange; 
		}	
		
		else{	
			return this.timeRange; 
		}	
	}	
	
	//Creates Time Offset
	categoryTimeOffsetCreator() {
		// Read the current unit and offset from the config
		const intervalUnit = this.uniqueCategoriesConfigI.categoryConfig.categoryCustomIntervalUnit;
		const timeOffset = parseInt(this.uniqueCategoriesConfigI.categoryConfig.categoryTimeOffset);
		this.DCNotfier.dgConsole("intervalUnit: "+intervalUnit)
		// Determine the offset unit based on the interval unit
		let offsetUnitMilliseconds;
		switch (intervalUnit) {
			case 's':   // Seconds
				offsetUnitMilliseconds = 1000; // 1 second = 1000 milliseconds
				break;
			case 'min': // Minutes
				offsetUnitMilliseconds = 1000; // 1 minute = 60,000 milliseconds
				break;
			case 'h':   // Hours
				offsetUnitMilliseconds = 1000 * 60; // 1 minute = 60,000 milliseconds
				break;
			case 'day':   // Days
				offsetUnitMilliseconds = 1000 * 60 * 60; // 1 hour = 3,600,000 milliseconds
				break;
			case 'month':   // Months
				offsetUnitMilliseconds = 1000 * 60 * 60 * 24; // 1 day = 86,400,000 milliseconds
			break;
			default:
				throw new Error('Unsupported interval unit');
		}
	
		// Calculate the time offset in milliseconds
		return timeOffset * offsetUnitMilliseconds;
	}
	
	//IntervalLength in Millis
	getIntervalLengthInMillis(timestamp) {
		if (typeof this.intervalLengthI === 'number') {
			return this.intervalLengthI;
		} else if (this.intervalLengthI === 'month') {
			let date = new Date(timestamp);
			let monthLater = new Date(date.getFullYear(), date.getMonth() + 1, date.getDate());
			return monthLater - timestamp;
		} else if (this.intervalLengthI === 'year') {
			let date = new Date(timestamp);
			let yearLater = new Date(date.getFullYear() + 1, date.getMonth(), date.getDate());
			return yearLater - timestamp;
		}
		return 0; // Default fallback if intervalLength is not properly set
	}
	
	//Get Category String
	getCategory(timeRange, num) {
		if (timeRange <= ONE_DAY) {
			return (new Date(num)).toTimeString().split(' ')[0];
		} else if (timeRange <= 31 * ONE_DAY) {
			return (new Date(num)).toDateString().split(' ').slice(1).join(' ');
		} else if (timeRange <= 365 * ONE_DAY) {
			let parts = (new Date(num)).toDateString().split(' ');
			return `${parts[1]} ${parts[3]}`;
		} else {
			return (new Date(num)).getFullYear().toString();
		}
	}	
	
	//All Data Category
	allDataCategoryCreator() {
		const { categoryConfig } = this.uniqueCategoriesConfigI;
		const { chartNodes } = categoryConfig;
		const categoriesData = [];
	
		chartNodes.forEach(node => {
			const rawDataNode = this.rawData.find(data => data.Nodeaddress === node);
	
			if (rawDataNode) {
				categoriesData.push({
					chartNode: node,
					categories: rawDataNode.timestamps
				});
			}
		});
	
		return {categories:categoriesData};
	}
	
	//All Data for Tables		
	allDataTableCategoryCreator() {
		const { categoryConfig } = this.uniqueCategoriesConfigI;
		const allNodes = this.rawData.map(data => data.Nodeaddress); // Extract all Nodeaddresses
		let categoriesData = [];
	
		// Use a Set to efficiently store unique timestamps
		const uniqueTimestamps = new Set();
	
		// Determine the CategorySource
		if (categoryConfig.specialParameters.TableConfig.CategorySource === 'Input-AllInputs') {
			this.DCNotfier.dgConsole("------Input-AllInputs----");
			// Collect timestamps and add them directly to the Set for uniqueness
			this.rawData.forEach(data => {
				data.timestamps.forEach(timestamp => uniqueTimestamps.add(timestamp));
			});
	
			// Convert the Set to an array and sort it only once
			const allTimestampsClean = [...uniqueTimestamps].sort((a, b) => a - b);
	
			// Create the final object with allNodes and clean timestamps
			categoriesData.push({
				chartNode: allNodes,
				categories: allTimestampsClean
			});
	
		} else if (categoryConfig.specialParameters.TableConfig.CategorySource === 'Input-LeadingInput') {
			this.DCNotfier.dgConsole("------Input-LeadingInput----");
			// Get the CategoryLeadingInput
			const leadingInputNode = categoryConfig.specialParameters.TableConfig.CategoryLeadingInput;
			
			this.DCNotfier.dgConsole("leadingInputNode");
			this.DCNotfier.dgConsole(leadingInputNode);
			
			this.DCNotfier.dgConsole( this.rawData);
			// Find the rawData object that corresponds to the leadingInputNode
			const leadingData = this.rawData.find(data => data.Nodeaddress === leadingInputNode);
	
			// If we find the data, use its timestamps
			if (leadingData) {
				leadingData.timestamps.forEach(timestamp => uniqueTimestamps.add(timestamp));
	
				// Convert the Set to an array and sort it once
				const leadingTimestampsClean = [...uniqueTimestamps].sort((a, b) => a - b);
	
				// Create the final object with allNodes and clean timestamps
				categoriesData.push({
					chartNode: allNodes,
					categories: leadingTimestampsClean
				});
			} else {
				console.error(`No data found for leading input node: ${leadingInputNode}`);
			}
		}
		this.DCNotfier.dgConsole("Partial Categories Before Reduction");
		this.DCNotfier.dgConsole("Length: "+categoriesData[0].categories.length);
		this.DCNotfier.dgConsole(categoriesData);
		return { categories: [this.tableCategoryProcessor(categoriesData)]};
	}
	
	//Category Creator	
	intervalCategoryCreator() {

		var Initial_Time=(new Date(this.dataRequest.updateRequest[0].initialTime)).getTime();
		var Final_Time=(new Date(this.dataRequest.updateRequest[0].finalTime)).getTime();
		
		const intervals = [];
		const categories = [];
	
		// Apply rounding if category rounding is enabled
		if (this.uniqueCategoriesConfigI.categoryConfig.categoryRound=== "true") {
			Initial_Time = this.roundDate(Initial_Time,"down").getTime();
		}
		this.DCNotfier.dgConsole("Raw Offset")
		this.DCNotfier.dgConsole(this.uniqueCategoriesConfigI.categoryConfig.categoryTimeOffset);
		//Apply Offset
		if (this.uniqueCategoriesConfigI.categoryConfig.categoryTimeOffset>0 && this.uniqueCategoriesConfigI.categoryConfig.categoryType=="Interval-CustomInterval") {
			this.categoryTimeOffsetI=this.categoryTimeOffsetCreator();
			this.DCNotfier.dgConsole("------------Category Time Offset------------");
			this.DCNotfier.dgConsole(this.categoryTimeOffsetI);
			
			Initial_Time = Initial_Time+this.categoryTimeOffsetI;
		}
		
		let currentTime = new Date(Initial_Time);
		
		while (currentTime.getTime() < Final_Time) {
			let currentEndTime = new Date(currentTime);
	
			if (typeof this.intervalLengthI === 'number') {
				currentEndTime = new Date(currentTime.getTime() + this.intervalLengthI);
			} else if (this.intervalLengthI=== 'month') {
				currentEndTime.setMonth(currentEndTime.getMonth() + 1);
			} else if (this.intervalLengthI === 'year') {
				currentEndTime.setFullYear(currentEndTime.getFullYear() + 1);
			}
	
			// Make sure we don't exceed Final_Time in our last interval
			if (currentEndTime.getTime() > Final_Time) {
				currentEndTime = new Date(Final_Time);
			}
	
			intervals.push({ start: currentTime.getTime(), end: currentEndTime.getTime() });
			categories.push(this.getCategory(this.timeRange, currentTime.getTime()));
	
			// Prepare for the next iteration
			currentTime = currentEndTime;
		}
	
		// Correct the last category if necessary to ensure it represents the end time accurately
		if (categories.length > 0) {
			categories[categories.length - 1] = this.getCategory(this.timeRange, Final_Time);
		}
		return { intervals, categories };
	}      
		
	//Ceates Histogram Category
	histogramCategoryCreator() {
		const { categoryConfig } = this.uniqueCategoriesConfigI;
		const firstNode = categoryConfig.chartNodes[0];
	
		// Find the raw data for the first node
		const rawData = this.rawData.find(data => data.Nodeaddress === firstNode);
	
		if (!rawData) {
			throw new Error(`No raw data found for node ${firstNode}`);
		}
	
		const n = rawData.Values.length;
		const sortedData = rawData.Values.slice().sort((a, b) => a - b); // Copy and sort data
		const q1 = sortedData[Math.floor(n / 4)];
		const q3 = sortedData[Math.floor(3 * n / 4)];
		const iqr = q3 - q1; // Interquartile range
		let binSize;
		let numBins=categoryConfig.specialParameters.HistogramNumberBins; /*this.chartConfigI.specialParameters.HistogramNumberBins;*/ // Get the number of bins from the config if provided
	
		if (numBins === undefined||numBins === null||numBins.length<=0) { // Only if it is not specified
			// Use Freedman-Diaconis Rule to determine bin size if possible
			if (iqr > 0) { // Avoid division by zero in IQR calculations
				binSize = 2 * (iqr / Math.cbrt(n));
				numBins = Math.ceil((sortedData[n - 1] - sortedData[0]) / binSize);
			} else {
				// Fallback to Sturges' formula if IQR is 0
				numBins = Math.ceil(Math.log2(n) + 1);
				binSize = (sortedData[n - 1] - sortedData[0]) / numBins;
			}
		} else {
			// Calculate binSize based on the specified number of bins
			const minData = sortedData[0];
			const maxData = sortedData[sortedData.length - 1];
			binSize = (maxData - minData) / numBins;
		}
	
		const minData = sortedData[0];
		const categories = [];
	
		for (let i = 0; i < numBins; i++) {
			const binMin = minData + i * binSize;
			const binMax = minData + (i + 1) * binSize;
			// Create a string representation for each category/bin
			categories.push(`${binMin.toFixed(2)}-${binMax.toFixed(2)}`);
		}
		
		//Safe for further analisis
		this.HistInfoRTI["categories"]= categories.map(str => str.replace(/ /g, ''));
		this.HistInfoRTI["BinSize"]=binSize;
		
		return { categories: categories };
	}
	
	
	//-------------------Tooltip Functions--------------//
	//--------------------------------------------------//
	
	tooltipInfoCreator(){
	
		let tooltipInfo;
		var intervalInfo=this.chartCategoriesI.intervalInfo;

		
		if(this.chartConfigI.elementType=="Chart"){
			
			//Simple Processing type
			if(this.chartConfigI.dataProcessingType.includes("Simple")) {
				tooltipInfo="";			
			}
			//SinglePoint Processing type
			else if(this.chartConfigI.dataProcessingType.includes("SinglePoint")) {
				tooltipInfo=this.formatTimestampToDateTime(this.relevantTimestampII);		
			}
			//Interval Processing type
			else if(this.chartConfigI.dataProcessingType.includes("Interval")) {
				if (this.updateRequestI.OperationMode === "Hist") {
					if (this.chartConfigI.dataProcessingType!="Interval-Histogram"){
						tooltipInfo = this.chartCategoriesI.chartCategory.intervals.map(interval => ({
						  start: this.formatTimestampToDateTime(interval.start),
						  end: this.formatTimestampToDateTime(interval.end)
						}));
					}		
					else{
						tooltipInfo={start:this.formatTimestampToDateTime(new Date(intervalInfo.start)),
							 end:this.formatTimestampToDateTime(new Date(intervalInfo.end))};
					}
				}
				else if (this.updateRequestI.OperationMode === "RealTime") {
					if (this.chartConfigI.dataProcessingType!="Interval-Histogram"){
						var interval=this.chartCategoriesI.chartCategory.intervals[0];
						tooltipInfo={
									start:this.formatTimestampToDateTime(interval.start),
									end:this.formatTimestampToDateTime(interval.end)
									};
						}
					else{
						tooltipInfo={start:this.formatTimestampToDateTime(this.informationRTI.LastRelevantTimestamp),
							 end:this.formatTimestampToDateTime(new Date(intervalInfo.end))};
					}
				}
			}
			//FullRange Processing type
			else if(this.chartConfigI.dataProcessingType.includes("FullRange")) {
				if (this.updateRequestI.OperationMode === "Hist") {
					tooltipInfo={start:this.formatTimestampToDateTime(new Date(intervalInfo.start)),
							 end:this.formatTimestampToDateTime(new Date(intervalInfo.end))};
							 
					this.relevantTimestampII=new Date(intervalInfo.start).getTime();
				}
				else if (this.updateRequestI.OperationMode === "RealTime") {
					tooltipInfo={start:this.formatTimestampToDateTime(this.informationRTI.LastRelevantTimestamp),
							 end:this.formatTimestampToDateTime(new Date(intervalInfo.end))};
					this.relevantTimestampII=new Date(this.informationRTI.LastRelevantTimestamp).getTime();
				}
							
			}
			//Any other
			else {
				tooltipInfo="";			
			}
		
		return {tooltipInfo:tooltipInfo, name:this.nodeI}
		}
	
	}	
	
	//---------------RT Processing Functions----------------//
	//--------------------------------------------------//
	
		
	
	//Create Categories for RT
	uniqueCategoriesCreatorRT() {
        this.DCNotfier.dgConsole("----------Creating Categories for RT--------");

        return this.uniqueCategoriesConfigRT.map(config => {
        
            // Update Current Category Config
            this.uniqueCategoriesConfigI = config;

            let chartCategory;
            let intervalInfo = config.categoryConfig.informationRT[0].IntervalInfo;
            
            // Create Specific Interval
            this.intervalLengthI =intervalInfo.intervalLength;
            this.DCNotfier.dgConsole("-----------This Interval Length----------");
            this.DCNotfier.dgConsole(this.intervalLengthI);
            
            switch (config.categoryConfig.categoryType) {
                case "AllData-DateTime":  // DateTime
					if(config.categoryConfig.elementType=="Chart"){
						chartCategory = this.allDataCategoryCreatorRT();
						intervalInfo = this.allDataIntervalInfoRT();
                    }
                    else if(config.categoryConfig.elementType=="Table"){
						//chartCategory=this.allDataTableCategoryCreatorRT();
						chartCategory=this.allDataCategoryCreatorRT();
						intervalInfo={start:this.dataRequest.updateRequest[0].initialTime,end:this.dataRequest.updateRequest[0].finalTime, newInterval:this.newIntervalI};
					}	
                    break;
                case "Interval-Dynamic": // Dynamic
                    chartCategory = this.intervalCategoryCreatorRT();
                    var intervalInfoI=chartCategory.intervals[0];
                    intervalInfo={start:intervalInfoI.start,end:intervalInfoI.end, newInterval:this.newIntervalI};
                    break;
                case "Interval-CustomInterval": // Custom Interval
                    chartCategory = this.intervalCategoryCreatorRT();
                    var intervalInfoI=chartCategory.intervals[0];
                    intervalInfo={start:intervalInfoI.start,end:intervalInfoI.end, newInterval:this.newIntervalI};
                    break;
                case "Interval-CustomText": // Custom
                    chartCategory = { categories: config.categoryConfig.categorCustomValue.split(',') };
                    intervalInfo = { start: intervalInfo.start, end: intervalInfo.end };
                    break;
                case "Interval-Histogram":  // Histogram
                    chartCategory = this.histogramCategoryCreatorRT();
                    intervalInfo = this.allDataIntervalInfoRT();
                    break;
                case "Single-Simple":  // Simple
					if(config.categoryConfig.elementType=="Chart"){
						if(config.categoryConfig.chartType=="Column"){
							const { informationRT } = this.uniqueCategoriesConfigI.categoryConfig;
							let highestTimestamp = 0;
							let correspondingIntervalInfo = null;
					
							// Find the highest timestamp and corresponding interval info
							informationRT.forEach(info => {
								info.LastDataPointRT.forEach(point => {
									if (point.timestamps > highestTimestamp) {
										highestTimestamp = point.timestamps;
										correspondingIntervalInfo = info.IntervalInfo;
									}
								});
							});
							
							chartCategory= { categories: [this.getCategory(this.timeRange,new Date(this.dataRequest.updateRequest[0].initialTime))+" - "+ this.getCategory(this.timeRange,new Date(highestTimestamp))] };
							intervalInfo=this.allDataIntervalInfoRT();
						}
						else{
							chartCategory = { categories: [] };
							intervalInfo = this.allDataIntervalInfoRT();
						}
				    }
                    
                    break;
                default:
                    // Handle other types or do nothing if not applicable
                    chartCategory = { categories: [] };
                    intervalInfo = this.allDataIntervalInfoRT();
                    break;
            }

            // Add Interval Length
            intervalInfo["intervalLength"] = this.intervalLengthI;

            return {
                chartCategory,
                intervalInfo: intervalInfo,
                chartIDs: config.chartIDs
            };
        }).filter(entry => entry !== undefined); // Filter out any undefined entries due to unsupported category types
    }
    
    //Creates Categories for allDataTypes
    allDataCategoryCreatorRT() {

        const { chartNodes, informationRT } = this.uniqueCategoriesConfigI.categoryConfig;
        const categoriesData = [];
		
        chartNodes.forEach(node => {
            const infoRTNode = informationRT.find(info => info.Node === node);

            if (infoRTNode) {
				if( infoRTNode.LastDataPointRT.length>0){
					categoriesData.push({
						chartNode: node,
						categories: infoRTNode.LastDataPointRT.map(point => point.timestamps)
					});
                }	
				else{
					categoriesData.push({
						chartNode: node,
						categories: []
					});
				}
            }
            
        });

        return { categories: categoriesData };
    }
        
    //Calculate Interval Info 
    allDataIntervalInfoRT() {
        const { informationRT } = this.uniqueCategoriesConfigI.categoryConfig;
        
        let highestTimestamp = 0;

        informationRT.forEach(info => {
            info.LastDataPointRT.forEach(point => {
                if (point.timestamps > highestTimestamp) {
                    highestTimestamp = point.timestamps;
                }
            });
        });

        const intervalInfo = {
            start: highestTimestamp - this.intervalLengthI,
            end: highestTimestamp,
            newInterval:false
        };

        return intervalInfo;
    }
    
    //Create Interval Category RT
    intervalCategoryCreatorRT() {
        const { informationRT } = this.uniqueCategoriesConfigI.categoryConfig;
        let highestTimestamp = 0;
        let correspondingIntervalInfo = null;

        // Find the highest timestamp and corresponding interval info
        informationRT.forEach(info => {
            info.LastDataPointRT.forEach(point => {
                if (point.timestamps > highestTimestamp) {
                    highestTimestamp = point.timestamps;
                    correspondingIntervalInfo = info.IntervalInfo;
                }
            });
        });

        if (!correspondingIntervalInfo) {
            throw new Error('No valid IntervalInfo found in informationRT');
        }

        let newIntervalI = false;
        const { start, intervalLength } = correspondingIntervalInfo;
        const calculatedStart = highestTimestamp - intervalLength;

        if (start +1000 < calculatedStart) {

            newIntervalI = true;
            this.newIntervalI=newIntervalI;
        }
        else{
			 newIntervalI = false;
            this.newIntervalI=newIntervalI;
        }        

        const intervals = newIntervalI
            ? [{ start: new Date(start).getTime() + intervalLength, end: highestTimestamp }]
            : [{ start: new Date(start).getTime(), end: highestTimestamp }];

        const categories = [this.getCategory(this.timeRange, highestTimestamp)];

        return { intervals, categories };
    }
    
    //Create Interval Category RT
    histogramCategoryCreatorRT() {
		this.DCNotfier.dgConsole("Creating Histogram Category RT");
		this.DCNotfier.dgConsole(this.uniqueCategoriesConfigI);
		const { informationRT } = this.uniqueCategoriesConfigI.categoryConfig;
		const histInfo = informationRT[0].HistInfo;
		const { BinSize, categories } = histInfo;
	
		let newCategories = [...categories]; // Start with existing categories
		let initialTailAdded = false;
		let finalTailAdded = false;
	
		informationRT[0].LastDataPointRT.forEach(dataPoint => {
			let pointInBin = false;
	
			// Recalculate bins after each iteration
			let bins = newCategories.map(category => {
				const parts = category.split('-');
				return {
					min: parseFloat(parts[0]),
					max: parseFloat(parts[1])
				};
			});
	
			bins.forEach(bin => {
				if (dataPoint.Value >= bin.min && dataPoint.Value < bin.max) {
					pointInBin = true;
				}
			});
	
			if (!pointInBin) {
				// Add bins at the beginning until the data point fits into a bin
				while (dataPoint.Value < bins[0].min) {
					const initialTail = `${(bins[0].min - BinSize).toFixed(2)}-${bins[0].min.toFixed(2)}`;
					if (!newCategories.includes(initialTail)) {
						newCategories.unshift(initialTail);
						initialTailAdded = true;
					}
					// Recalculate bins to include the new initial tail
					bins = newCategories.map(category => {
						const parts = category.split('-');
						return {
							min: parseFloat(parts[0]),
							max: parseFloat(parts[1])
						};
					});
				}
	
				// Add bins at the end until the data point fits into a bin
				while (dataPoint.Value >= bins[bins.length - 1].max) {
					const finalTail = `${bins[bins.length - 1].max.toFixed(2)}-${(bins[bins.length - 1].max + BinSize).toFixed(2)}`;
					if (!newCategories.includes(finalTail)) {
						newCategories.push(finalTail);
						finalTailAdded = true;
					}
					// Recalculate bins to include the new final tail
					bins = newCategories.map(category => {
						const parts = category.split('-');
						return {
							min: parseFloat(parts[0]),
							max: parseFloat(parts[1])
						};
					});
					
				}
			}
		});
		
		this.HistInfoRTI["categories"]= newCategories.map(str => str.replace(/ /g, ''));
		this.HistInfoRTI["BinSize"]=BinSize;			
		
		if (initialTailAdded || finalTailAdded) {
			this.newIntervalI = true;
			return { categories: newCategories };
		}
	
		return { categories: categories.map(str => str.replace(/ /g, '')) };
	}
    	
	//Function to Create Data for RT
	dataInfoRTCreator() {
		try {
		
			// Handle All data Required
			let allDataRequired = false;
			
			if (this.chartConfigI.dataProcessingType === "SinglePoint-FirstValue") {
				allDataRequired = true;
			}		
			
			//Defined LastDataPointRaw based on Operation Mode
			var LastDataPointRaw;

			//Hist Mode
			if (this.updateRequestI.OperationMode==="Hist"){
				if (this.rawDataI!=undefined){
					LastDataPointRaw={
						Value: this.rawDataI.Values[this.rawDataI.DataSize - 1],
						status: this.rawDataI.status[this.rawDataI.DataSize - 1],
						timestamps: this.rawDataI.timestamps[this.rawDataI.DataSize - 1]
					}
				}
				else {
					LastDataPointRaw={};		
				}
			
			}	
			//Real Time Mode
			else if (this.updateRequestI.OperationMode==="RealTime"){
				if(this.informationRTI.LastDataPointRT.length>0 ){
					LastDataPointRaw=this.informationRTI.LastDataPointRT[this.informationRTI.LastDataPointRT.length - 1];
				}
				else{
					LastDataPointRaw={};
				}
			}
			
		
			return {
				  informationRTIServer:{
					  chartID:this.chartConfigI.chartID,
					  DataPType:this.chartConfigI.dataProcessingType,
					  Info: [{
							Node: this.nodeI,
							LastDataPointRT: 0,
							LastDataPointProcessed: (this.processedDataII.ProcessedData.length > 0) ? this.getLastNonNullElement(this.processedDataII.ProcessedData).element : 0,							
							LastDataPointRaw:LastDataPointRaw,
							AllDataRequired: allDataRequired,
							IntervalInfo: this.chartCategoriesI.intervalInfo,
							ReduceInfo: {
								reductionStepSize: this.reductionStepSizeI,
								reductioniterationsBeforeNextStepRT: this.reductionreductioniterationsBeforeNextStepRTI
							},
							OEEInfo:JSON.parse(JSON.stringify(this.OEEinfoRTI)),
							HistInfo:this.HistInfoRTI,
							LastRelevantTimestamp:this.relevantTimestampII
					}]
				},
				informationRTIWeb:{
					Node: this.nodeI,
					LastDataPointRT: 0,
					LastDataPointRaw:LastDataPointRaw,
					IntervalInfo: this.chartCategoriesI.intervalInfo,			
				}
			};
			
			
		} catch (error) {
			console.error("Error in dataInfoRTCreator: ", error.message);
			console.error(error.message);
			return null; // or handle the error appropriately
		}
	}
	
	//EntersRT Info into cache
	dataInfoRTCacheStore() {
	
		// Retrieve existing cache data for key "infoData".
		let checkedCacheData = this.dashboardCacheManager.checkCacheData("infoData");
		this.DCNotfier.dgConsole("checkedCacheData Before Update");
		this.DCNotfier.dgConsole(checkedCacheData);
				
		
		
		// If there's no data in the cache (length === 0),
		if (checkedCacheData.length === 0) {
			this.DCNotfier.dgConsole("Fetched all infoRT data due to empty cache.");
			this.dashboardCacheManager.initialize([this.DataInfoRTIServer], "infoData");
			return;
		}	
		else {

			//Update cache
			this.dashboardCacheManager.updateCacheData(this.DataInfoRTIServer, "infoData");	
			let newcheckedCacheData = this.dashboardCacheManager.checkCacheData("infoData");
			this.DCNotfier.dgConsole("newcheckedCacheData");
			this.DCNotfier.dgConsole(newcheckedCacheData);				
		}
		
	}
	
	//Updates Cache data Cross Series
	dataInfoRTCacheCrossSeriesUpdater(type) {
		if (type === "newInterval") {
			// Step 1: Extract chartIDs and their corresponding intervalStart into an array of objects
			let chartIDInfo = []; // Array to hold chartID and intervalStart pairs
	
			this.uniqueCategoriesRT.forEach((category) => {
				if (category.intervalInfo?.newInterval === true) {
					category.chartIDs.forEach((chartID) => {
						chartIDInfo.push({ chartID, intervalStart: category.intervalInfo.start });
					});
				}
			});
	
			// If no chartIDs are found, exit the function
			if (chartIDInfo.length === 0) {
				this.DCNotfier.dgConsole("No newInterval found in uniqueCategoriesRT.");
				return;
			}
	
			// Step 2: Update elements in checkedCacheData based on chartIDInfo
			let checkedCacheData = this.dashboardCacheManager.checkCacheData("infoData");

			let DataInfoRTE = [];
	
	
			checkedCacheData.forEach((element) => {
				// Check if the element's chartID is in chartIDInfo
				const match = chartIDInfo.find((info) => info.chartID === element.chartID);
				if (match) {
					const intervalStart = match.intervalStart;
	
					// Update Info elements in this chartID
					element.Info.forEach((info) => {
						info.LastDataPointProcessed = 0; // Reset LastDataPointProcessed to 0
						info.IntervalInfo.start = intervalStart; // Update IntervalInfo.start
						
						// Add the updated element to DataInfoRTE
						DataInfoRTE.push({
							DataPType: element.DataPType,
							Info: [info],
							chartID: element.chartID,
						});
					});	
					
	
					// Add the updated element to DataInfoRTE
					DataInfoRTE.push({
						DataPType: element.DataPType,
						Info: element.Info,
						chartID: element.chartID,
					});
				}
			});
	
			// Step 3: Update the cache with the modified elements
			DataInfoRTE.forEach((item) => {
				this.dashboardCacheManager.updateCacheData(item, "infoData");
			});
	
			// Step 4: Verify the updated cache
			let checkedCacheDataAfter = this.dashboardCacheManager.checkCacheData("infoData");
			this.DCNotfier.dgConsole("checkedCacheData after new Interval:");
			this.DCNotfier.dgConsole(checkedCacheDataAfter);
		}
	}

	//Function to find all RTInfo
	dataInfoRTFinder() {
        const node = this.nodeI;
        const updateRequest = this.updateRequestI;
        
        // Find the informationRT object that corresponds to this.nodeI
       const dataInfoRT = updateRequest.informationRT.find(info => info.Node === node); 
       const index = updateRequest.informationRT.findIndex(info => info.Node === node);       

        
        //Find the informationRT from the cache
        let infoQuery={chartIDs:[this.chartConfigI.chartID],nodes:[ this.nodeI]}

        let dataInfoRTquery=this.dashboardCacheManager.queryCacheData(infoQuery,"infoData");
        let dataInfoRTServer=dataInfoRTquery[0].Info[0];
        
        //If LastDataPointRT comming from Web is different than empty
        if (Object.keys(dataInfoRT.LastDataPointRT[0]).length > 0){
			//Take only LastDataPointRT from webclient
			dataInfoRTServer.LastDataPointRT=dataInfoRT.LastDataPointRT;
        }
        //If it is empty then use the previos existing value
        else {
			dataInfoRTServer.LastDataPointRT=[dataInfoRTServer.LastDataPointRaw];
			this.updateRequestI.informationRT[index].LastDataPointRT=[dataInfoRTServer.LastDataPointRaw];

        }
              
       if (dataInfoRTServer) {
            this.DCNotfier.dgConsole(`DataInfoRT found for node ${node}:`);
            this.DCNotfier.dgConsole(dataInfoRTServer);
            return dataInfoRTServer;
        } else {
            this.DCNotfier.dgConsole(`No DataInfoRT found for node ${node}`);
            return null;
        }
    }
    
    dataInfoRTFinderbyID(processingtype, ID) {
		try {
			// Retrieve existing cache data for key "infoData".
			let checkedCacheData = this.dashboardCacheManager.checkCacheData("infoData");
	
			// Filter elements by processingtype.
			let filteredData = checkedCacheData.filter(item => item.DataPType === processingtype);
	
			// Further filter if processingtype contains 'OEE'
			if (processingtype.includes("OEE")) {
				filteredData = filteredData.map(item => {
					// Filter Info elements where OEEID matches the input ID parameter
					const matchingInfo = item.Info.filter(info => info.OEEInfo?.OEEID === ID);
					return matchingInfo.length > 0 ? matchingInfo : null;
				}).flat(); // Flatten to get individual Info objects.
			} else {
				// For non-OEE processingtype, retain all Info elements.
				filteredData = filteredData.map(item => item.Info).flat();
			}
	
			// Remove null or undefined entries (in case no OEEID matched).
			filteredData = filteredData.filter(info => info !== null);
	
			// Return the filtered data or an empty array if no match.
			if (filteredData.length > 0) {
				this.DCNotfier.dgConsole(`Matching Info found:`, filteredData);
				return filteredData;
			} else {
				this.DCNotfier.dgConsole("No matching Info found.");
				return [];
			}
	
		} catch (error) {
			console.error("Error in dataInfoRTFinderbyID: ", error.message);
			return [];
		}
	}
	
	//Conditioner to update dataInfoRTweb with empty RTdata
	dataInfoRTWebConditioner() {

		if (!this.dataRequest || !this.dataRequest.updateRequest) {
			console.error("dataRequest or updateRequest is undefined.");
			return;
		}
	
		// Iterate through each updateRequest
		this.dataRequest.updateRequest.forEach((updateRequest) => {
			// Ensure informationRT exists
			if (!updateRequest.informationRT || !Array.isArray(updateRequest.informationRT)) {
				console.warn(`No informationRT array found for chartID: ${updateRequest.chartID}`);
				return;
			}
	
			// Process each informationRT item
			updateRequest.informationRT.forEach((infoRT) => {
			
				// Check if LastDataPointRT is empty
				if (!infoRT.LastDataPointRT || Object.keys(infoRT.LastDataPointRT[0]).length === 0) {
					
					this.DCNotfier.dgConsole("Updating empty LastDataPointRT");
					const chartID = updateRequest.chartID;
					const chartNode = infoRT.Node;
	
					if (!chartID || !chartNode) {
						console.error("chartID or chartNode is missing.", { chartID, chartNode });
						return;
					}
	
					// Create the query object
					const infoQuery = { chartIDs: [chartID], nodes: [chartNode] };
	
					// Query the cache for data
					const dataInfoRTquery = this.dashboardCacheManager.queryCacheData(infoQuery, "infoData");
					
					if (!dataInfoRTquery || dataInfoRTquery.length === 0 || !dataInfoRTquery[0].Info || dataInfoRTquery[0].Info.length === 0) {
						console.warn(`No cached data found for chartID: ${chartID}, node: ${chartNode}`);
						return;
					}
	
					// Extract the server data
					const dataInfoRTserver = dataInfoRTquery[0].Info[0];
					if (!dataInfoRTserver || !dataInfoRTserver.LastDataPointRaw) {
						console.warn(`No LastDataPointRaw found in cached data for chartID: ${chartID}, node: ${chartNode}`);
						return;
					}
					
	
					// Update LastDataPointRT with the cached LastDataPointRaw
					infoRT.LastDataPointRT[0] = dataInfoRTserver.LastDataPointRaw;
				}
			});
		});
	}
	
	//---------------Chart Processing Functions----------------//
	//--------------------------------------------------//
	//--------------------------------------------------//
	
	//---------------Single Point Functions----------------//
	
	//Calculates Last Value
	SinglePoint_lastValue(rawData) {
		let lastValidValue = null;
		if (this.updateRequestI.OperationMode==="Hist"){
			// Iterate from end to start
			for (let i = rawData.Values.length - 1; i >= 0; i--) {
				if (rawData.status[i] === 0) {
					lastValidValue = rawData.Values[i];
					break;
				}
			}
			this.relevantTimestampII=rawData.timestamps[rawData.Values.length-1];
		}
		
		if (this.updateRequestI.OperationMode==="RealTime"){
		
			var LastDataPointRTI=this.informationRTI.LastDataPointRT;
			// Iterate from end to start
			for (let i = LastDataPointRTI.length - 1; i >= 0; i--) {
				if (LastDataPointRTI[i].status === 0) {
					lastValidValue = LastDataPointRTI[i].Value;
					this.DCNotfier.dgConsole("lastValidValue: ");
					this.DCNotfier.dgConsole(LastDataPointRTI[i]);
					this.relevantTimestampII=LastDataPointRTI[i].timestamps;
					
					break;
				}
			}
		}
		// Return the last valid value
		return { ProcessedData: [lastValidValue ?? 0] };  // Default to 0 if no valid values found
	}
	
	//Bring First Value
	SinglePoint_firstValue(rawData) {
		let firstValidValue = null;
	
		// Iterate from start to end
		for (let i = 0; i < rawData.Values.length; i++) {
			if (rawData.status[i] === 0) {
				firstValidValue = rawData.Values[i];
				break;
			}
		}
	
		// Return the first valid value
		return { ProcessedData: [firstValidValue ?? 0] };  // Default to 0 if no valid values found
	}	
	
	//Bring Max Value
	SinglePoint_Max(rawData) {
		let maxValidValue = null;
		let maxTimestamp = null;  // Variable to store the timestamp corresponding to max value

		if (this.updateRequestI.OperationMode === "Hist") {
			// Loop through the values and statuses to find the max value where status is 0
			for (let i = 0; i < rawData.Values.length; i++) {
				if (rawData.status[i] === 0) {
					if (maxValidValue === null || rawData.Values[i] > maxValidValue) {
						maxValidValue = rawData.Values[i];
						maxTimestamp = rawData.timestamps[i];  // Store the corresponding timestamp
					}
				}
			}
			
			//Update category
			this.relevantTimestampII=maxTimestamp;

		}
				
		else if (this.updateRequestI.OperationMode === "RealTime") {
			var LastDataPointRTI=this.informationRTI.LastDataPointRT;
			maxValidValue=this.informationRTI.LastDataPointProcessed;
			maxTimestamp=this.informationRTI.LastRelevantTimestamp;
			
			// Iterate from end to start
			for (let i = LastDataPointRTI.length - 1; i >= 0; i--) {				
				if (LastDataPointRTI[i].status === 0) {
					if (maxValidValue === null || LastDataPointRTI[i].Value > maxValidValue) {
						maxValidValue = LastDataPointRTI[i].Value;
						maxTimestamp = LastDataPointRTI[i].timestamps;  // Store the corresponding timestamp
						
						//Update category
						this.chartCategoriesI.chartCategory.categories.push(maxTimestamp);				
						this.DCNotfier.dgConsole("New Max value: "+maxValidValue);
					}
				}				
			}
			
			//Update Relevant Timestamp
			this.relevantTimestampII=maxTimestamp;
			
		}
		
		// If no valid values were found, set default to 0
		if (maxValidValue === null) {
			maxValidValue = 0;
		}
	
		return { ProcessedData: [maxValidValue] };  // Return the max value
	}
	
	//Bring Min Value
	SinglePoint_Min(rawData) {
		let minValidValue = null;
		let minTimestamp = null;  // Variable to store the timestamp corresponding to min value
	
		if (this.updateRequestI.OperationMode === "Hist") {
			// Loop through the values and statuses to find the min value where status is 0
			for (let i = 0; i < rawData.Values.length; i++) {
				if (rawData.status[i] === 0) { // Valid status check
					if (minValidValue === null || rawData.Values[i] < minValidValue) {
						minValidValue = rawData.Values[i];
						minTimestamp = rawData.timestamps[i];  // Store the corresponding timestamp
					}
				}
			}
			
			//Update Relevant Timestamp
			this.relevantTimestampII=minTimestamp;
	
		} 
		else if (this.updateRequestI.OperationMode === "RealTime") {
			var LastDataPointRTI = this.informationRTI.LastDataPointRT;
			minValidValue = this.informationRTI.LastDataPointProcessed;
			minTimestamp=this.informationRTI.LastRelevantTimestamp;
			
			// Iterate from end to start for real-time data
			for (let i = LastDataPointRTI.length - 1; i >= 0; i--) {
				if (LastDataPointRTI[i].status === 0) {
					if (minValidValue === null || LastDataPointRTI[i].Value < minValidValue) {
						minValidValue = LastDataPointRTI[i].Value;
						minTimestamp = LastDataPointRTI[i].timestamps;  // Store the corresponding timestamp
						this.DCNotfier.dgConsole("New Min value: " + minValidValue);
					}
				}
			}
			
			//Update Relevant Timestamp
			this.relevantTimestampII=minTimestamp;
		}
	
		// If no valid values were found, set default to 0
		if (minValidValue === null) {
			minValidValue = 0;
		}
	
		return { ProcessedData: [minValidValue], minTimestamp: minTimestamp };  // Return the min value and its timestamp
	}
	
	//---------------Full Range Functions----------------//
	
	// Sums all data from rawData
	FullRange_Addition(rawData) {
		if (this.OperationMode === "Hist") {
			let sum = 0;
			// Iterate through the rawData.Values and sum values where rawData.status is 0
			rawData.Values.forEach((value, index) => {
				if (rawData.status[index] === 0) {
					sum += value;
				}
			});
		
			return { ProcessedData: [sum] };
		} else if (this.OperationMode === "RealTime") {
			let sum = this.informationRTI.LastDataPointProcessed;
	
			this.informationRTI.LastDataPointRT.forEach(dataPoint => {
				if (dataPoint.status === 0) {
					sum += dataPoint.Value;
				}
			});
	
			return { ProcessedData: [sum] };
		}
	}
	
	//Full Range Average
	FullRange_Average(rawData) {
		let sum = 0;
		let count = 0;
	
		if (this.OperationMode === "Hist") {
			// Iterate through rawData in a single pass
			for (let i = 0; i < rawData.Values.length; i++) {
				if (rawData.status[i] === 0) {  // Only consider valid data points
					sum += rawData.Values[i];
					count++;
				}
			}
	
			// Calculate the average, avoiding division by zero
			const average = count > 0 ? sum / count : null;
	
			return { ProcessedData: [average] };
		} else if (this.OperationMode === "RealTime") {
			// For real-time mode, handle incremental updates
			sum = this.informationRTI.LastDataPointProcessed || 0;
			count = this.informationRTI.LastDataPointRT.length || 0;
	
			// Reset if a new interval starts
			if (this.chartCategoriesI.intervalInfo.newInterval) {
				this.informationRTI.LastDataPointProcessed = 0;
				sum = 0;
				count = 0;
			}
	
			// Process real-time data points
			this.informationRTI.LastDataPointRT.forEach(dataPoint => {
				if (dataPoint.status === 0) {
					sum += dataPoint.Value;
					count++;
				}
			});
	
			// Update the processed data for future use
			this.informationRTI.LastDataPointProcessed = sum;
	
			// Calculate the average, avoiding division by zero
			const average = count > 0 ? sum / count : null;
	
			return { ProcessedData: [average] };
		}
	}
	
	//Full Range Integration No Filter
    FullRange_Integration(rawData,informationRTI,Tunit, NoValidranges) {
		this.DCNotfier.dgConsole("-------------FullRange_Integration--------------");

		try {
			// Get the unit conversion factor to convert U/{unit} to U/ms
			const unitConversionFactor = (() => {
				switch (Tunit) {
					case 's': return 1 / 1000; // U/s to U/ms
					case 'min': return 1 / (60 * 1000); // U/min to U/ms
					case 'h': return 1 / (3600 * 1000); // U/h to U/ms
					case 'day': return 1 / (24 * 3600 * 1000); // U/day to U/ms
					case 'month': return 1 / (30 * 24 * 3600 * 1000); // U/month to U/ms
					default:
						throw new Error(`Unsupported dataPrTUnit: ${Tunit}`);
				}
			})();
	
			if (this.OperationMode === "Hist") {
				// Historical Mode
				let integratedValue = 0;
	
				// Get the final time from the update request
				const initialTime = new Date(this.updateRequestI.initialTime).getTime();
				const finalTime = new Date(this.updateRequestI.finalTime).getTime();
				
				if (rawData.Values.length>1){ //More than one dataPoint
				
					// Iterate through the timestamps and calculate the integration
					for (let i = 0; i < rawData.timestamps.length; i++) {
						const currentValue = rawData.Values[i];
						let currentTimestamp = rawData.timestamps[i];
						let nextTimestamp;
						let previousTimestamp=initialTime;						
		
						var timeDifference;
						
						// Use the finalTime for the last iteration
						if (i === rawData.timestamps.length - 1) {
							nextTimestamp = finalTime;
							timeDifference = nextTimestamp - currentTimestamp;
						}//First iteration
						else if (i === 0){
							nextTimestamp = rawData.timestamps[i + 1];
							currentTimestamp=previousTimestamp;
							timeDifference = nextTimestamp - currentTimestamp;
						}
						 else {
							nextTimestamp = rawData.timestamps[i + 1];
							timeDifference = nextTimestamp - currentTimestamp;
						}
						
						this.DCNotfier.dgConsole("--------------currentTimestamp--------------");
						this.DCNotfier.dgConsole(new Date (currentTimestamp).toLocaleString());
						this.DCNotfier.dgConsole("--------------nextTimestamp--------------");
						this.DCNotfier.dgConsole(new Date (nextTimestamp).toLocaleString());
						
						this.DCNotfier.dgConsole("--------------Time Difference--------------");
						this.DCNotfier.dgConsole(timeDifference);
						this.DCNotfier.dgConsole("--------------currentValue--------------");
						this.DCNotfier.dgConsole(currentValue);
	
		
						// Multiply the current value (converted to U/ms) by the time difference (in ms)
						integratedValue += currentValue * unitConversionFactor * timeDifference;					
						
						this.DCNotfier.dgConsole("--------------integratedValue--------------");
						this.DCNotfier.dgConsole(integratedValue);
					}			
				}
				else if(rawData.Values.length<=1){
						
						const timeDifference = finalTime - initialTime;
						
						//Constant Speed the whole interval of analysis
						integratedValue = rawData.Values[0] * unitConversionFactor * timeDifference;
						
						this.DCNotfier.dgConsole("--------------Time Difference--------------");
						this.DCNotfier.dgConsole(timeDifference);
						
					}
					this.DCNotfier.dgConsole("--------------New Integration Value------------");
					this.DCNotfier.dgConsole(integratedValue);
	
				return { ProcessedData: [integratedValue] };
			} else if (this.OperationMode === "RealTime") {
				// Real-Time Mode
				const previousIntegration = informationRTI.LastDataPointProcessed || 0;
				const LastDataPointRaw={...informationRTI.LastDataPointRaw};
				const previousTimestamp=LastDataPointRaw.timestamps;
				let newIntegration = 0;
	
				// Iterate through LastDataPointRT points
				const realTimePoints = [...informationRTI.LastDataPointRT];
	
				if (!Array.isArray(realTimePoints) || realTimePoints.length === 0) {
					throw new Error("No valid LastDataPointRT available for RealTime processing.");
				}
	
				// Process each real-time point
				for (let i = 0; i < realTimePoints.length; i++) {
					const currentPoint = realTimePoints[i];
					var currentTimestamp = currentPoint.timestamps;
					const currentValue = currentPoint.Value;
					let  nextTimestamp;
	
					if (i < realTimePoints.length - 1) {
						nextTimestamp = realTimePoints[i + 1].timestamps;
					} else {
						nextTimestamp = realTimePoints[i].timestamps;
					}
					
					//const timeDifference = nextTimestamp - currentTimestamp;
					var timeDifference;
					if (i==0){
						currentTimestamp=previousTimestamp;
						timeDifference=nextTimestamp-currentTimestamp;
					}
					else{
							timeDifference=nextTimestamp-currentTimestamp;
					}


	
					// Multiply the current value (converted to U/ms) by the time difference (in ms)
					newIntegration += currentValue * unitConversionFactor * timeDifference;
					
			
					this.DCNotfier.dgConsole("--------------Time Difference--------------");
					this.DCNotfier.dgConsole(timeDifference);
					this.DCNotfier.dgConsole("--------------New Integration Value------------");
					this.DCNotfier.dgConsole(newIntegration);
				}
				
				
				// Calculate the total new integration value
				const totalNewIntegration = previousIntegration + newIntegration;
	
				return { ProcessedData: [totalNewIntegration] };
			} else {
				throw new Error(`Unsupported OperationMode: ${this.OperationMode}`);
			}
		} catch (error) {
			console.error("Error in FullRange_Integration_Filtered: ", error.message);
			return { ProcessedData: [] }; // Return empty array on error
		}
	}	
	
	//Full Range Integration
	FullRange_Integration_Filtered(rawData, informationRTI, Tunit, NoValidranges) {
		try {
			// Check if NoValidranges is empty
			const hasValidRanges = Array.isArray(NoValidranges) && NoValidranges.length > 0;
	
			// Helper function to convert HH:mm time to milliseconds of the same day as a reference timestamp
			const convertTimeToMilliseconds = (timeString, referenceTimestamp) => {
				const [hours, minutes] = timeString.split(":").map(Number);
				const referenceDate = new Date(referenceTimestamp);
				referenceDate.setHours(hours, minutes, 0, 0); // Set hours, minutes, and seconds
				return referenceDate.getTime();
			};
	
			// Helper function to check if a timestamp is within any range
			const isWithinRange = hasValidRanges
				? (timestamp, ranges) => {
					return ranges.some(([start, end]) => {
						const startMs = convertTimeToMilliseconds(start, timestamp);
						const endMs = convertTimeToMilliseconds(end, timestamp);
						return timestamp >= startMs && timestamp <= endMs;
					});
				}
				: () => false; // If NoValidranges is empty, always return false
	
			// Get the unit conversion factor to convert U/{unit} to U/ms
			const unitConversionFactor = (() => {
				switch (Tunit) {
					case 's': return 1 / 1000; // U/s to U/ms
					case 'min': return 1 / (60 * 1000); // U/min to U/ms
					case 'h': return 1 / (3600 * 1000); // U/h to U/ms
					case 'day': return 1 / (24 * 3600 * 1000); // U/day to U/ms
					case 'month': return 1 / (30 * 24 * 3600 * 1000); // U/month to U/ms
					default:
						throw new Error(`Unsupported dataPrTUnit: ${Tunit}`);
				}
			})();
	
			if (this.OperationMode === "Hist") {
			
				this.DCNotfier.dgConsole("--------------Full range Integration--------------");
				// Historical Mode
				let integratedValue = 0;
				const initialTime = new Date(this.updateRequestI.initialTime).getTime();
				const finalTime = new Date(this.updateRequestI.finalTime).getTime();
				let timeDifference;
				let nVtimeAcumulated;
				this.DCNotfier.dgConsole("rawData");
				this.DCNotfier.dgConsole(rawData);
				if (rawData.Values.length > 1) {
					for (let i = 0; i < rawData.timestamps.length; i++) {
						const currentValue = rawData.Values[i];
						let currentTimestamp = rawData.timestamps[i];
						let nextTimestamp = i < rawData.timestamps.length - 1
							? rawData.timestamps[i + 1]
							: finalTime;
						timeDifference = nextTimestamp - currentTimestamp;
						nVtimeAcumulated=0;
	
						// Handle NoValidranges logic only if there are valid ranges						
						
						if (hasValidRanges) {
							this.DCNotfier.dgConsole("Has valid ranges");
							//Case 1: Range within NoValid Range	
							if (isWithinRange(currentTimestamp, NoValidranges) && isWithinRange(nextTimestamp, NoValidranges)) {
								timeDifference = 0;
								
								nVtimeAcumulated=nVtimeAcumulated+(nextTimestamp-currentTimestamp);
							} 
							
							//Case 2: Right Tail Time after NoValid Range	
							else if (isWithinRange(currentTimestamp, NoValidranges)) {
								const endOfRange = NoValidranges.find(([start, end]) => {
									const startMs = convertTimeToMilliseconds(start, currentTimestamp);
									const endMs = convertTimeToMilliseconds(end, currentTimestamp);
									return currentTimestamp >= startMs && currentTimestamp <= endMs;
								})[1];
								const endMs = convertTimeToMilliseconds(endOfRange, nextTimestamp);
								timeDifference = nextTimestamp - endMs;
								
								nVtimeAcumulated=nVtimeAcumulated+(endMs-currentTimestamp);
							} 
							
							//Case 3: Left Tail Time before NoValid Range	
							else if (isWithinRange(nextTimestamp, NoValidranges)) {
								const startOfRange = NoValidranges.find(([start, end]) => {
									const startMs = convertTimeToMilliseconds(start, nextTimestamp);
									const endMs = convertTimeToMilliseconds(end, nextTimestamp);
									return nextTimestamp >= startMs && nextTimestamp <= endMs;
								})[0];
								const startMs = convertTimeToMilliseconds(startOfRange, currentTimestamp);
								timeDifference = startMs - currentTimestamp;
								
								nVtimeAcumulated=nVtimeAcumulated+(startMs-nextTimestamp);
							}
							
							//Case 4: Out from NoValid Range
							else{
								timeDifference=nextTimestamp-currentTimestamp;
							}
						}
						
					
						integratedValue += currentValue * unitConversionFactor * timeDifference;
					}
					
					this.DCNotfier.dgConsole("--------------Time Difference--------------");
					this.DCNotfier.dgConsole(timeDifference);
					this.DCNotfier.dgConsole("--------------Time NoValid--------------");
					this.DCNotfier.dgConsole(nVtimeAcumulated);
					
				}
	
				this.DCNotfier.dgConsole("--------------New Integration Value------------");
				this.DCNotfier.dgConsole(integratedValue);
				return { ProcessedData: [Math.floor(integratedValue)] };
	
			} 
			
			else if (this.OperationMode === "RealTime") {					
				// Real-Time Mode
				const LastDataPointRaw={...informationRTI.LastDataPointRaw};
				const previousTimestamp=LastDataPointRaw.timestamps;
				
				const previousIntegration = informationRTI.LastDataPointProcessed || 0;
				const realTimePoints = [...informationRTI.LastDataPointRT];
				let newIntegration = 0;
				let nVtimeAcumulated=0;
	
				if (!Array.isArray(realTimePoints) || realTimePoints.length === 0) {
					throw new Error("No valid LastDataPointRT available for RealTime processing.");
				}
	
				for (let i = 0; i < realTimePoints.length; i++) {
				
					if (hasValidRanges) {												
								
					this.DCNotfier.dgConsole("--------------Has NoValid Ranges--------------");			
						
						const currentPoint = realTimePoints[i];
						let currentTimestamp = currentPoint.timestamps;
						const currentValue = currentPoint.Value;
						let nextTimestamp = i < realTimePoints.length - 1
							? realTimePoints[i + 1].timestamps
							: realTimePoints[i].timestamps;
						let timeDifference = nextTimestamp - currentTimestamp;
						
						if (i==0){
							currentTimestamp=previousTimestamp;
						}
		
						// Handle NoValidranges logic only if there are valid ranges	
						//Case 1: Range within NoValid Range					
						if (isWithinRange(currentTimestamp, NoValidranges) && isWithinRange(nextTimestamp, NoValidranges)) {	
								timeDifference = 0;
								
								nVtimeAcumulated=nVtimeAcumulated+(nextTimestamp-currentTimestamp);
						} 
						
						//Case 2: Right Tail Time after NoValid Range	
						else if (isWithinRange(currentTimestamp, NoValidranges)) {									
								const endOfRange = NoValidranges.find(([start, end]) => {
									const startMs = convertTimeToMilliseconds(start, currentTimestamp);
									const endMs = convertTimeToMilliseconds(end, currentTimestamp);
									return currentTimestamp >= startMs && currentTimestamp <= endMs;
								})[1];
								const endMs = convertTimeToMilliseconds(endOfRange, nextTimestamp);
								timeDifference = nextTimestamp - endMs;
								
								nVtimeAcumulated=nVtimeAcumulated+(endMs-currentTimestamp);
						} 
						
						//Case 3: Left Tail Time before NoValid Range	
						else if (isWithinRange(nextTimestamp, NoValidranges)) {
								const startOfRange = NoValidranges.find(([start, end]) => {
									const startMs = convertTimeToMilliseconds(start, nextTimestamp);
									const endMs = convertTimeToMilliseconds(end, nextTimestamp);
									return nextTimestamp >= startMs && nextTimestamp <= endMs;
								})[0];
								const startMs = convertTimeToMilliseconds(startOfRange, currentTimestamp);
								timeDifference = startMs - currentTimestamp;
								
								nVtimeAcumulated=nVtimeAcumulated+(startMs-nextTimestamp);
							}
							
						//Case 4: Out from NoValid Range	
						else{
							timeDifference=nextTimestamp-currentTimestamp;
						}
						
						
		
						newIntegration += currentValue * unitConversionFactor * timeDifference;
		
						this.DCNotfier.dgConsole("--------------Time Difference--------------");
						this.DCNotfier.dgConsole(timeDifference);
						this.DCNotfier.dgConsole("--------------Time NoValid--------------");
						this.DCNotfier.dgConsole(nVtimeAcumulated);
						this.DCNotfier.dgConsole("--------------New Integration Value------------");
						this.DCNotfier.dgConsole(newIntegration);
						
					}
					else {
						this.DCNotfier.dgConsole("--------------Does not have NoValid Ranges--------------");		
						const currentPoint = realTimePoints[i];
						var currentTimestamp = currentPoint.timestamps;
						const currentValue = currentPoint.Value;
						let  nextTimestamp;
	
					if (i < realTimePoints.length - 1) {
						nextTimestamp = realTimePoints[i + 1].timestamps;
					} else {
						nextTimestamp = realTimePoints[i].timestamps;
					}
					
					//const timeDifference = nextTimestamp - currentTimestamp;
					var timeDifference;
					if (i==0){
						currentTimestamp=previousTimestamp;
						timeDifference=nextTimestamp-currentTimestamp;
					}
					else{
							timeDifference=nextTimestamp-currentTimestamp;
					}


	
					// Multiply the current value (converted to U/ms) by the time difference (in ms)
					newIntegration += currentValue * unitConversionFactor * timeDifference;
					
			
					this.DCNotfier.dgConsole("--------------Time Difference--------------");
					this.DCNotfier.dgConsole(timeDifference);
					this.DCNotfier.dgConsole("--------------New Integration Value------------");
					this.DCNotfier.dgConsole(newIntegration);
					}
				}
	
				const totalNewIntegration = previousIntegration + newIntegration;
				return { ProcessedData: [totalNewIntegration] };
			} else {
				throw new Error(`Unsupported OperationMode: ${this.OperationMode}`);
			}
		} catch (error) {
			console.error("Error in FullRange_Integration_Filtered: ", error.message);
			return { ProcessedData: [] }; // Return empty array on error
		}
	}	

	//Full Range Diference
	FullRange_Difference(rawData,informationRTI) {
		
		if (this.OperationMode === "Hist") {
			if (rawData == undefined) {
				this.DCNotfier.dgConsole("No raw data available");
				return { ProcessedData: [] }; // Return an empty array if not enough data
			}
		
			if (rawData.Values.length < 2) {
				this.DCNotfier.dgConsole("Not enough data points to calculate the difference.");
				return { ProcessedData: [] }; // Return an empty array if not enough data
			}
		
			let accumulatedDifference = 0;
			let previousValue = rawData.Values[0];
			this.DCNotfier.dgConsole("New Iteration of Full Range");
			this.DCNotfier.dgConsole(rawData);
			for (let i = 1; i < rawData.Values.length; i++) {
				let currentValue = rawData.Values[i];
				let difference = currentValue - previousValue;
				
				
			//Negative Number
			if (difference < 0) {
				this.DCNotfier.dgConsole("Negative difference detected:"+currentValue+" - "+ previousValue+" = "+difference);
				let differenceI=this.negativeDifHandler({Values:[previousValue,currentValue]},difference,0,1);
				this.DCNotfier.dgConsole("--------------------New Difference------------------");
				this.DCNotfier.dgConsole(differenceI);
				accumulatedDifference += differenceI;
			}			
			 else {
					accumulatedDifference += difference;
				}			
				previousValue = currentValue;
			}
		
			return { ProcessedData: [accumulatedDifference] };
		} 
		
		else if (this.OperationMode === "RealTime") {
			let accumulatedDifference = informationRTI.LastDataPointProcessed;
			let previousValue = informationRTI.LastDataPointRaw.Value;
			let currentValue = informationRTI.LastDataPointRT[informationRTI.LastDataPointRT.length - 1].Value;
			let difference = currentValue - previousValue;	
			
			
			//Negative Number
			if (difference < 0) {
				this.DCNotfier.dgConsole("Negative difference detected:"+currentValue+" - "+ previousValue+" = "+difference);
				let differenceI=this.negativeDifHandler({Values:[previousValue,currentValue]},difference,0,1);
				this.DCNotfier.dgConsole("--------------------New Difference------------------");
				this.DCNotfier.dgConsole(differenceI);
				accumulatedDifference += differenceI;
			}	
			else {
				accumulatedDifference += difference;
			}
	
			return { ProcessedData: [accumulatedDifference] };
		}
	}

	//Productivity Calculator
	FullRange_OEEProductivity(rawData,informationRTI) {
		this.DCNotfier.dgConsole("--------------OEE Productivity Processing--------------");
		try {
			//Set OEE ID
			this.OEEinfoRTI["OEEID"]=this.chartConfigI.specialParameters.OEEID;

			//History Mode
			if (this.OperationMode === "Hist") {
				// Calculate unitsProduced using FullRange_Difference
				const { ProcessedData: unitsProducedArray } = this.FullRange_Difference(rawData,{});
				const unitsProduced = unitsProducedArray[0] ?? 0; // Default to 0 if no data
		
				// Calculate the time range of analysis
				const initialTime = new Date(this.dataRequest.updateRequest[0].initialTime).getTime();
				const finalTime = new Date(this.dataRequest.updateRequest[0].finalTime).getTime();
				const timeRange = finalTime - initialTime;
		
				let expectedUnitsProduced = 0;

				
				
				// First mode: Use OEEProSpeed
				if (this.chartConfigI.specialParameters.OEEProSM=="FixedSpeed"&& this.chartConfigI.specialParameters.OEEProSpeed !== "") {
					this.DCNotfier.dgConsole("--------------Fixed Speed Mode--------------");
					const OEEProSpeed = parseFloat(this.chartConfigI.specialParameters.OEEProSpeed);
					const unitConversionFactor = (() => {
						const unit = this.chartConfigI.specialParameters.OEEPSpU.split('/')[1];
						switch (unit) {
							case 's': return 1 / 1000; // Units per millisecond
							case 'min': return 1 / (60 * 1000); // Units per millisecond
							case 'h': return 1 / (3600 * 1000); // Units per millisecond
							case 'day': return 1 / (24 * 3600 * 1000); // Units per millisecond
							case 'month': return 1 / (30 * 24 * 3600 * 1000); // Units per millisecond
							default:
								throw new Error(`Unsupported OEEPSpU: ${unit}`);
						}
					})();
					
					const plannedDowntimeAcumulated = this.calculatePlannedDowntime(initialTime, finalTime, this.chartConfigI.specialParameters.OEEPDownE);
					
					this.DCNotfier.dgConsole("--------------Planned Downtime Acumulated--------------");
					this.DCNotfier.dgConsole(plannedDowntimeAcumulated);
					this.DCNotfier.dgConsole("--------------Time Range--------------");
					this.DCNotfier.dgConsole(timeRange);
					
					expectedUnitsProduced = OEEProSpeed * unitConversionFactor *(timeRange-plannedDowntimeAcumulated);
				}
				
				// Second mode: Use OEEProdSpeedN
				else if (this.chartConfigI.specialParameters.OEEProSM=="VariableSpeed"&&this.chartConfigI.specialParameters.OEEProdSpeedN !== "") {										
					
					this.DCNotfier.dgConsole("--------------Variable Speed Mode--------------");
					
					// Fetch rawDataSpeed
					const rawDataSpeed = this.rawData.find(data => data.Nodeaddress === this.chartConfigI.specialParameters.OEEProdSpeedN);
					if (!rawDataSpeed) {
						throw new Error("No rawDataSpeed found for the specified OEEProdSpeedN");
					}
		
					// Extract unit from OEEPSpU
					const Tunit = this.chartConfigI.specialParameters.OEEPSpU.split('/')[1];
		
					// Calculate integration of production speed
					const { ProcessedData: integratedProductionArray } = this.FullRange_Integration_Filtered(rawDataSpeed, {}, Tunit,this.chartConfigI.specialParameters.OEEPDownE);
					expectedUnitsProduced = integratedProductionArray[0] ?? 0; 
					expectedUnitsProduced =(expectedUnitsProduced==0?unitsProduced:expectedUnitsProduced)
					
					this.OEEinfoRTI["LSDataRaw"]={
							Value: rawDataSpeed.Values[rawDataSpeed.DataSize - 1],
							status: rawDataSpeed.status[rawDataSpeed.DataSize - 1],
							timestamps: rawDataSpeed.timestamps[rawDataSpeed.DataSize - 1]
						}
					
					
				}
				// Third mode: Use a Literal Expected units produced predefined counter
				else if (this.chartConfigI.specialParameters.OEEProSM=="ExpectedUnitsCounter"&& this.chartConfigI.specialParameters.OEEProExUCN !== "") {
				
					this.DCNotfier.dgConsole("--------------Expected Units Produced Mode--------------");
					
					// Fetch rawData Expected units Produced
					const rawDataExpectedU = this.rawData.find(data => data.Nodeaddress === this.chartConfigI.specialParameters.OEEProExUCN);
					if (!rawDataExpectedU) {
						throw new Error("No rawDataSpeed found for the specified OEEProExUCN");
					}
					
					// Calculate Full Range Difference in Expected units Produced
					const { ProcessedData: expectedUnitsProducedDif } = this.FullRange_Difference(rawDataExpectedU, {});
					expectedUnitsProduced = expectedUnitsProducedDif[0] ?? 0; 
					expectedUnitsProduced =(expectedUnitsProduced==0?unitsProduced:expectedUnitsProduced);		
					
					
					//Update for next iteration
					this.OEEinfoRTI["LtotalExU"]=expectedUnitsProduced;
					this.OEEinfoRTI["LDataExURaw"]={
														Value:rawDataExpectedU.Values[rawDataExpectedU.DataSize - 1],
														status: rawDataExpectedU.status[rawDataExpectedU.DataSize - 1],
														timestamps: rawDataExpectedU.timestamps[rawDataExpectedU.DataSize - 1]				
													};			
				}
				// Third mode:  No mode Use unitsProduced as expectedUnitsProduced
				else {
					expectedUnitsProduced = unitsProduced;
				}
				this.DCNotfier.dgConsole("--------------Units Produced--------------");
				this.DCNotfier.dgConsole(unitsProduced);
				this.DCNotfier.dgConsole("--------------Expected Units Produced--------------");
				this.DCNotfier.dgConsole(expectedUnitsProduced);
				
				//Update for next Iteration
				this.OEEinfoRTI["LunitsProd"]=unitsProduced;
				this.OEEinfoRTI["LEunitsProd"]=expectedUnitsProduced;
				this.OEEinfoRTI["Ftime"]=finalTime;
				
				// Calculate Productivity
				const OEEProductivityValue = (unitsProduced / expectedUnitsProduced) * 100;
		
				// Return the result
				return { ProcessedData: [OEEProductivityValue] };
			}
			
			else if (this.OperationMode === "RealTime") {
				
				//Final Time for multiple calculations
				const finalTime = new Date(this.informationRTI.LastDataPointRT[this.informationRTI.LastDataPointRT.length - 1].timestamps).getTime();
				
				// Calculate unitsProduced using FullRange_Difference
				this.informationRTI.LastDataPointProcessed = this.informationRTI.OEEInfo.LunitsProd;
				const { ProcessedData: unitsProducedArray } = this.FullRange_Difference(rawData,this.informationRTI);
				const unitsProduced = unitsProducedArray[0] ?? 0; // Default to 0 if no data
				this.DCNotfier.dgConsole("-------------- New Units Produced--------------");
				this.DCNotfier.dgConsole(unitsProduced);
				
				let expectedUnitsProduced = 0;
		
				// First mode: Use OEEProSpeed
				if (this.chartConfigI.specialParameters.OEEProSM=="FixedSpeed"&& this.chartConfigI.specialParameters.OEEProSpeed !== "") {
				
					this.DCNotfier.dgConsole("--------------Fixed Speed Mode--------------");
					// Calculate the time range of analysis
					const initialTime = new Date(this.informationRTI.OEEInfo.Ftime).getTime();		
					this.DCNotfier.dgConsole("--------------Inital Time--------------");
					this.DCNotfier.dgConsole((new Date (initialTime)).toLocaleString());			
					this.DCNotfier.dgConsole("--------------Final Time--------------");
					this.DCNotfier.dgConsole((new Date (finalTime)).toLocaleString());			
					const timeRange = finalTime - initialTime;
				
					const OEEProSpeed = parseFloat(this.chartConfigI.specialParameters.OEEProSpeed);
					const unitConversionFactor = (() => {
						const unit = this.chartConfigI.specialParameters.OEEPSpU.split('/')[1];
						switch (unit) {
							case 's': return 1 / 1000; // Units per millisecond
							case 'min': return 1 / (60 * 1000); // Units per millisecond
							case 'h': return 1 / (3600 * 1000); // Units per millisecond
							case 'day': return 1 / (24 * 3600 * 1000); // Units per millisecond
							case 'month': return 1 / (30 * 24 * 3600 * 1000); // Units per millisecond
							default:
								throw new Error(`Unsupported OEEPSpU: ${unit}`);
						}
					})();
					
					const plannedDowntimeAcumulated = this.calculatePlannedDowntime(initialTime, finalTime, this.chartConfigI.specialParameters.OEEPDownE);		
					
					this.DCNotfier.dgConsole("--------------Planned Downtime Acumulated--------------");
					this.DCNotfier.dgConsole(plannedDowntimeAcumulated);
					this.DCNotfier.dgConsole("--------------Time Range--------------");
					this.DCNotfier.dgConsole(timeRange);					
							
					expectedUnitsProduced = this.informationRTI.OEEInfo.LEunitsProd+(OEEProSpeed * unitConversionFactor * (timeRange-plannedDowntimeAcumulated));
				}
				// Second mode: Use OEEProdSpeedN
				else if (this.chartConfigI.specialParameters.OEEProSM=="VariableSpeed"&&this.chartConfigI.specialParameters.OEEProdSpeedN !== "") {		
					
					this.DCNotfier.dgConsole("--------------Variable Speed Mode--------------");
					
					let LastDataPointRT=this.readCurrentValue	(this.chartConfigI.specialParameters.OEEProdSpeedN);			
					
					//Prepare informationRTI					
					const informationRTI={			
									LastDataPointProcessed:this.informationRTI.OEEInfo.LEunitsProd,
									LastDataPointRT:[LastDataPointRT],
									LastDataPointRaw:this.informationRTI.OEEInfo.LSDataRaw,
					}

					// Extract unit from OEEPSpU
					const Tunit = this.chartConfigI.specialParameters.OEEPSpU.split('/')[1];
		
					// Calculate integration of production speed
					const { ProcessedData: integratedProductionArray } = this.FullRange_Integration_Filtered([], informationRTI, Tunit,this.chartConfigI.specialParameters.OEEPDownE);
					expectedUnitsProduced = integratedProductionArray[0] ?? 0;
					
					//Update for next iteration
					
					this.OEEinfoRTI["LSDataRaw"]=LastDataPointRT;
				}
				// Third mode: Use a Expected units produced predefined counter
				else if (this.chartConfigI.specialParameters.OEEProSM=="ExpectedUnitsCounter"&& this.chartConfigI.specialParameters.OEEProExUCN !== "") {
					
					this.DCNotfier.dgConsole("--------------Expected Units Produced Mode--------------");
					let LastDataPointRT=this.readCurrentValue(this.chartConfigI.specialParameters.OEEProExUCN);							
				
					//Prepare informationRTI					
					const informationPRTI={			
									LastDataPointProcessed:informationRTI.OEEInfo.LtotalExU,
									LastDataPointRT:[LastDataPointRT],
									LastDataPointRaw:informationRTI.OEEInfo.LDataExURaw,
					}	
					this.DCNotfier.dgConsole("--------------informationPRTI--------------");
					this.DCNotfier.dgConsole(informationPRTI);
					// Calculate totalExpectedUnits
					const { ProcessedData: totalExpectedUnits } = this.FullRange_Difference({},informationPRTI);
					const addedExpectedUnits = totalExpectedUnits[0] ?? 0; // Default to 0 if no data				
					
					
					expectedUnitsProduced = addedExpectedUnits;
					
					//Update for next iteration
					this.OEEinfoRTI["LtotalExU"]=expectedUnitsProduced;
					this.OEEinfoRTI["LDataExURaw"]=LastDataPointRT;
					
				}
				// Fourth mode: Use unitsProduced as expectedUnitsProduced
				else {
					expectedUnitsProduced = unitsProduced;
				}
				
				this.DCNotfier.dgConsole("-------------- New Expected Units Produced--------------");
				this.DCNotfier.dgConsole(expectedUnitsProduced);
				
				this.OEEinfoRTI["LunitsProd"]=unitsProduced;
				this.OEEinfoRTI["Ftime"]=finalTime;
				this.OEEinfoRTI["LEunitsProd"]=expectedUnitsProduced;
				
				
				
				// Calculate Productivity
				const OEEProductivityValue = (unitsProduced / expectedUnitsProduced) * 100;
				
				// Return the result
				return { ProcessedData: [OEEProductivityValue] };
			}
		} catch (error) {
			console.error("Error in FullRange_OEEProductivity:", error.message);
			return { ProcessedData: [] }; // Handle errors gracefully
		}
	}
	
	//Avalilability Calculator
	FullRange_OEEAvailability(rawData,informationRTI) {
	
		this.DCNotfier.dgConsole("--------------OEE Availability Processing--------------");
		try {		
			
			//Set OEE ID
			this.OEEinfoRTI["OEEID"]=this.chartConfigI.specialParameters.OEEID;

			if (!rawData) {
				this.DCNotfier.dgConsole("No raw data available");
				return { ProcessedData: [] }; // Return an empty array if no data
			}
	
			const convertToMilliseconds = (value, unit) => {
				const unitConversion = {
					s: 1000,
					min: 60 * 1000,
					h: 60 * 60 * 1000,
					day: 24 * 60 * 60 * 1000,
					month: 30 * 24 * 60 * 60 * 1000, // Approximate
				};
				return value * (unitConversion[unit] || 1000); // Default to seconds
			};
	
			const calculateOEEAvailability = (totalUptime, expectedRunningTime) =>
				(totalUptime / (expectedRunningTime || 1)) * 100;
	
			// Common variables and logic
			const plannedDowntimePeriods = this.chartConfigI.specialParameters.OEEPDownE;
			const dataPrTUnit = this.chartConfigI.dataPrTUnit || "s";
	
			if (this.OperationMode === "Hist") {
				// Step 1: Calculate total uptime
				const { ProcessedData: uptimeArray } = this.FullRange_Difference(rawData,{});
				const totalUptime = convertToMilliseconds(uptimeArray[0], dataPrTUnit);
	
				// Step 2: Calculate running times
				const initialTime = new Date(this.updateRequestI.initialTime).getTime();
				const finalTime = new Date(this.updateRequestI.finalTime).getTime();
				const preliminaryRunningTime = finalTime - initialTime;
				const plannedDowntimeAcumulated = this.calculatePlannedDowntime(initialTime, finalTime, plannedDowntimePeriods);
				const expectedRunningTime = preliminaryRunningTime - plannedDowntimeAcumulated;
		
				// Step 3: Calculate OEE Availability
				const OEEAvailabilityValue = calculateOEEAvailability(totalUptime, expectedRunningTime);
				
				
				this.DCNotfier.dgConsole("--------------Total Uptime--------------");
				this.DCNotfier.dgConsole(totalUptime);	
				
				this.DCNotfier.dgConsole("--------------Expected Running time--------------");
				this.DCNotfier.dgConsole(expectedRunningTime);	
				
				//Update for next iteration
				this.OEEinfoRTI["LuptimeValue"]=uptimeArray[0];
				this.OEEinfoRTI["LexRuTime"]=expectedRunningTime;
				this.OEEinfoRTI["FtimeA"]=finalTime;
				
	
				return { ProcessedData: [OEEAvailabilityValue] };
			}
			else if (this.OperationMode === "RealTime") {
				// Step 1: Calculate added uptime
				informationRTI.LastDataPointProcessed = informationRTI.OEEInfo.LuptimeValue;
				const { ProcessedData: uptimeArray } = this.FullRange_Difference(rawData,informationRTI);
				const addedUptime = convertToMilliseconds(uptimeArray[0], dataPrTUnit);
				
				this.DCNotfier.dgConsole("--------------Added Uptime--------------");
				this.DCNotfier.dgConsole(addedUptime);	
				
     			const newTotalUptime = addedUptime;
	
				// Step 2: Calculate running times
				const initialTime = new Date(informationRTI.OEEInfo.FtimeA).getTime();
				const finalTime = new Date(informationRTI.LastDataPointRT[informationRTI.LastDataPointRT.length - 1].timestamps).getTime();
				const preliminaryRunningTime = finalTime - initialTime;
				const plannedDowntimeAcumulated = this.calculatePlannedDowntime(initialTime, finalTime, plannedDowntimePeriods);
				
				const previousExpectedRunningTime = informationRTI.OEEInfo.LexRuTime || 0;
				const newExpectedRunningTime = previousExpectedRunningTime + (preliminaryRunningTime - plannedDowntimeAcumulated);
				
				this.DCNotfier.dgConsole("--------------new Expected Running Time-------------");
				this.DCNotfier.dgConsole(newExpectedRunningTime);
	
				// Step 3: Calculate OEE Availability
				const OEEAvailabilityValue = calculateOEEAvailability(newTotalUptime, newExpectedRunningTime);
	
				// Update real-time info
				this.OEEinfoRTI["LuptimeValue"]=uptimeArray[0];
				this.OEEinfoRTI["LexRuTime"]=newExpectedRunningTime;
				this.OEEinfoRTI["FtimeA"]=finalTime;
	
				return { ProcessedData: [OEEAvailabilityValue] };
			}
		} catch (error) {
			console.error("Error in FullRange_OEEAvailability: ", error.message);
			return { ProcessedData: [] }; // Handle errors gracefully
		}
	}	
	
	//Quality Calculator
	FullRange_OEEQuality(rawData,informationRTI) {
		this.DCNotfier.dgConsole("--------------OEE Quality Processing--------------");
		
		try {			
			//Set OEE ID
			this.OEEinfoRTI["OEEID"]=this.chartConfigI.specialParameters.OEEID;
			
			if (this.OperationMode === "Hist") {
			
				// Fetch rawDataProd
				const rawDataProd = this.rawData.find(data => data.Nodeaddress === this.chartConfigI.specialParameters.OEEPrN);
				if (!rawDataProd) {
					this.DCNotfier.dgConsole("No rawDataProd found for the specified OEEPrN");
					return { ProcessedData: [] }; // Handle missing rawDataProd
				}
	
				// Calculate totalUnitsProduced
				const { ProcessedData: producedArray } = this.FullRange_Difference(rawDataProd,{});
				const totalUnitsProduced = producedArray[0] ?? 0; // Default to 0 if no data
	
				// Calculate totalUnitsQuality
				const { ProcessedData: qualityArray } = this.FullRange_Difference(rawData,{});				
				const totalUnitsQuality = qualityArray[0] ?? 0; // Default to 0 if no data
				
				// Calculate OEE Quality
				if (totalUnitsProduced === 0) {
					this.DCNotfier.dgConsole("Total units produced is 0, cannot calculate quality.");
					return { ProcessedData: [0] }; // Avoid division by zero
				}
				
				//Initialize Quality
				var OEEQuality;
				
				//Considering Input as Bad Units
				if(this.chartConfigI.specialParameters.OEEQM=="Input-BadUnits"){
					OEEQuality = ((totalUnitsProduced - totalUnitsQuality) / totalUnitsProduced) * 100;
				}
				//Considering Input as good Units
				else if (this.chartConfigI.specialParameters.OEEQM=="Input-GoodUnits"){
					OEEQuality = ((totalUnitsQuality) / totalUnitsProduced) * 100;
				}
				else{
					OEEQuality =100;
				}
	
				this.DCNotfier.dgConsole("--------------Total Units Produced--------------");
				this.DCNotfier.dgConsole(totalUnitsProduced);
				
				let consoleText= this.chartConfigI.specialParameters.OEEQM=="Input-BadUnits" ? "Bad" : "Good"
				this.DCNotfier.dgConsole("--------------Total Units " +consoleText+ "--------------");
				this.DCNotfier.dgConsole(totalUnitsQuality);
	
				this.DCNotfier.dgConsole("--------------OEE Quality--------------");
				this.DCNotfier.dgConsole(OEEQuality);
				
				//Update for next iteration
				this.OEEinfoRTI["LtotalUPr"]=totalUnitsProduced;
				this.OEEinfoRTI["LtotalUB"]=totalUnitsQuality;
				this.OEEinfoRTI["LDataPrRaw"]={
													Value:rawDataProd.Values[rawDataProd.DataSize - 1],
													status: rawDataProd.status[rawDataProd.DataSize - 1],
													timestamps: rawDataProd.timestamps[rawDataProd.DataSize - 1]				
												};


				// Return the calculated OEE Quality
				return { ProcessedData: [OEEQuality] };
			}
			
			else if (this.OperationMode === "RealTime") {

				let LastDataPointRT=this.readCurrentValue(this.chartConfigI.specialParameters.OEEPrN);							
				
				//Prepare informationRTI					
				const informationPRTI={			
								LastDataPointProcessed:informationRTI.OEEInfo.LtotalUPr,
								LastDataPointRT:[LastDataPointRT],
								LastDataPointRaw:informationRTI.OEEInfo.LDataPrRaw,
				}
				
				
				// Calculate totalUnitsProduced
				const { ProcessedData: producedArray } = this.FullRange_Difference({},informationPRTI);
				const addedUnitsProduced = producedArray[0] ?? 0; // Default to 0 if no data

				// Calculate addedUnitsQuality				
				informationRTI.LastDataPointProcessed=informationRTI.OEEInfo.LtotalUB;
				const { ProcessedData: qualityArray } = this.FullRange_Difference({},informationRTI);
				const addedUnitsQuality = qualityArray[0] ?? 0; // Default to 0 if no data
				
				
				//Initialize Quality
				var OEEQuality;
				
				//Considering Input as Bad Units
				if(this.chartConfigI.specialParameters.OEEQM=="Input-BadUnits"){
					 OEEQuality = ((addedUnitsProduced - addedUnitsQuality) / addedUnitsProduced) * 100;
				}
				//Considering Input as good Units
				else if (this.chartConfigI.specialParameters.OEEQM=="Input-GoodUnits"){
					OEEQuality = ((addedUnitsQuality) / addedUnitsProduced) * 100;
				}
				else{
					OEEQuality =100;
				}
	
				
				this.DCNotfier.dgConsole("--------------Total Units Produced--------------");
				this.DCNotfier.dgConsole(addedUnitsProduced);

				let consoleText= this.chartConfigI.specialParameters.OEEQM=="Input-BadUnits" ? "Bad" : "Good"
				
				this.DCNotfier.dgConsole("--------------Total Units " +consoleText+ "--------------");
				this.DCNotfier.dgConsole(addedUnitsQuality);
	
				this.DCNotfier.dgConsole("--------------OEE Quality--------------");
				this.DCNotfier.dgConsole(OEEQuality);
				
				//Update for next iteration
				this.OEEinfoRTI["LtotalUPr"]=addedUnitsProduced;
				this.OEEinfoRTI["LtotalUB"]=addedUnitsQuality;
				this.OEEinfoRTI["LDataPrRaw"]=LastDataPointRT;
				
				// Return the calculated OEE Quality
				return { ProcessedData: [OEEQuality] };
				
			}
		} catch (error) {
			console.error("Error in FullRange_OEEQuality:", error.message);
			return { ProcessedData: [] }; // Handle errors gracefully
		}
	}
	
	//OEE Calculator
	FullRange_OEE(rawData) {
			this.DCNotfier.dgConsole("--------------OEE Processing--------------");
			
			try {
				//Set OEE ID
				this.OEEinfoRTI["OEEID"]=this.chartConfigI.specialParameters.OEEID;
				
				if (this.OperationMode === "Hist") {
					let OEE=0;
					
									
					
					//--------------Calculate Productivity	
					var OEEProd;
						
					
					//Check Cache
					let cachedProductivity=this.dataInfoRTFinderbyID("FullRange-OEEProductivity",this.chartConfigI.specialParameters.OEEID);
					this.DCNotfier.dgConsole("cachedProductivity: ");
					this.DCNotfier.dgConsole(cachedProductivity[0].LastDataPointProcessed);
					
					//If there is info in the cache
					if (cachedProductivity.length>0){
						OEEProd=cachedProductivity[0].LastDataPointProcessed;		
					}
					//Calculate 
					else {
						OEEProd=this.FullRange_OEEProductivity(rawData,{}).ProcessedData[0];		
					}
								
					
					//--------------Calculate Availability		
					var OEEAvail;				
					
					//Check Cache
					let cachedAvailability=this.dataInfoRTFinderbyID("FullRange-OEEAvailability",this.chartConfigI.specialParameters.OEEID);
					this.DCNotfier.dgConsole("cachedAvailability: ");
					this.DCNotfier.dgConsole(cachedAvailability[0].LastDataPointProcessed);
					
					//If there is info in the cache
					if (cachedAvailability.length>0){
						OEEAvail=cachedAvailability[0].LastDataPointProcessed;		
					}
					//Calculate
					else {
						// Fetch rawDataAvail
						const rawDataAvail = this.rawData.find(data => data.Nodeaddress === this.chartConfigI.specialParameters.OEEAvN);
						OEEAvail=this.FullRange_OEEAvailability(rawDataAvail,{}).ProcessedData[0];
						
						//For next Iteration
						this.OEEinfoRTI["LDataAvRaw"]={
								Value: rawDataAvail.Values[rawDataAvail.DataSize - 1],
								status: rawDataAvail.status[rawDataAvail.DataSize - 1],
								timestamps: rawDataAvail.timestamps[rawDataAvail.DataSize - 1]
						}
					}
					
					
					//--------------Calculate Quality
					var OEEQual;
						
					let cachedQuality=this.dataInfoRTFinderbyID("FullRange-OEEQuality",this.chartConfigI.specialParameters.OEEID);
					this.DCNotfier.dgConsole("cachedQuality: ");
					this.DCNotfier.dgConsole(cachedQuality[0].LastDataPointProcessed);
					
					//If there is info in the cache
					if (cachedQuality.length>0){
						OEEQual=cachedQuality[0].LastDataPointProcessed;		
					}
					//Calculate
					else{
						// Fetch rawDataQual
						const rawDataQual = this.rawData.find(data => data.Nodeaddress === this.chartConfigI.specialParameters.OEEQuN);	
						OEEQual=this.FullRange_OEEQuality(rawDataQual,{}).ProcessedData[0];
						
						//For next Iteration
						this.OEEinfoRTI["LDataQuRaw"]={
								Value: rawDataQual.Values[rawDataQual.DataSize - 1],
								status: rawDataQual.status[rawDataQual.DataSize - 1],
								timestamps: rawDataQual.timestamps[rawDataQual.DataSize - 1]
						}
						
					}		
					
					OEE=(OEEProd*OEEAvail*OEEQual)/10000;										
						
					this.DCNotfier.dgConsole("--------------OEE Productivity--------------");
					this.DCNotfier.dgConsole(OEEProd);
		
					this.DCNotfier.dgConsole("--------------OEE Availability--------------");
					this.DCNotfier.dgConsole(OEEAvail);
		
					this.DCNotfier.dgConsole("--------------OEE Quality--------------");
					this.DCNotfier.dgConsole(OEEQual);
					
					this.DCNotfier.dgConsole("--------------OEE--------------");
					this.DCNotfier.dgConsole(OEE);
				
				
					return { ProcessedData: [OEE] };
				}
				
				else if (this.OperationMode === "RealTime") {
				
					this.DCNotfier.dgConsole("--------------Information RT--------------");
					this.DCNotfier.dgConsole(this.informationRTI);
					this.DCNotfier.dgConsole((new Date(this.informationRTI.LastDataPointRT[0].timestamps)).toLocaleString());
					
					//-------Calculate Productivity
					var OEEPRT;
					
					let cachedProductivity=this.dataInfoRTFinderbyID("FullRange-OEEProductivity",this.chartConfigI.specialParameters.OEEID);
					this.DCNotfier.dgConsole("cachedProductivity: ");
					this.DCNotfier.dgConsole(cachedProductivity[0].LastDataPointProcessed);		
					
					//If there is info in the cache
					if (cachedProductivity.length>0){
						OEEPRT=cachedProductivity[0].LastDataPointProcessed;		
					}
					//Calculate
					else {
						OEEPRT=this.FullRange_OEEProductivity({},this.informationRTI).ProcessedData[0];
					}			
					
					//-------Calculate Availability
					var OEEART;
					
					let cachedAvailability=this.dataInfoRTFinderbyID("FullRange-OEEAvailability",this.chartConfigI.specialParameters.OEEID);
					this.DCNotfier.dgConsole("cachedAvailability: ");
					this.DCNotfier.dgConsole(cachedAvailability[0].LastDataPointProcessed);
					
					//If there is info in the cache
					if (cachedAvailability.length>0){
						OEEART=cachedAvailability[0].LastDataPointProcessed;		
					}
					//Calculate
					else{
						
						//Create Temp informationRTI
						const informationART={...this.informationRTI}
						const informationARTI={
															LastDataPointRT:[this.readCurrentValue(this.chartConfigI.specialParameters.OEEAvN)],
															LastDataPointRaw:informationART.OEEInfo.LDataAvRaw,
															OEEInfo:informationART.OEEInfo
															}
						
						//Create OEE Availability RT
						OEEART=this.FullRange_OEEAvailability({},informationARTI).ProcessedData[0];	
	
						//For next Iteration
						this.OEEinfoRTI["LDataAvRaw"]=informationARTI.LastDataPointRT[0];
					
					}					
					
									
					//-------Calculate Quality	
					var OEEQRT;				
					let cachedQuality=this.dataInfoRTFinderbyID("FullRange-OEEQuality",this.chartConfigI.specialParameters.OEEID);
					this.DCNotfier.dgConsole("cachedQuality: ");
					this.DCNotfier.dgConsole(cachedQuality[0].LastDataPointProcessed);
					
					//If there is info in the cache
					if (cachedQuality.length>0){
						OEEQRT=cachedQuality[0].LastDataPointProcessed;		
					}
					//Calculate
					else{
					
						//Create Temp informationRTI
						const informationQuRT={...this.informationRTI}
						const informationQuTI={
															LastDataPointRT:[this.readCurrentValue(this.chartConfigI.specialParameters.OEEQuN)],
															LastDataPointRaw:informationQuRT.OEEInfo.LDataQuRaw,
															OEEInfo:informationQuRT.OEEInfo
															}
															
						OEEQRT=this.FullRange_OEEQuality({},informationQuTI).ProcessedData[0];
												
							//For next Iteration
							this.OEEinfoRTI["LDataQuRaw"]=informationQuTI.LastDataPointRT[0];					
					}				
										
					//Calculate OEE										
					const OEERT=(OEEPRT*OEEART*OEEQRT)/10000;	
										
										
					this.DCNotfier.dgConsole("--------------Productivity RT--------------");
					this.DCNotfier.dgConsole(OEEPRT);						
					this.DCNotfier.dgConsole("--------------Availability RT--------------");
					this.DCNotfier.dgConsole(OEEART);
					this.DCNotfier.dgConsole("--------------Quality RT--------------");
					this.DCNotfier.dgConsole(OEEQRT);			
					this.DCNotfier.dgConsole("--------------OEE RT--------------");
					this.DCNotfier.dgConsole(OEERT);
					
					return { ProcessedData: [OEERT] };					
				}
			}
			catch (error) {
			console.error("Error in FullRange_OEE:", error.message);
			return { ProcessedData: [] }; // Handle errors gracefully
		}
	}
    
    //---------------Interval Functions----------------//
    
	//Create Histogram Data
	Interval_Histogram(rawData, chartCategories) {
		// Initialize histogram count array with zeros for each category
		let histogramCountArray = new Array(chartCategories.length).fill(0);
		// Parse chartCategories to get min and max for each bin
		const bins = chartCategories.map(category => {
			const parts = category.split('-');
			return {
				min: parseFloat(parts[0]),
				max: parseFloat(parts[1])
			};
		});
	
		if (this.OperationMode === "Hist") {
			// Iterate over each value in the raw data
			rawData.Values.forEach(value => {
				// Find which bin this value belongs to
				for (let i = 0; i < bins.length; i++) {
					if (value >= bins[i].min && value < bins[i].max) {
						histogramCountArray[i]++;
						break; // Stop checking once the correct bin is found
					}
				}
			});
		} 
		else if (this.OperationMode === "RealTime") {
			const originalCategories = this.informationRTI.HistInfo.categories;
			const originalProcessedData = this.informationRTI.HistInfo.ProcessedData;
			
			this.DCNotfier.dgConsole("originalCategories");
			this.DCNotfier.dgConsole(originalCategories);
			this.DCNotfier.dgConsole("originalProcessedData");
			this.DCNotfier.dgConsole(originalProcessedData);
			
			this.DCNotfier.dgConsole("Updated Chart Categories");
			this.DCNotfier.dgConsole(chartCategories);
			
			let newProcessedData = [...originalProcessedData];
	
			// Find new bins added at the beginning
			let addedBinsAtBeginning = 0;
			while (!originalCategories.includes(chartCategories[addedBinsAtBeginning])) {
				newProcessedData.unshift(0);
				addedBinsAtBeginning++;
			}
	
			// Find new bins added at the end
			let addedBinsAtEnd = 0;
			while (!originalCategories.includes(chartCategories[chartCategories.length - 1 - addedBinsAtEnd])) {
				newProcessedData.push(0);
				addedBinsAtEnd++;
			}
	
			// Iterate over each value in the LastDataPointRT
			this.informationRTI.LastDataPointRT.forEach(dataPoint => {
				// Find which bin this value belongs to
				for (let i = 0; i < bins.length; i++) {
					if (dataPoint.Value >= bins[i].min && dataPoint.Value < bins[i].max) {
						newProcessedData[i]++;
						break; // Stop checking once the correct bin is found
					}
				}
			});
			
			this.DCNotfier.dgConsole("newProcessedData");
			this.DCNotfier.dgConsole(newProcessedData);
	
			histogramCountArray = newProcessedData;
		}
	
		// Update this.HistInfoRTI["ProcessedData"]
		this.HistInfoRTI["ProcessedData"] = histogramCountArray;
	
		return { ProcessedData: histogramCountArray };
	}
	
	// Method to count changes in data
	Interval_ChangesCounter(rawData, intervals) {
		if (this.OperationMode === "Hist") {
			let changesCountArray = intervals.map(interval => {
				let previousValue = null;
				let changesCount = 0;
	
				for (let i = 0; i < rawData.timestamps.length; i++) {
					const timestamp = rawData.timestamps[i];
					if (timestamp >= interval.start && timestamp <= interval.end) {
						const currentValue = rawData.Values[i];
						const currentStatus = rawData.status[i];
	
						// Increment changesCount only if the status is 0 and the value changed
						if (previousValue !== null && currentValue !== previousValue && currentStatus === 0) {
							changesCount++;
						}
						previousValue = currentValue;
					}
				}
	
				return changesCount;
			});
	
			return { ProcessedData: changesCountArray };
		} else if (this.OperationMode === "RealTime") {
			//Reset if new Interval
			if(this.chartCategoriesI.intervalInfo.newInterval==true){
				 this.informationRTI.LastDataPointProcessed=0;
			}
				
			let changesCount = this.informationRTI.LastDataPointProcessed;
	
			this.informationRTI.LastDataPointRT.forEach(dataPoint => {
				if (dataPoint.status === 0) {
					changesCount++;
				}
			});
	
			return { ProcessedData: [changesCount] };
		}
	}
	
	//Count time On
	Interval_CountTimeOn(rawData, intervals) {
		let timeOnArray = new Array(intervals.length).fill(0);
	
		// Loop through each interval to determine the ON time
		intervals.forEach((interval, idx) => {
			let intervalStart = interval.start;
			let intervalEnd = interval.end;
			let timeOn = 0;
			let lastKnownOn = false;
			let lastTimestamp = intervalStart;
	
			// Iterate through timestamps to calculate ON time within the interval
			rawData.timestamps.forEach((timestamp, i) => {
				if (timestamp >= intervalStart && timestamp <= intervalEnd) {
					// Check if we're inside the interval and there is a state change
					if (lastKnownOn) {
						// Accumulate ON time from the last timestamp or the start of the interval
						timeOn += Math.min(timestamp, intervalEnd) - lastTimestamp;
					}
					// Update the last known state and the last timestamp
					lastKnownOn = rawData.Values[i];
					lastTimestamp = timestamp;
				}
			});
	
			// After processing all timestamps, if the last state was ON and the last timestamp is within the interval,
			// extend the ON time to the end of the interval
			if (lastKnownOn && lastTimestamp < intervalEnd) {
				timeOn += intervalEnd - lastTimestamp;
			}
	
			// Check if any timestamps fall into the interval
			const timestampsInInterval = rawData.timestamps.filter(t => t >= intervalStart && t <= intervalEnd);
			if (timestampsInInterval.length === 0) {
				// No timestamps in the interval, use the last known value from the previous intervals
				if (idx > 0 && rawData.Values[rawData.timestamps.length - 1]) {
					timeOn = intervalEnd - intervalStart; // If the machine was ON in the last known check, assume it stayed ON
				}
			}
	
			timeOnArray[idx] = timeOn;
		});
	
		return { ProcessedData: timeOnArray };
	}
		
	
	// Method to integrate data within Intervals
	Interval_Integration(rawData, intervals) {
		let integratedDataArray = [];
		let Tunit=this.chartConfigI.dataPrTUnit;
		
		
		//Function for unit conversion
		const unitConversionFactor = (() => {
				switch (Tunit) {
					case 's': return 1 / 1000; // U/s to U/ms
					case 'min': return 1 / (60 * 1000); // U/min to U/ms
					case 'h': return 1 / (3600 * 1000); // U/h to U/ms
					case 'day': return 1 / (24 * 3600 * 1000); // U/day to U/ms
					case 'month': return 1 / (30 * 24 * 3600 * 1000); // U/month to U/ms
					default:
						throw new Error(`Unsupported dataPrTUnit: ${Tunit}`);
				}
			})();
	
	
		if (this.OperationMode === "Hist") {
		
			let startIndex; 
			let endIndex;
			let endIndexPrevious;
			
			
			// Get the final time from the update request
			const initialTime = new Date(this.updateRequestI.initialTime).getTime();
			const finalTime = new Date(this.updateRequestI.finalTime).getTime();
			
			intervals.forEach((interval, intervalIndex) => {
				// Variables to store the previous value for trapezoidal calculation
				let previousValue = null;
				let previousTime = null;
				let area = 0;		
				let integratedValue=0;	
				
				// Find startIndex: First index where timestamp >= interval.start and < interval.end
				startIndex = rawData.timestamps.findIndex(time => time >= interval.start && time < interval.end);
					
				// Find endIndex: First index where timestamp > interval.end
				endIndex = rawData.timestamps.findIndex(time => time > interval.end);
				
				// For all iterations
				if (intervalIndex > 0 && endIndexPrevious!=-1) {
					// Use the previous endIndex as the startIndex for the current interval
					startIndex = endIndexPrevious;
				}
								
				// Calculate the endIndex for the current interval
				if (endIndex !== -1) {
					endIndex -= 1; // Move back one index to get the closest value less than or equal to interval.end
				} else {
					endIndex = rawData.Values.length - 1; // If no index found, set to last element
				}
				
				// Store the current endIndex for the next iteration
				endIndexPrevious = endIndex;

		
				// Check validity of startIndex and endIndex
				if (startIndex === -1 || startIndex > endIndex || endIndex < 0) {
					return null; // No valid data in this interval
				}			
				
				
				if (rawData.Values.length>1){ //More than one dataPoint
				
					// Iterate through the timestamps and calculate the integration
					for (let i = startIndex; i < endIndex; i++) {
					
						const currentValue = rawData.Values[i];
						let currentTimestamp = rawData.timestamps[i];
						let nextTimestamp;
						let previousTimestamp=initialTime;						
		
						var timeDifference;
						
						// Use the finalTime for the last iteration
						if (i === rawData.timestamps.length - 1) {
							nextTimestamp = finalTime;
							timeDifference = nextTimestamp - currentTimestamp;
						}//First iteration
						else if (i === 0){
							nextTimestamp = rawData.timestamps[i + 1];
							currentTimestamp=previousTimestamp;
							timeDifference = nextTimestamp - currentTimestamp;
						}
						 else {
							nextTimestamp = rawData.timestamps[i + 1];
							timeDifference = nextTimestamp - currentTimestamp;
						}
					
		
						// Multiply the current value (converted to U/ms) by the time difference (in ms)
						integratedValue += currentValue * unitConversionFactor * timeDifference;					
						
						
					}		
				}	
				
				this.DCNotfier.dgConsole("--------------integratedValue--------------");
				this.DCNotfier.dgConsole(integratedValue);
				// Add the calculated area for the current interval to the array
				integratedDataArray.push(integratedValue);
			});
	
			return { ProcessedData: integratedDataArray };
		} else if (this.OperationMode === "RealTime") {
		
			//Reset if new Interval
			if(this.chartCategoriesI.intervalInfo.newInterval==true){
				 this.informationRTI.LastDataPointProcessed=0;
			}
			
			
			
			let area = this.informationRTI.LastDataPointProcessed;
			let iterationAggregation=0;
			let previousValue = null;
			let previousTime = this.informationRTI.LastDataPointRaw.timestamps / 1000;
	
			// Concatenate LastDataPointRaw at the beginning of LastDataPointRT
			let allDataPoints = [this.informationRTI.LastDataPointRaw].concat(this.informationRTI.LastDataPointRT);
	
			allDataPoints.forEach((dataPoint, index) => {
				if (dataPoint.status === 0) {
					// Convert timestamp from milliseconds to seconds for the x-axis
					let currentTime = dataPoint.timestamps / 1000;
					let currentValue = dataPoint.Value;
	
					// Calculate the area using the trapezoidal rule if it's not the first data point
					if (previousValue !== null) {
						let base = currentTime - previousTime; // The difference in time (in seconds)
						area += (currentValue + previousValue) / 2 * base; // Trapezoidal area calculation
						iterationAggregation= (currentValue + previousValue) / 2 * base;
					}
	
					// Update the previous values for the next iteration
					previousValue = currentValue;
					previousTime = currentTime;
				}
			});	
			
			
			this.DCNotfier.dgConsole("iterationAggregation:");
			this.DCNotfier.dgConsole(iterationAggregation);
			
			return { ProcessedData: [area] };
		}
	}
		
	// Interval Difference
    Interval_Difference(rawData, intervals) {
        let differenceArray = [];

		if (this.OperationMode === "Hist") {
			try {
			
				let endIndexPrevious;
				
				differenceArray = intervals.map((interval, intervalIndex) => {
				
					
					// Find startIndex: First index where timestamp >= interval.start and < interval.end
					let startIndex = rawData.timestamps.findIndex(time => time >= interval.start && time < interval.end);
					
					// Find endIndex: First index where timestamp > interval.end
					let endIndex = rawData.timestamps.findIndex(time => time > interval.end);
					
					
					
					// For all iterations
					if (intervalIndex > 0 && endIndexPrevious!=-1) {
						// Use the previous endIndex as the startIndex for the current interval
						startIndex = endIndexPrevious;
					}
					
					// Calculate the endIndex for the current interval
					if (endIndex !== -1) {
						endIndex -= 1; // Move back one index to get the closest value less than or equal to interval.end
					} else {
						endIndex = rawData.Values.length - 1; // If no index found, set to last element
					}
					
					// Store the current endIndex for the next iteration
					endIndexPrevious = endIndex;

			
					// Check validity of startIndex and endIndex
					if (startIndex === -1 || startIndex > endIndex || endIndex < 0) {
						return null; // No valid data in this interval
					}
			
					let firstValue = rawData.Values[startIndex];
					let lastValue = rawData.Values[endIndex];
					
					let firstTimestamp=new Date(rawData.timestamps[startIndex]);
					let lastTimestamp=new Date(rawData.timestamps[endIndex]);				
					
					
					this.DCNotfier.dgConsole("firstTimestamp: ");
					this.DCNotfier.dgConsole(firstTimestamp.toLocaleString());
					this.DCNotfier.dgConsole("lastTimestamp: ");
					this.DCNotfier.dgConsole(lastTimestamp.toLocaleString());
					
					this.DCNotfier.dgConsole("firstValue: ");
					this.DCNotfier.dgConsole(firstValue);
					this.DCNotfier.dgConsole("lastValue: ");
					this.DCNotfier.dgConsole(lastValue);
					
					let highPrecision=true;
					let difference;
					
					//High Precision
					if (highPrecision){
						 difference=(this.FullRange_Difference({Values:rawData.Values.slice(startIndex, endIndex)})).ProcessedData[0];
						 this.DCNotfier.dgConsole("Interval difference");
						 this.DCNotfier.dgConsole(difference);
					 }
					 //Lower Precision
					 else{					 
							difference = lastValue - firstValue;
							// Handling potential rollovers				
							if (difference < 0){//Negative number
							
								this.DCNotfier.dgConsole("Negative difference detected:"+lastValue+" - "+ firstValue+" = "+difference);
								difference=this.negativeDifHandler(rawData,difference,startIndex,endIndex);
								
							}
					}
			
					return difference;
				});
			} catch (error) {
				console.error("An error occurred in Interval_Difference:", error);
				throw new Error("Failed to calculate interval differences: " + error.message);
			}
			
			return { ProcessedData: differenceArray };
		}

        else if (this.OperationMode === "RealTime") {
            try {
				//Reset if new Interval
				if(this.chartCategoriesI.intervalInfo.newInterval==true){
					 this.informationRTI.LastDataPointProcessed=0;
				}
				
                let latestValueRT = this.informationRTI.LastDataPointRT[this.informationRTI.LastDataPointRT.length - 1].Value;
                let lastValueRaw = this.informationRTI.LastDataPointRaw.Value;
                let difference = latestValueRT - lastValueRaw;
				this.DCNotfier.dgConsole("Difference: "+difference);
				this.DCNotfier.dgConsole("this.informationRTI.LastDataPointProcessed: "+this.informationRTI.LastDataPointProcessed);
                
                //Negative Number
				if (difference < 0) {
					this.DCNotfier.dgConsole("Negative difference detected:"+latestValueRT+" - "+ lastValueRaw+" = "+difference);
					let differenceI=this.negativeDifHandler({Values:[lastValueRaw,latestValueRT]},difference,0,1);
					this.DCNotfier.dgConsole("--------------------New Difference------------------");
					this.DCNotfier.dgConsole(differenceI);
					difference= differenceI;
				}	
				                
                let result = this.informationRTI.LastDataPointProcessed + difference;
                
                this.DCNotfier.dgConsole("result: "+result);
                return { ProcessedData: [result] };
            } catch (error) {
                console.error("An error occurred in Interval_Difference (RealTime):", error);
                throw new Error("Failed to calculate interval differences (RealTime): " + error.message);
            }
        }
    }
 	
	//Interval addition
	Interval_Addition(rawData, intervals) {
		if (this.OperationMode === "Hist") {
			let sumsArray = intervals.map(interval => {
				let sum = 0;
				
				for (let i = 0; i < rawData.timestamps.length; i++) {
					const timestamp = rawData.timestamps[i];
					if (timestamp >= interval.start && timestamp <= interval.end && rawData.status[i] === 0) {
						sum += rawData.Values[i];
					}
				}
				
				return sum;
			});
			
			return { ProcessedData: sumsArray };
		} else if (this.OperationMode === "RealTime") {
			let sum = this.informationRTI.LastDataPointProcessed;
			//Reset if new Interval
			if(this.chartCategoriesI.intervalInfo.newInterval==true){
				 this.informationRTI.LastDataPointProcessed=0;
			}
			
			this.informationRTI.LastDataPointRT.forEach(dataPoint => {
				if (dataPoint.status === 0) {
					sum += dataPoint.Value;
				}
			});
			
			return { ProcessedData: [sum] };
		}
	}
	
	// Interval_Average Method
	Interval_Average(rawData, intervals) {
		let averageArray = [];
		
		// Use binary search to quickly find ranges for each interval
		if (this.OperationMode === "Hist") {
			averageArray = intervals.map(interval => {
				// Use binary search to find the start and end indices for the current interval
				let startIndex = this.binarySearchTimestamps(rawData.timestamps, interval.start, 0, rawData.timestamps.length - 1, true);
				let endIndex = this.binarySearchTimestamps(rawData.timestamps, interval.end, startIndex, rawData.timestamps.length - 1, false);
				
				let sum = 0;
				let count = 0;
	
				// Iterate through only the relevant range of rawData for the current interval
				for (let i = startIndex; i <= endIndex; i++) {
					if (rawData.status[i] === 0) {
						sum += rawData.Values[i]; // Sum valid values
						count++; // Count valid entries
					}
				}
	
				// Calculate the average for the interval, avoiding division by zero
				const average = count > 0 ? sum / count : null;
	
				return average;
			});
	
			return { ProcessedData: averageArray };
		} else if (this.OperationMode === "RealTime") {
			let sum = this.informationRTI.LastDataPointProcessed || 0;
			let count = this.informationRTI.LastDataPointRT.length || 0;
	
			// Reset if it's a new interval
			if (this.chartCategoriesI.intervalInfo.newInterval) {
				this.informationRTI.LastDataPointProcessed = 0;
				sum = 0;
				count = 0;
			}
	
			this.informationRTI.LastDataPointRT.forEach(dataPoint => {
				if (dataPoint.status === 0) {
					sum += dataPoint.Value;
					count++;
				}
			});
	
			const average = count > 0 ? sum / count : null;
	
			return { ProcessedData: [average] };
		}
	}
	
	
	//---------------Table Processing Functions----------------//
	//--------------------------------------------------//
	//--------------------------------------------------//
	
	//---------------Single Point Functions----------------//
	
	//SimpleData
	SimpleNoneTableProcessing() {
		
		
		var processedDataI = [];
		const timestampsCategories = this.chartCategoriesI.chartCategory.categories[0].categories;
		const replacementText = this.chartConfigI.specialParameters.TableConfig.ReplacementText; // Variable for replacement text
		const fillingMethod=this.chartConfigI.specialParameters.TableConfig.FillingMethod;
		
		
		// Find the index of this.nodeI in this.chartNodesI to match the DataColumnTypes
		const dataColumnType = this.chartConfigI.specialParameters.TableConfig.DataColumnTypes[this.indexNodeI];
		this.DCNotfier.dgConsole("------------dataColumnType: "+dataColumnType);
		
		if (this.OperationMode === "Hist") {
			
			const rawDataTimestamps = this.partialDashboardDataI.timestamps;
			const rawDataValues = this.partialDashboardDataI.Values;
		
			// Helper functions to find closest values based on timestamp comparison
			const findClosestBelow = (targetTimestamp) => {
				let closestIndex = -1;
				for (let i = 0; i < rawDataTimestamps.length; i++) {
					if (rawDataTimestamps[i] <= targetTimestamp) {
						closestIndex = i;
					} else {
						break;
					}
				}
				return closestIndex;
			};
		
			const findClosestAbove = (targetTimestamp) => {
				for (let i = 0; i < rawDataTimestamps.length; i++) {
					if (rawDataTimestamps[i] >= targetTimestamp) {
						return i;
					}
				}
				return -1;
			};
		
			const findAverageBetweenTwo = (targetTimestamp) => {
				let belowIndex = findClosestBelow(targetTimestamp);
				let aboveIndex = findClosestAbove(targetTimestamp);
		
				if (belowIndex === -1 && aboveIndex === -1) {
					return replacementText; // No values available
				}
				if (belowIndex === -1) {
					return rawDataValues[aboveIndex]; // Only one available, return above
				}
				if (aboveIndex === -1) {
					return rawDataValues[belowIndex]; // Only one available, return below
				}
				// Average of two closest values
				return (rawDataValues[belowIndex] + rawDataValues[aboveIndex]) / 2;
			};
			
			
			
			if (dataColumnType=="Time"){
				processedDataI=rawDataTimestamps	;				
			}
			else{
				// Main logic based on fillingMethod and DataColumnTypes
				for (let timestamp of timestampsCategories) {
					let processedValue;
							
					if (fillingMethod === "Fill-NoValue") {
						// Check for an exact match in timestamps
						const index = rawDataTimestamps.indexOf(timestamp);
						const threshold=100;
						
						if (index !== -1) {
							// Exact match found
							processedValue = dataColumnType === "Value" ? rawDataValues[index] : rawDataTimestamps[index];
						} else {
							// Find the closest value below the timestamp
							const closestBelowIndex = findClosestBelow(timestamp);
							const closestBelowDiff = closestBelowIndex !== -1 ? Math.abs(timestamp - rawDataTimestamps[closestBelowIndex]) : Infinity;
					
							// Check if it's within the threshold
							if (closestBelowDiff <= threshold) {
								processedValue = dataColumnType === "Value" ? rawDataValues[closestBelowIndex] : rawDataTimestamps[closestBelowIndex];
							} else {
								// Find the closest value above the timestamp
								const closestAboveIndex = findClosestAbove(timestamp);
								const closestAboveDiff = closestAboveIndex !== -1 ? Math.abs(rawDataTimestamps[closestAboveIndex] - timestamp) : Infinity;
					
								// Check if it's within the threshold
								if (closestAboveDiff <= threshold) {
									processedValue = dataColumnType === "Value" ? rawDataValues[closestAboveIndex] : rawDataTimestamps[closestAboveIndex];
								} else {
									// No suitable match, use replacementText
									processedValue = replacementText;
								}
							}
						}
					}			
					else if (fillingMethod === "Fill-ClosestValueBelow") {
						// Find the closest timestamp below
						const closestIndex = findClosestBelow(timestamp);
						if (closestIndex !== -1) {
							processedValue = dataColumnType === "Value" ? rawDataValues[closestIndex] : rawDataTimestamps[closestIndex];
						} else if (rawDataTimestamps.length > 0) {
							processedValue = dataColumnType === "Value" ? rawDataValues[0] : rawDataTimestamps[0];
						} else {
							processedValue = replacementText;
						}
					} else if (fillingMethod === "Fill-ClosestValueAbove") {
						// Find the closest timestamp above
						const closestIndex = findClosestAbove(timestamp);
						if (closestIndex !== -1) {
							processedValue = dataColumnType === "Value" ? rawDataValues[closestIndex] : rawDataTimestamps[closestIndex];
						} else if (rawDataTimestamps.length > 0) {
							processedValue = dataColumnType === "Value" ? rawDataValues[rawDataValues.length - 1] : rawDataTimestamps[rawDataTimestamps.length - 1];
						} else {
							processedValue = replacementText;
						}
					} else if (fillingMethod === "Fill-Average") {
						// Find the average of the two closest timestamps
						if (dataColumnType === "Value") {
							processedValue = findAverageBetweenTwo(timestamp);
						} else {
							const belowIndex = findClosestBelow(timestamp);
							const aboveIndex = findClosestAbove(timestamp);
							if (belowIndex !== -1 && aboveIndex !== -1) {
								processedValue = (rawDataTimestamps[belowIndex] + rawDataTimestamps[aboveIndex]) / 2;
							} else if (belowIndex !== -1) {
								processedValue = rawDataTimestamps[belowIndex];
							} else if (aboveIndex !== -1) {
								processedValue = rawDataTimestamps[aboveIndex];
							} else {
								processedValue = replacementText;
							}
						}
					}
			
					// Push the processed value or timestamp depending on the DataColumnTypes
					processedDataI.push(processedValue);
				}
			}
			
		
			return { ProcessedData: processedDataI };
		}
		else if (this.OperationMode === "RealTime") {
		
			const lastDataPointTRaw = this.informationRTI.LastDataPointRaw;	  
			const lastDataPointRTI = this.informationRTI.LastDataPointRT;
			
			// Remove elements from lastDataPointRT that are equal to lastDataPointTRaw
			const stringifyRaw = JSON.stringify(lastDataPointTRaw);
			const lastDataPointRT = lastDataPointRTI.filter(
				item => JSON.stringify(item) !== stringifyRaw
			);
			
		
			//If there are elements in lastDataPointRT
			if(lastDataPointRT.length>0){
				const lastDataPointRTTimestamps =  lastDataPointRT.map(dataPoint => dataPoint.timestamps);
				const lastDataPointRTValues = lastDataPointRT.map(dataPoint => dataPoint.Value);
				
				
			
				// Helper functions to find closest values based on timestamp comparison
				const findClosestBelow = (targetTimestamp) => {
					let closestIndex = -1;
					for (let i = 0; i < lastDataPointRTTimestamps.length; i++) {
						if (lastDataPointRTTimestamps[i] <= targetTimestamp) {
							closestIndex = i;
						} else {
							break;
						}
					}
					return closestIndex;
				};
			
				const findClosestAbove = (targetTimestamp) => {
					for (let i = 0; i < lastDataPointRTTimestamps.length; i++) {
						if (lastDataPointRTTimestamps[i] >= targetTimestamp) {
							return i;
						}
					}
					return -1;
				};
			
				const findAverageBetweenTwo = (targetTimestamp) => {
					let belowIndex = findClosestBelow(targetTimestamp);
					let aboveIndex = findClosestAbove(targetTimestamp);
			
					if (belowIndex === -1 && aboveIndex === -1) {
						return replacementText; // No values available
					}
					if (belowIndex === -1) {
						return lastDataPointRTValues[aboveIndex]; // Only one available, return above
					}
					if (aboveIndex === -1) {
						return lastDataPointRTValues[belowIndex]; // Only one available, return below
					}
					// Average of two closest values
					return (lastDataPointRTValues[belowIndex] + lastDataPointRTValues[aboveIndex]) / 2;
				};
			
				// Main logic based on fillingMethod and DataColumnTypes
				for (let timestamp of timestampsCategories) {
					let processedValue;
							
					if (fillingMethod === "Fill-NoValue") {
						// Check for an exact match in timestamps
						const index = lastDataPointRTTimestamps.indexOf(timestamp);
						const threshold=100;
						
						if (index !== -1) {
							// Exact match found
							processedValue = dataColumnType === "Value" ? lastDataPointRTValues[index] : lastDataPointRTTimestamps[index];
						} else {
							// Find the closest value below the timestamp
							const closestBelowIndex = findClosestBelow(timestamp);
							const closestBelowDiff = closestBelowIndex !== -1 ? Math.abs(timestamp - lastDataPointRTTimestamps[closestBelowIndex]) : Infinity;
					
							// Check if it's within the threshold
							if (closestBelowDiff <= threshold) {
								processedValue = dataColumnType === "Value" ? lastDataPointRTValues[closestBelowIndex] : lastDataPointRTTimestamps[closestBelowIndex];
							} else {
								// Find the closest value above the timestamp
								const closestAboveIndex = findClosestAbove(timestamp);
								const closestAboveDiff = closestAboveIndex !== -1 ? Math.abs(lastDataPointRTTimestamps[closestAboveIndex] - timestamp) : Infinity;
					
								// Check if it's within the threshold
								if (closestAboveDiff <= threshold) {
									processedValue = dataColumnType === "Value" ? lastDataPointRTValues[closestAboveIndex] : lastDataPointRTTimestamps[closestAboveIndex];
								} else {
									// No suitable match, use replacementText
									processedValue = replacementText;
								}
							}
						}
					}			
					else if (fillingMethod === "Fill-ClosestValueBelow") {
						// Find the closest timestamp below
						const closestIndex = findClosestBelow(timestamp);
						if (closestIndex !== -1) {
							processedValue = dataColumnType === "Value" ? lastDataPointRTValues[closestIndex] : lastDataPointRTTimestamps[closestIndex];
						} else if (lastDataPointRTTimestamps.length > 0) {
							processedValue = dataColumnType === "Value" ? lastDataPointRTValues[0] : lastDataPointRTTimestamps[0];
						} else {
							processedValue = replacementText;
						}
					} else if (fillingMethod === "Fill-ClosestValueAbove") {
						// Find the closest timestamp above
						const closestIndex = findClosestAbove(timestamp);
						if (closestIndex !== -1) {
							processedValue = dataColumnType === "Value" ? lastDataPointRTValues[closestIndex] : lastDataPointRTTimestamps[closestIndex];
						} else if (lastDataPointRTTimestamps.length > 0) {
							processedValue = dataColumnType === "Value" ? lastDataPointRTValues[lastDataPointRTValues.length - 1] : lastDataPointRTTimestamps[lastDataPointRTTimestamps.length - 1];
						} else {
							processedValue = replacementText;
						}
					} else if (fillingMethod === "Fill-Average") {
						// Find the average of the two closest timestamps
						if (dataColumnType === "Value") {
							processedValue = findAverageBetweenTwo(timestamp);
						} else {
							const belowIndex = findClosestBelow(timestamp);
							const aboveIndex = findClosestAbove(timestamp);
							if (belowIndex !== -1 && aboveIndex !== -1) {
								processedValue = (lastDataPointRTTimestamps[belowIndex] + lastDataPointRTTimestamps[aboveIndex]) / 2;
							} else if (belowIndex !== -1) {
								processedValue = lastDataPointRTTimestamps[belowIndex];
							} else if (aboveIndex !== -1) {
								processedValue = lastDataPointRTTimestamps[aboveIndex];
							} else {
								processedValue = replacementText;
							}
						}
					}
			
					// Push the processed value or timestamp depending on the DataColumnTypes
					processedDataI.push(processedValue);
				}
			
				return { ProcessedData: processedDataI };
			
			}
			else {
				return { ProcessedData: [] };
			}
		}
		
	}
	
	//---------------Data Analisis Helper Methods--------------//
	//--------------------------------------------------------//
	
	//Performs Current Value Read
    readCurrentValue(node) {
        try {
            // Find the node
            var nodeI = Ua.findNode(node);

            // Check if the node result is properly defined
            if (nodeI?.result) {
                // Extract and return the desired object
                const output = {
                    Value: nodeI.result.value,
                    timestamps: new Date(nodeI.result.sourceTime?.value).getTime(),
                    status: nodeI.result.status?.value,
                };
                return output;
            } else {
                console.error(`Node result is undefined or missing required fields for node ${node}.`);
                return null;
            }
        } catch (error) {
            // Handle and log any errors that occur
            console.error(`Error reading current value for node ${node}:`, error);
            return null;
        }
    }
    
    //Calculate planned downtime
    calculatePlannedDowntime (initialTime, finalTime, downtimePeriods) {
		const dayMilliseconds = 24 * 60 * 60 * 1000;
		let currentDayStart = new Date(initialTime).setHours(0, 0, 0, 0);
		let plannedDowntime = 0;

		while (currentDayStart < finalTime) {
			const currentDayEnd = Math.min(currentDayStart + dayMilliseconds, finalTime);

			downtimePeriods.forEach(([start, end]) => {
				const [startHour, startMinute] = start.split(":").map(Number);
				const [endHour, endMinute] = end.split(":").map(Number);

				const plannedStart = new Date(currentDayStart).setHours(startHour, startMinute, 0, 0);
				const plannedEnd = new Date(currentDayStart).setHours(endHour, endMinute, 0, 0);

				if (plannedStart < currentDayEnd && plannedEnd > initialTime) {
					plannedDowntime += Math.min(plannedEnd, currentDayEnd) - Math.max(plannedStart, initialTime);
				}
			});

			currentDayStart += dayMilliseconds;
		}

		return plannedDowntime;
	};
    
	// Auxiliary function
	getMaxValue(values) {
		return values.reduce((max, v) => v > max ? v : max, values[0]);
	}
	
	//Auxiliary function
	closestPowerOfTwo(maxValue) {
		if (maxValue < 65536) {
			return 65536; // 2^16
		} else if (maxValue < 4294967296) {
			return 4294967296; // 2^32
		} else {
			return 18446744073709551616; // 2^64
		}
	}
	
	// Function to round date
	roundDate(date, orientation) {
		var date = new Date(date); // Clone to avoid mutating the original date
		if (typeof this.intervalLengthI === 'number') {
			if (this.intervalLengthI <= ONE_MINUTE) {
				date.setSeconds(0, 0);
				if (orientation === 'up' && date.getSeconds() > 0) {
					date.setMinutes(date.getMinutes() + 1);
				}
			} else if (this.intervalLengthI <= ONE_HOUR) {
				date.setSeconds(0, 0);
				if (orientation === 'up' && date.getMinutes() > 0) {
					date.setHours(date.getHours() + 1);
					date.setMinutes(0);
				} else {
					date.setMinutes(0);
				}
			} else if (this.intervalLengthI <= ONE_DAY) {
				date.setMinutes(0, 0, 0);
				if (orientation === 'up' && date.getHours() > 0) {
					date.setDate(date.getDate() + 1);
					date.setHours(0);
				} else {
					date.setHours(0);
				}
			}
		} else if (this.intervalLengthI === 'month') {
			date.setHours(0, 0, 0, 0);
			date.setDate(1);
			if (orientation === 'up' && date.getMonth() > 0) {
				date.setMonth(date.getMonth() + 1);
			}
		} else if (this.intervalLengthI === 'year') {
			date.setMonth(0, 1);
			date.setHours(0, 0, 0, 0);
			date.setDate(1);
			if (orientation === 'up' && date.getFullYear() > 0) {
				date.setFullYear(date.getFullYear() + 1);
			}
		}
		return date;
	}
	
	// Faster Search
	binarySearchTimestamps(timestamps, target, start = 0, end = timestamps.length - 1, findStart = true) {
		while (start <= end) {
			let mid = Math.floor((start + end) / 2);
			if (timestamps[mid] === target) {
				return mid;
			} else if (timestamps[mid] < target) {
				start = mid + 1;
			} else {
				end = mid - 1;
			}
		}
		// If findStart is true, return the first index where the timestamp >= target
		return findStart ? start : end;
	}
	
	//Format Time
	formatTimestampToDateTime(unixTimestamp) {
		const date = new Date(unixTimestamp); // Convert Unix timestamp to Date object
	
		// Extract date components
		const day = String(date.getDate()).padStart(2, '0'); // Pad single-digit days with 0
		const month = String(date.getMonth() + 1).padStart(2, '0'); // Months are 0-based, pad single-digit months
		const year = date.getFullYear();
	
		// Extract time components
		const hours = String(date.getHours()).padStart(2, '0'); // Pad single-digit hours
		const minutes = String(date.getMinutes()).padStart(2, '0'); // Pad single-digit minutes
		const seconds = String(date.getSeconds()).padStart(2, '0'); // Pad single-digit seconds
	
		// Return formatted string in the desired format
		return `${day}/${month}/${year} ${hours}:${minutes}:${seconds}`;
	}
	
	//Find Closest Value By Timestamp		
	findClosestValueByTimestamp(targetTimestamp, limitData) {

		
        if (!limitData || !limitData.timestamps || !limitData.Values || limitData.timestamps.length === 0) {
            // console.warn("Limit data is invalid or empty for timestamp search.");
            return null; // No data to search
        }

        const timestamps = limitData.timestamps;
        const values = limitData.Values;
        const n = timestamps.length;

        // Handle edge cases: target is before the first or after the last timestamp
        if (targetTimestamp <= timestamps[0]) {
            return values[0];
        }
        if (targetTimestamp >= timestamps[n - 1]) {
            return values[n - 1];
        }

        // Binary search to find the insertion point
        let low = 0, high = n - 1;
        let insertPos = 0;

        while (low <= high) {
            const mid = Math.floor((low + high) / 2);
            if (timestamps[mid] === targetTimestamp) {
                return values[mid]; // Exact match found
            } else if (timestamps[mid] < targetTimestamp) {
                insertPos = mid + 1; // Potential insertion point is after mid
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }

        // insertPos is now the index where targetTimestamp would be inserted
        // The closest timestamp is either at insertPos or insertPos - 1
        const tsBefore = timestamps[insertPos - 1];
        const tsAfter = timestamps[insertPos]; // This index might be out of bounds if target > last element, but handled by edge case above

        const diffBefore = targetTimestamp - tsBefore;
        const diffAfter = tsAfter - targetTimestamp;

        // Return the value corresponding to the timestamp with the smaller difference
        if (diffBefore <= diffAfter) {
            return values[insertPos - 1];
        } else {
            return values[insertPos];
        }
    }

	
	//---------------Negative difference Handling-----------------//	
	//-----------------------------------------------------------------//
	
	//Negative Handler
	negativeDifHandler(rawData,difference,startIndex,endIndex){
		
		this.DCNotfier.dgConsole("Entering Negative Difference Handler....");
		this.DCNotfier.dgConsole(rawData)
		let firstValue = rawData.Values[startIndex];
		let lastValue = rawData.Values[endIndex];
		
		this.DCNotfier.dgConsole(firstValue);
		this.DCNotfier.dgConsole(lastValue);
		
		
		let endIndexPositive=endIndex;
		
		//Potential Roll Over
		if (difference < -10000) {
			this.DCNotfier.dgConsole("Potential rollover detected between values:"+firstValue+ " and "+lastValue);
			//Roll Over
			if (this.isRollover(rawData.Values.slice(startIndex, endIndex))) {
				this.DCNotfier.dgConsole("Roll Over confirmed");
				const maxValue = this.getMaxValue(rawData.Values);
				const powerOfTwo = this.closestPowerOfTwo(maxValue);
				difference = (powerOfTwo - firstValue) + lastValue;
			}
			
			//No Roll Over
			else{
				this.DCNotfier.dgConsole("No Roll Over found");
				while(difference < 0 || endIndexPositive>startIndex){
				
					//Go Backwards to find when this happened
					endIndexPositive=endIndexPositive-1;
					let lastValuePositive = rawData.Values[endIndexPositive];
					
					//Recalculate Difference
					difference=firstValue-lastValuePositive;
					
					
				}
				
				let lastValueafterPositive = rawData.Values[endIndexPositive+1];
				
				//Adds the rest
				difference=difference+(lastValue-lastValueafterPositive);
			}
		}
		
		//Defenitelly No Roll Over
		else{
			this.DCNotfier.dgConsole("No Roll Over found");
			
			let  positiveFound=false;
			
			while(difference < 0 || endIndexPositive>startIndex){
				
					//Go Backwards to find when this happened
					endIndexPositive=endIndexPositive-1;
					let lastValuePositive = rawData.Values[endIndexPositive];
					
					//Recalculate Difference
					difference=firstValue-lastValuePositive;
					
					//Found positive value
					if (difference>= 0){
						positiveFound=true;
					}
				}
				
				
				let lastValueafterPositive = rawData.Values[endIndexPositive+1];
				
				//Adds the rest
				difference=difference+(lastValue-lastValueafterPositive);
		}
		return difference;
					
	}
	
	//Auxiliary function for Rollover Detection
	nearestPowerOfTwo(value) {
		const lower = Math.pow(2, Math.floor(Math.log2(value)));
		const upper = Math.pow(2, Math.ceil(Math.log2(value)));
		return Math.abs(value - lower) < Math.abs(value - upper) ? lower : upper;
	}
	
	// Check for rollovers
	isRollover(values) {
		// Calculate basic statistics
		const { mean, stdDev } = this.calculateStats(values);
	
		// Iterate through the values to detect a sudden drop
		for (let i = 1; i < values.length; i++) {
			const current = values[i];
			const previous = values[i - 1];
	
			// Check for a sudden drop (large negative difference)
			if (previous - current > 3 * stdDev) {
				// Check if the previous value is close to a power of 2
				const nearestPower = this.nearestPowerOfTwo(previous);
				const isCloseToPowerOf2 = Math.abs(previous - nearestPower) < nearestPower * 0.01;
	
				// Check if the current value is near zero
				const isNearZero = current < mean - 3 * stdDev;
	
				if (isCloseToPowerOf2 && isNearZero) {
					return true; // Detected rollover
				}
			}
		}
	
		return false; // No rollover detected
	}
	
	//Calculate stats
	calculateStats(values) {
		const n = values.length;
		let mean = values.reduce((acc, val) => acc + val, 0) / n;
		let variance = values.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / n;
		let stdDev = Math.sqrt(variance);
		return { mean, stdDev };
	}
	
	//Get last element Different than null, used in dataInfoRTCreator
	getLastNonNullElement(array) {

		for (let i = array.length - 1; i >= 0; i--) {

			if (array[i] !== null   && array[i] !==undefined ) {
				return { element: array[i], index: i };
			}
		}
		return { element: null, index: -1 };
	}
}

//---------------Dashboard Cache Manager Class----------------//
//-----------------------------------------------------//
class DashboardCacheManager {

    // Attributes
    cacheDataRequest;
    cacheData;
    cacheRawData;
    cacheProcessedData;
    initialTime;
    finalTime;

    // Constructor
    constructor(dashboardCreatorNotifier,dataRequest) {    
		this.cacheConfig;
		this.dashboardID=JSON.parse(dataRequest).updateRequest[0].dID;
		this.cacheKey="cacheData"+this.dashboardID;
        this.initialTime;
        this.finalTime;
        this.cacheDataRequest = {};
        this.cachedData = [];
        
        this.cacheRawData;
        this.cacheProcessedData;
        this.cacheInfoData;
       
        this.intervalLength=ONE_HOUR;
        this.DCNotfier=dashboardCreatorNotifier;

    }
	
    // Initialize cache data based on initial setup
    initialize(Data, type) {
		    	
   	
		//Variables to store
		let cacheKey;
		let cacheData;
		
		switch (type) {
		  case "rawData":
			this.cacheRawData = Data;
			cacheData=this.cacheRawData;
			cacheKey=this.cacheKey+"rawData";
			break;
		  case "processedData":
			this.cacheProcessedData = Data;
			cacheData=this.cacheProcessedData;
			cacheKey=this.cacheKey+"processedData";
			break;
		  case "infoData":
			 this.cacheInfoData = Data;
			 cacheData=this.cacheInfoData;
			 cacheKey=this.cacheKey+"infoData";
			break;
		  default:
				break;
		}
        
        
		//Store Data
		this.storeCacheData(cacheKey,cacheData);
		
		this.DCNotfier.dgConsole("--------------Initial Cache Store-----------");
    }
    
    setCacheConfig(cacheConfig){
		//Initialize Cache Config
		this.cacheConfig=cacheConfig    
    }

    // Store data in the cache
    storeCacheData(cachekey,cacheData) {
    
		//Store in global Variable
		globals.set(cachekey, cacheData);
		
    }

	// Update existing cache data
	async updateCacheData(data, type) {
		try {
		  this.DCNotfier.dgConsole("---------------Updating Cache data-------------");
		  
		  if(type=="rawData"){
			  // Get current cached data
			  const cachedData = globals.get(this.cacheKey+"rawData");
			  
			  // Fix initial time and final time
			  const fixedcachedData = this.fixCacheToTimestamps(cachedData);
			  this.DCNotfier.dgConsole("Initial CacheData: ", fixedcachedData);
			  this.DCNotfier.dgConsole("New Data: ", data);
			  
			  // Sort data
			  let combinedData = [fixedcachedData];
			  combinedData.push(data[0]);
			  
			  // Merge with other data
			  this.cacheRawData = await this.rawDataMerger(combinedData);
			  
			  this.DCNotfier.dgConsole("Merged Data: ", this.cacheRawData);
			  
			  // Store new data
			  this.storeCacheData(this.cacheKey+"rawData",this.cacheRawData);
		  }
		  else if(type=="infoData"){
			 this.DCNotfier.dgConsole("data in infoData")
			 this.DCNotfier.dgConsole(data);
			 // Retrieve existing cache data for key "infoData".
			let checkedCacheData = this.checkCacheData("infoData");
			this.DCNotfier.dgConsole("Existing Data: ");
			this.DCNotfier.dgConsole(checkedCacheData);
			  
			let newCacheData=checkedCacheData;
	
	
			// Find if there's already cache data for this.chartConfigI.chartID
			let foundChartIndex = newCacheData.findIndex(
				(chartObj) => chartObj.chartID === data.chartID
			);
		
			if (foundChartIndex >= 0) {
				// We found a chart object for our chartID. Let's check its Info array.
				let infoArray = newCacheData[foundChartIndex].Info;
		
				//Find if there's already an object with Node === this.nodeI
				let foundNodeIndex = infoArray.findIndex(
					(infoItem) => infoItem.Node === data.Info[0].Node
				);
		
				if (foundNodeIndex >= 0) {
					// If the node exists, update its properties with those of this.DataInfoRTIServer.Info[0]
					infoArray[foundNodeIndex] = {
						...infoArray[foundNodeIndex],
						...data.Info[0],
					};
					this.DCNotfier.dgConsole(
						`Updated existing node ${data.Info[0].Node} in chartID ${data.chartID}`
					);
				} else {
					// If no node found, push a new info object to the array
					infoArray.push(data.Info[0]);
					this.DCNotfier.dgConsole(
						`Added new node ${data.Info[0].Node} to chartID ${data.chartID}`
					);
				}
			} else {
				// If no chart object found for our chartID, create one
				newCacheData.push({
					chartID: data.chartID,
					DataPType:data.DataPType,
					Info: [data.Info[0]],
				});
				this.DCNotfier.dgConsole(
					`Created a new chart object for chartID ${data.chartID} and added node ${data.Info[0].Node}`
				);
			}
			  
			  this.DCNotfier.dgConsole("New Data: ");
			  this.DCNotfier.dgConsole(newCacheData);
			  
			  // Store new data
			  this.storeCacheData(this.cacheKey+"infoData",newCacheData);
		  }
		} 
		
		catch (error) {
		  console.error("Error updating cache data: ", error);
		}
	}
		
	//Query Cache data
	queryCacheData(query,type) {
	
			
			this.DCNotfier.dgConsole("----------Querying Cache-----------");
			this.DCNotfier.dgConsole("CacheDataType: "+type);
		
			if(type=="rawData"){
				
				const cachedData = globals.get(this.cacheKey+"rawData");
				this.DCNotfier.dgConsole("Complete raw cacheData: ")
			    this.DCNotfier.dgConsole(cachedData);
				if (!cachedData) {
					this.DCNotfier.dgConsole("No cache data available.");
					return [];
				}
			
				const dataMap = new Map();
				cachedData.forEach(data => {
					if (!dataMap.has(data.Nodeaddress)) {
						dataMap.set(data.Nodeaddress, []);
					}
					dataMap.get(data.Nodeaddress).push(data);
				});
			
				let results = [];
				query.forEach(q => {
					const initialTime = new Date(q.initialTime).getTime();
					const finalTime = new Date(q.finalTime).getTime();
			
					q.nodes.forEach(node => {
						if (dataMap.has(node)) {
							const nodeData = dataMap.get(node);
							nodeData.forEach(data => {
								const filteredValues = [];
								const filteredStatus = [];
								const filteredTimestamps = [];
			
								let startIdx = this.binarySearch(data.timestamps, initialTime, true);
								let endIdx = this.binarySearch(data.timestamps, finalTime, false);
			
								for (let i = startIdx; i <= endIdx; i++) {
									filteredValues.push(data.Values[i]);
									filteredStatus.push(data.status[i]);
									filteredTimestamps.push(data.timestamps[i]);
								}
			
								if (filteredValues.length > 0) {
									results.push({
										Nodeaddress: node,
										InitialTimeevaluated: q.initialTime,
										FinalTimeevaluated: q.finalTime,
										Values: filteredValues,
										status: filteredStatus,
										timestamps: filteredTimestamps,
										DataSize: filteredValues.length
									});
								}
							});
						}
					});
				});
			
			return results;
		    }		    
		    else if (type === "infoData") {
				const cachedData = globals.get(this.cacheKey + "infoData");
				this.DCNotfier.dgConsole("Complete infoData cacheData alfa: ");
				this.DCNotfier.dgConsole(cachedData);
			
				if (!cachedData ||cachedData.length<=0) {
					this.DCNotfier.dgConsole("No cache data available.");
					return [];
				}
				
				this.DCNotfier.dgConsole("Query: ");
				this.DCNotfier.dgConsole(query);
				
				// Destructure (or directly reference) chartIDs and nodes from the query
				const { chartIDs, nodes } = query;
			
				//Filter the cached data to only include objects whose chartID
				const filteredByChartID = cachedData.filter(item =>
					chartIDs.includes(item.chartID)
				);
			
				// For each matching chart object, filter its 'Info' array
				const results = filteredByChartID
					.map(item => {
						const filteredInfo = item.Info.filter(infoObj =>
							nodes.includes(infoObj.Node)
						);
			
						// Return a new object with the filtered Info array
						return {
							...item,
							Info: filteredInfo
						};
					})
					// Optionally remove chart objects that end up with an empty Info array
					.filter(item => item.Info.length > 0);
			
				return results;
			}
	}
	
	//QueryCacheData
	queryCacheData2(query) {
		this.DCNotfier.dgConsole("----------Querying Cache-----------");
		const cachedData = globals.get(this.cacheKey);
		this.DCNotfier.dgConsole("Complete cacheData: ");
		//this.DCNotfier.dgConsole(cachedData);
		if (!cachedData) {
			this.DCNotfier.dgConsole("No cache data available.");
			return [];
		}
		
		// Extract initial and final times from the query
		const initialTime = new Date(query.initialTime).getTime();
		const finalTime = new Date(query.finalTime).getTime();
		
		// Filter data for the specified node
		const nodeData = cachedData.filter(data => data.Nodeaddress === query.nodes[0]);
		this.DCNotfier.dgConsole("nodeData");
		this.DCNotfier.dgConsole(nodeData);
		if (nodeData.length === 0) {
			this.DCNotfier.dgConsole("No data found for the specified node.");
			return [];
		}
	
		// Find intervals that intersect with the query time range
		const relevantIntervals = nodeData[0].Data.filter(interval => {
			return !(interval.FinalTime < initialTime || interval.InitialTime > finalTime);
		});
	
		if (relevantIntervals.length === 0) {
			this.DCNotfier.dgConsole("No intervals found within the specified time range.");
			return [];
		}
	
		// Reconstruct data from the relevant intervals
		const reconstructedData = this.cacheDataReconstructor([{
			CacheDataType: 'RawDataInIntervals',
			Data: relevantIntervals,
			FinalTimeevaluated: nodeData[0].FinalTimeevaluated,
			InitialTimeevaluated: nodeData[0].InitialTimeevaluated,
			IntervalLength: nodeData[0].IntervalLength,
			Nodeaddress: nodeData[0].Nodeaddress
		}]);
	
		this.DCNotfier.dgConsole("reconstructedData");
		this.DCNotfier.dgConsole(reconstructedData);
		// Filter data to match the query time range
		const filteredResults = reconstructedData.map(data => {
			const startIdx = this.binarySearch(data.timestamps, initialTime, true);
			const endIdx = this.binarySearch(data.timestamps, finalTime, false);
	
			this.DCNotfier.dgConsole("startIdx: ", startIdx);
			this.DCNotfier.dgConsole("endIdx: ", endIdx);
			this.DCNotfier.dgConsole("timestamps: ", data.timestamps);
			this.DCNotfier.dgConsole("initialTime: ", initialTime);
			this.DCNotfier.dgConsole("finalTime: ", finalTime);
	
			return {
				Nodeaddress: data.Nodeaddress,
				InitialTimeevaluated: query.initialTime,
				FinalTimeevaluated: query.finalTime,
				Values: data.Values.slice(startIdx, endIdx + 1),
				status: data.status.slice(startIdx, endIdx + 1),
				timestamps: data.timestamps.slice(startIdx, endIdx + 1),
				DataSize: endIdx - startIdx + 1
			};
		});
	
		return filteredResults;
	}
    
    //Check data available
    checkCacheData(type) {
		if(type=="rawData"){
			this.cachedData = globals.get(this.cacheKey+"rawData"); // Retrieve data from global cache
			
			if (!this.cachedData) {
				this.DCNotfier.dgConsole("No cache data available.");
				return [];
			}		
			// Create an array of structures 
			const formattedData = this.cachedData.map(dataEntry => ({
				Nodeaddress: dataEntry.Nodeaddress,
				initialTimeevaluated: new Date(dataEntry.InitialTimeevaluated).getTime(),
				finalTimeevaluated: new Date(dataEntry.FinalTimeevaluated).getTime()
			}));
	
			return formattedData;
       }
       else if(type=="infoData"){
			this.cachedData = globals.get(this.cacheKey+"infoData"); // Retrieve data from global cache
			
			if (!this.cachedData) {
				this.DCNotfier.dgConsole("No cache data available.");
				return [];
			}	
			
			/*	
			// Create an array of structures 
			const formattedData = this.cachedData.map(dataEntry => ({
				Nodeaddress: dataEntry.Nodeaddress,
				initialTimeevaluated: new Date(dataEntry.InitialTimeevaluated).getTime(),
				finalTimeevaluated: new Date(dataEntry.FinalTimeevaluated).getTime()
			}));
			*/
			
			return this.cachedData;
       }
    }
   
   //Merge data to later store it
    rawDataMerger(dataArrays) {
		try {
			// Exclude empty arrays
			const nonEmptyDataArrays = dataArrays.filter(array => Array.isArray(array) && array.length > 0);
			
			// Validate and organize data
			nonEmptyDataArrays.forEach((array, index) => {
				if (!array[0].hasOwnProperty('InitialTimeevaluated')) {
					console.error(`Invalid data structure at index ${index}:`, array);
					throw new Error(`Invalid data structure at index ${index}`);
					}
			});
			
			// First Organize Data
			nonEmptyDataArrays.sort((a, b) => a[0].InitialTimeevaluated - b[0].InitialTimeevaluated); // Sort by initial time			
			this.DCNotfier.dgConsole("---------CombinedData Updating Cache-------------");
			this.DCNotfier.dgConsole(nonEmptyDataArrays);

			const mergedData = {};
			
			// Flatten the array of arrays structure and process each data entry
			nonEmptyDataArrays.flat(2).forEach((data, index) => {
				if (!data || typeof data !== 'object') {
					console.error(`Invalid data entry at index ${index}:`, data);
					throw new Error(`Invalid data entry at index ${index}`);
				}
				
				const { Nodeaddress, Values, status, timestamps, InitialTimeevaluated, FinalTimeevaluated, DataSize } = data;
				if (!Nodeaddress || !Values || !status || !timestamps || InitialTimeevaluated === undefined || FinalTimeevaluated === undefined || DataSize === undefined) {
					console.error(`Incomplete data entry at index ${index}:`, data);
					throw new Error(`Incomplete data entry at index ${index}`);
				}
				
				const node = Nodeaddress;
				
				if (!mergedData[node]) {
					// Initialize with the first data entry for the node
					mergedData[node] = { ...data };
				} 
				else {
				// Merge subsequent data entries
					mergedData[node].Values = mergedData[node].Values.concat(Values);
					mergedData[node].status = mergedData[node].status.concat(status);
					mergedData[node].timestamps = mergedData[node].timestamps.concat(timestamps);
					mergedData[node].DataSize += DataSize;
					mergedData[node].FinalTimeevaluated = Math.max(
					new Date(mergedData[node].FinalTimeevaluated).getTime(),
					FinalTimeevaluated
					);
					mergedData[node].InitialTimeevaluated = Math.min(
					new Date(mergedData[node].InitialTimeevaluated).getTime(),
					InitialTimeevaluated
					);
				}
			});
			
			// Convert the merged data object back into an array
			return Object.values(mergedData);
		} catch (error) {
			console.error("Error merging raw data: ", error);
			console.error(error.message);
		return []; // Return an empty array or handle the error as needed
		}
	}

	//Clear Cache
	clearCacheData(type){
	
		//Variables to store
		let cacheKey;
		
		switch (type) {
		  case "rawData":
			cacheKey=this.cacheKey+"rawData";
			break;
		  case "processedData":
			cacheKey=this.cacheKey+"processedData";
			break;
		  case "infoData":
			 cacheKey=this.cacheKey+"infoData";
			break;
		  default:
				break;
		}
		
		//Store in global Variable
		globals.set(cacheKey, []);
		
	}
	
	//Prepare Cache data with Intervals
	cacheDataPreparator(rawData, cacheDataType) {
        if (cacheDataType !== "RawDataInIntervals") {
            console.error(`Unsupported cache data type: ${cacheDataType}`);
            return [];
        }

        const intervalLength = this.intervalLength || ONE_HOUR; // Default to one hour if not set

        return rawData.map(dataEntry => {
            const { Nodeaddress, Values, status, timestamps, InitialTimeevaluated, FinalTimeevaluated, DataSize } = dataEntry;

            const startTime = this.roundDate(new Date(InitialTimeevaluated), 'down').getTime();
            const endTimerounded=this.roundDate(new Date(FinalTimeevaluated), 'up').getTime();
            const endTime = endTimerounded+intervalLength;

            const intervals = [];
            let currentStartTime = startTime;
            
			this.DCNotfier.dgConsole("currentStartTime");
			this.DCNotfier.dgConsole(new Date (currentStartTime).toString());
			this.DCNotfier.dgConsole("endTime");
			this.DCNotfier.dgConsole(new Date (endTime).toString());
			
            while (currentStartTime < endTime) {
                const currentEndTime = Math.min(currentStartTime + intervalLength, endTime);
                const intervalData = {
                    InitialTime: currentStartTime,
                    FinalTime: currentEndTime,
                    Values: [],
                    status: [],
                    timestamps: []
                };

                for (let i = 0; i < timestamps.length; i++) {
                    const timestamp = new Date(timestamps[i]).getTime();
                    if (timestamp >= currentStartTime && timestamp < currentEndTime) {
                        intervalData.Values.push(Values[i]);
                        intervalData.status.push(status[i]);
                        intervalData.timestamps.push(timestamp);
                    }
                }

                intervals.push(intervalData);
                currentStartTime = currentEndTime;
            }

            return {
                Nodeaddress,
                InitialTimeevaluated,
                FinalTimeevaluated,
                IntervalLength: intervalLength,
                CacheDataType: cacheDataType,
                Data: intervals
            };
        });
    }
    
    //Reconstruct Cache data
    cacheDataReconstructor(cacheData) {
        return cacheData.map(entry => {
            try {
                switch (entry.CacheDataType) {
                    case 'RawDataInIntervals':
                        const allValues = [];
                        const allStatus = [];
                        const allTimestamps = [];

                        entry.Data.forEach(interval => {
                            allValues.push(...interval.Values);
                            allStatus.push(...interval.status);
                            allTimestamps.push(...interval.timestamps);
                        });

                        return {
                            DataSize: allValues.length,
                            FinalTimeevaluated: entry.FinalTimeevaluated,
                            InitialTimeevaluated: entry.InitialTimeevaluated,
                            Nodeaddress: entry.Nodeaddress,
                            Values: allValues,
                            status: allStatus,
                            timestamps: allTimestamps
                        };

                    // Add more cases for different CacheDataType as needed
                    default:
                        throw new Error(`Unsupported cache data type: ${entry.CacheDataType}`);
                }
            } catch (error) {
                console.error(`Error reconstructing data entry for Nodeaddress ${entry.Nodeaddress}:`, error);
                return {
                    DataSize: 0,
                    FinalTimeevaluated: entry.FinalTimeevaluated,
                    InitialTimeevaluated: entry.InitialTimeevaluated,
                    Nodeaddress: entry.Nodeaddress,
                    Values: [],
                    status: [],
                    timestamps: [],
                    Error: error.message
                };
            }
        });
    }

	
	//----------Auxiliary Functions---------------------//
	//--------------------------------------------------//
	roundDate(date, orientation) {
        const roundedDate = new Date(date);
        roundedDate.setMinutes(0, 0, 0);

        if (orientation === 'down') {
            return roundedDate;
        }

        if (orientation === 'up' && roundedDate.getMinutes() > 0) {
            roundedDate.setHours(roundedDate.getHours() + 1);
        }

        return roundedDate;
    }	
	
	//Fix Cache Timestamps
	fixCacheToTimestamps(dataArray) {
		return dataArray.map(item => ({
			...item,
			InitialTimeevaluated: new Date(item.InitialTimeevaluated).getTime(),
			FinalTimeevaluated: new Date(item.FinalTimeevaluated).getTime()
		}));
	}
	
	//Find intersection of Time intervals
	findTimeIntersection(interval1, interval2) {
		// Extract start and end times from both intervals
		let [start1, end1] = interval1;
		let [start2, end2] = interval2;
	
		// Initialize arrays to store the common and uncommon intervals
		let commonIntervals = [];
		let uncommonIntervals = [];
	
		// Calculate the intersection (common interval)
		let commonStart = Math.max(start1, start2);
		let commonEnd = Math.min(end1, end2);
	
		// There is overlap if the common end is after the common start
		if (commonEnd >= commonStart) {
			commonIntervals.push([commonStart, commonEnd]);
		}
	
		// Calculate the non-overlapping interval for the first interval only
		if (start1 < commonStart) {
			uncommonIntervals.push([start1, commonStart]);
		}
		if (end1 > commonEnd) {
			uncommonIntervals.push([commonEnd, end1]);
		}
	
		// If there's no common interval, the entire first interval is uncommon
		if (commonIntervals.length === 0) {
			uncommonIntervals = [[start1, end1]];
		}
	
		return { commonIntervals, uncommonIntervals };
	}
	
	//Auxiliary Function to increase Cache Performance
	binarySearch(arr, target, findStart) {
		let low = 0;
		let high = arr.length - 1;
		let result = -1;
	
		while (low <= high) {
			const mid = Math.floor((low + high) / 2);
			if (arr[mid] === target) {
				result = mid;
				if (findStart) {
					high = mid - 1;
				} else {
					low = mid + 1;
				}
			} else if (arr[mid] < target) {
				low = mid + 1;
			} else {
				high = mid - 1;
			}
		}
	
		return findStart ? (result === -1 ? low : result) : (result === -1 ? high : result);
	}
}

//---------------Dashboard Creator Class----------------//
//-----------------------------------------------------//
class DashboardDataCreator {
	// Attributes
	dataRequest; // Holds the specifics of the data request
	dashboardData; // Holds processed data ready for the dashboard/Highcharts
	processRequest; // May contain request processing logic or status
	processedData; // Flag or data that indicates the data has been processed
	rawData; // The raw data retrieved based on rawDataRequest
	nodes;

	// Constructor: Initialize Attributes
	constructor(dataRequest) {
		this.replacementString="<_::_>";
		this.dataRequest = JSON.parse(this.handleSpacesDecode( dataRequest));
		this.initialTime = this.dataRequest.updateRequest[0].initialTime;
		this.finalTime =this.dataRequest.updateRequest[0].finalTime;
		this.initialTimeI = this.initialTime;
		this.finalTimeI = this.finalTime;
		this.intervalQuery=2*86400*1000;
		this.dashboardData = null;
		this.processRequest = null;
		this.processedData = false;
		this.nodes=this.rawDataRequestProcessor(this.dataRequest,"nodesRequest"); //Find all Unique Nodes
		this.databaseManager;
		this.databaseRequest=this.rawDataRequestProcessor(this.dataRequest,"databaseRequest")
		this.databaseRequestInfo;
		this.rawDataRequestRTInfo;
		this.rawData = null;
		this.DCNotfier;
		
	}
	

	
	//Initilialize 
	async initialize(dashboardDataProcessor,dashboardDatabaseManager,dashboardCacheManager,dashboardCreatorNotifier) {
		
		try {
			this.databaseManager=dashboardDatabaseManager;
			this.DCNotfier=dashboardCreatorNotifier;
			this.DCNotfier.dgConsole("-----------DataRequest------------");
			this.DCNotfier.dgConsole(this.dataRequest);
			this.DCNotfier.dgConsole("-----------DatabaseRequest------------");
			this.DCNotfier.dgConsole(this.databaseRequest);
					
			this.DCNotfier.dgConsole();		
			this.DCNotfier.dgConsole("------------Operation Mode---------");
			this.DCNotfier.dgConsole(this.dataRequest.updateRequest[0].OperationMode);
			
			//Gets Raw Data History Mode
			if (this.dataRequest.updateRequest[0].OperationMode==="Hist"){
				
				this.rawData = await this.rawDataCreator(dashboardCacheManager);
				this.DCNotfier.dgConsole("-----------Raw Data-----------");
				this.DCNotfier.dgConsole(this.rawData);
				
				
				// Process Data			
				dashboardDataProcessor.initialize(this.dataRequest,this.rawData,dashboardCacheManager);
				const processedData = dashboardDataProcessor.processRequestHandler(this.dataRequest, this.rawData);
				this.DCNotfier.dgConsole("-----------ProcessedData-----------");
				this.DCNotfier.dgConsole(processedData);
		
				//Gives format to data
				this.dashboardData=this.dashboardDataFormater(processedData);
				this.DCNotfier.dgConsole("-----------Final Format Data-----------");
				this.DCNotfier.dgConsole(this.dashboardData);
				
				
				//Sends response to webclient			
				this.dashboardDataWriter();				
				
				
			} 
			
			//Gets Raw Data Real Time Mode
			else if (this.dataRequest.updateRequest[0].OperationMode==="RealTime"){			
				
				//Prepare data required
				this.rawDataRequestRTInfo=this.rawDataRequestProcessor(this.dataRequest,"rawDataRequestRTInfo"); //Find all Unique RT Nodes
				this.DCNotfier.dgConsole("this.rawDataRequestRTInfo");
				this.DCNotfier.dgConsole(this.rawDataRequestRTInfo);
				
				this.rawData = await this.rawDataCreatorRT(dashboardCacheManager);
				this.DCNotfier.dgConsole("-----------Raw Data-----------");
				this.DCNotfier.dgConsole(this.rawData);	
				
				// Process Data			
				dashboardDataProcessor.initialize(this.dataRequest,this.rawData,dashboardCacheManager);
				const processedData = dashboardDataProcessor.processRequestHandler(this.dataRequest, this.rawData);
				this.DCNotfier.dgConsole("-----------ProcessedData-----------");
				this.DCNotfier.dgConsole(processedData);				
				
				//Gives format to data
				this.dashboardData=this.dashboardDataFormater(processedData);
				this.DCNotfier.dgConsole("-----------Final Format Data-----------");
				this.DCNotfier.dgConsole(this.dashboardData);
				
				//Sends response to webclient			
				this.dashboardDataWriter();	
			}			
			
		} catch (error) {
			console.error("An error occurred while processing dashboard data:");
			console.error(error.message);
		}
	}
	
	//-----------------------------------------------//
	//------Data Extraction Functions-----//	
	
	//Creates Data Structure Hist (rawData-Cache handling)
	async rawDataCreator(dashboardCacheManager) {
		
		if(this.dataRequest.updateRequest[0].cacheConfig.CacheEnabled==="false"){ //Dont use Cache Data
			
			this.DCNotfier.dgConsole("----------------Cache Disabled-------------");
			//Clear existing cache
			dashboardCacheManager.clearCacheData("rawData");
			
			//Bring Data
			this.rawData = await this.rawDataRequestExecutor(this.nodes);
			
			return this.rawData;
		} 
		
		
		else{//Use Cache	
			
			//Initialize Cache
			dashboardCacheManager.setCacheConfig(this.dataRequest.updateRequest.cacheConfig);	
			
			// Check Cached Data
			var checkedCacheData = await dashboardCacheManager.checkCacheData("rawData");

			this.DCNotfier.dgConsole("----------------Cache Enabled-------------");					
			//No data already in Cache
			if (checkedCacheData.length === 0) {
				this.rawData = await this.rawDataRequestExecutor(this.nodes);
				this.DCNotfier.dgConsole("Fetched all data due to empty cache.");
				dashboardCacheManager.initialize(this.rawData,"rawData");
				return this.rawData;
			} 	
				
			//Data in Cache
			else {
				// Time Available in Cache
				const cacheInitialTime = new Date(checkedCacheData[0].initialTimeevaluated).getTime();
				const cacheFinalTime = new Date(checkedCacheData[0].finalTimeevaluated).getTime();
				
				// Calculate intervals
				var intervals_intersection = dashboardCacheManager.findTimeIntersection(
					[(new Date(this.initialTime)).getTime(), (new Date(this.finalTime)).getTime()],
					[cacheInitialTime, cacheFinalTime]
				);
				
				this.DCNotfier.dgConsole("Initial time required");
				this.DCNotfier.dgConsole((new Date(this.initialTime)).toString());
				this.DCNotfier.dgConsole("Final time required");
				this.DCNotfier.dgConsole((new Date(this.finalTime)).toString());
				this.DCNotfier.dgConsole("Cached Initial time");
				this.DCNotfier.dgConsole(new Date(cacheInitialTime).toString());
				this.DCNotfier.dgConsole("Cached Final time");
				this.DCNotfier.dgConsole(new Date(cacheFinalTime).toString());
				this.DCNotfier.dgConsole("--------------intervals_intersecction-------------");
				this.DCNotfier.dgConsole("Common Intervals");
				this.DCNotfier.dgConsole(intervals_intersection);			
				
	
				let rawDataFetched = [];
				let cachedDataResults = [];
		
				//------------------Fetch data from the cache-------------------//
				//-------------------Common Intervals--------------------------//
				
				if (intervals_intersection.commonIntervals.length > 0) {
				
					intervals_intersection.commonIntervals.forEach(async interval => {
						let query = {
							nodes: this.nodes,
							initialTime: interval[0],
							finalTime: interval[1]
						};
						
						let commonData = dashboardCacheManager.queryCacheData([query],"rawData");

						cachedDataResults.push(commonData);
					});
					this.DCNotfier.dgConsole("-------------cachedDataResults-----------");
					this.DCNotfier.dgConsole(cachedDataResults[0]);
				
					if(intervals_intersection.uncommonIntervals.length <= 0){ //No Uncommondata
						return cachedDataResults[0];
					}
				}
				
				//Add first cachedDataResults
				let combinedData = [cachedDataResults[0]];	
				let updateTimeRanges=[];
				let timethreshold=28800000;
				
				//------------------Fetch data from the Raw Data-------------------//
				//--------------------Uncommon Intervals--------------------------//
				
				if (intervals_intersection.uncommonIntervals.length > 0) {
					
					for (let i = 0; i < intervals_intersection.uncommonIntervals.length; i++) {
						this.initialTimeI = new Date(intervals_intersection.uncommonIntervals[i][0]).getTime();
						this.finalTimeI = new Date(intervals_intersection.uncommonIntervals[i][1]).getTime();
						let fetchedData = await this.rawDataRequestExecutor(this.nodes);
						rawDataFetched.push(fetchedData);
						
						//Add Upated time Ranges
						updateTimeRanges.push(this.finalTimeI-this.initialTimeI);			
						
						//Add to combined data
						combinedData.push(fetchedData);
						
						
					}
					
					this.DCNotfier.dgConsole("-------------rawDataFetched-----------");
					this.DCNotfier.dgConsole(rawDataFetched);
					
					//---------Update Cache if it has commonIntervals--------------//
					//-------------------------------------------------------------//
					
					if(intervals_intersection.commonIntervals.length > 0 && updateTimeRanges.some(value => value > timethreshold)){ //It has common data
						
						//Update Cache data with Data Requested
						dashboardCacheManager.updateCacheData(rawDataFetched,"rawData");
					}		
					
					//------------------Only Uncommon Intervals---------------------//
					//-------------------------------------------------------------//
					
					else if(intervals_intersection.commonIntervals.length <= 0){ //No Common data
					
						const uncommonIntervalStart = intervals_intersection.uncommonIntervals[0][0];
						
						//Check order
						if (uncommonIntervalStart < cacheInitialTime) {
							// Before tail
							this.initialTimeI = new Date(intervals_intersection.uncommonIntervals[0][1]).getTime();
							this.finalTimeI = cacheInitialTime;
							
							updateTimeRanges.push(this.finalTimeI-this.initialTimeI);
							
						} else {
							// After tail
							this.initialTimeI = cacheFinalTime;
							this.finalTimeI = new Date(intervals_intersection.uncommonIntervals[0][0]).getTime();
							
							updateTimeRanges.push(this.finalTimeI-this.initialTimeI);
						}
						
						//Fit missing data in cache
						 const fetchedDataI = await this.rawDataRequestExecutor(this.nodes);	
						 
						 //Update only if is relevant
						if (updateTimeRanges.some(value => value > timethreshold)) { 					 	 
							dashboardCacheManager.updateCacheData([fetchedDataI],"rawData");
						}
						
						//Only return rawDataFetched
						return rawDataFetched[0];
					}
				}
				
				//---------------Merge Common and Uncommon data-----------------//
				//-------------------------------------------------------------//
				
				let mergedData=dashboardCacheManager.rawDataMerger(combinedData);
				return mergedData;
			}
		}
	}
	
	//Creates Data Structure RT
	async rawDataCreatorRT(dashboardCacheManager) {
        try {			
			

			if (this.rawDataRequestRTInfo.length<=0 && this.databaseRequest?.length <=0){
				this.DCNotfier.dgConsole("No data requested");
				 return [];
			 
			 
			}			
			else{
				var nodesI=new Array();
				this.DCNotfier.dgConsole("Excecuting rawDataCreator:");
				
				// Iterate over each element in rawDataRequestRTInfo
				for (let rtInfo of this.rawDataRequestRTInfo) {
							
					nodesI.push(rtInfo.Nodeaddress)

				} 
				
					this.nodes = nodesI;
					
					let rawDataI= await this.rawDataCreator(dashboardCacheManager);
					
					this.DCNotfier.dgConsole("rawDataI");
					this.DCNotfier.dgConsole(rawDataI);
					
					this.DCNotfier.dgConsole("this.dataRequest");
					this.DCNotfier.dgConsole(this.dataRequest);
					
					//Update DatabaseRTinfo
					let dataRequestUpdated= this.updateDatabaseRTInfo(rawDataI);
					
					this.DCNotfier.dgConsole("this.dataRequest after");
					this.DCNotfier.dgConsole(dataRequestUpdated);
					this.dataRequest=dataRequestUpdated;
								           
				return dataRequestUpdated; // Optionally return the last fetched raw data
            }
        } catch (error) {
            console.error("Error executing rawDataCreatorRT:", error);
            this.DCNotfier.dgConsole(error);
        }
    }	
    
	//Update Information RT LastDataRT
	updateDatabaseRTInfo(rawData) {
	  // Create a deep copy of this.dataRequest to avoid mutation of the original object
	  const updatedDataRequest = JSON.parse(JSON.stringify(this.dataRequest));
	
	  // Iterate through each updateRequest in the copy of this.dataRequest
	  updatedDataRequest.updateRequest.forEach(updateRequestItem => {
		// Find the corresponding chartConfig based on chartID
		const chartConfig = updatedDataRequest.chartsConfig.find(
		  config => config.chartID === updateRequestItem.chartID
		);
		// If the dataSource is "External-Database", proceed to update
		if (chartConfig && chartConfig.dataSource === "External-Database") {
		  // Iterate through each informationRT element in the current updateRequest
		  updateRequestItem.informationRT.forEach(infoRT => {
		  
			// Find the corresponding rawData element based on the Node attribute matching Nodeaddress
			const matchingRawData = rawData.find(
			  rawDataItem => rawDataItem.Nodeaddress === infoRT.Node
			);
			
			// If a matching rawData is found, update LastDataPointRT
			if (matchingRawData) {
			  infoRT.LastDataPointRT = [];
	
			  // If DataSize is greater than 0, update LastDataPointRT based on Values, status, and timestamps
			  if (matchingRawData.DataSize > 0) {
				matchingRawData.Values.forEach((value, index) => {
				  infoRT.LastDataPointRT.push({
					Value: value,
					status: matchingRawData.status[index],
					timestamps: matchingRawData.timestamps[index],
				  });
				});
			  } 
			  else {
				// If DataSize is 0 or less, set a default value for LastDataPointRT
				infoRT.LastDataPointRT=[];
			  }
			}
			else {
					// If te\here is not even a match
					infoRT.LastDataPointRT = [];	
			}		
		  });
		}
	  });
	  // Return the updated copy of this.dataRequest
	  return updatedDataRequest;
	}
	
	// Executes the rawDataRequest 
	async rawDataRequestExecutor(nodes) {
		try {
			let histRawData = [];
			let databaseRawData = [];
			let completeRawData = [];
		
		
			//---------From Historian
			// Execute Historian Request if nodes array is not empty
			if (nodes?.length > 0) {
				histRawData = await this.rawDataHistExecutor(nodes);
				this.DCNotfier.dgConsole("Historian Data Retrieved:");
				this.DCNotfier.dgConsole(histRawData);
				
			} else {
				this.DCNotfier.dgConsole("No nodes provided for Historian Request.");
			}
		
			
			//---------From Database
			// Execute Database Request if there are requests defined
			if (this.databaseRequest?.length > 0) {
				databaseRawData = await this.rawDatabaseExecutor(this.databaseRequest[0]);
				this.DCNotfier.dgConsole("Database Data Retrieved:");
				this.DCNotfier.dgConsole(databaseRawData);
			} else {
				this.DCNotfier.dgConsole("No database request provided.");
			}
	
	
			//Merge
			// Merge historian and database data if both are available, or return whichever is available
			completeRawData = [...(databaseRawData ?? []), ...(histRawData ?? [])];
	
			// Log the combined data for verification
			this.DCNotfier.dgConsole("Combined Raw Data:");
			this.DCNotfier.dgConsole(completeRawData);
			
			return completeRawData.length > 0 ? completeRawData : {};
		} catch (error) {
			// Catch and log any errors from async calls
			console.error("Error in rawDataRequestExecutor:", error);
			this.DCNotfier.dgConsole(error.message)
			return {};
		}
	}
	
	//Hist Request
	rawDataHistExecutor(nodes) {
	
		this.DCNotfier.dgConsole("Initiating queries...");
		const startTime = new Date().getTime();		
		
		const queries = nodes.map(node => this.asyncHistQuery(node));
	
		return Promise.allSettled(queries).then(results => {
			const endTime = new Date().getTime();
			this.DCNotfier.dgConsole(`Total execution time for queries: ${endTime - startTime} milliseconds.`);
			
			// Map each result to include the desired structure along with DataSize
			const structuredResults = results.map((result, index) => {
	
				//When there is data in Historian
				if(result.value.result.length >0){
	
					if (result.status === 'fulfilled' && result.value.result) {
						const values = result.value.result.map(item => item.value);					
						const timestamps = result.value.result.map(item => item.timestamp);
						const statuses = result.value.result.map(item => item.status);
						return {
							Nodeaddress: nodes[index], // Assuming the node address can be directly taken from the nodes array
							InitialTimeevaluated: new Date(this.initialTimeI),  // Include initial time
							FinalTimeevaluated: new Date(this.finalTimeI),  // Include final time
							Values: values,
							timestamps: timestamps,
							status: statuses,
							DataSize: values.length // Add the DataSize key here
						};
					} else {
						console.error(`Error querying data for node ${nodes[index]}:`, result.reason);
						return {
							Nodeaddress: nodes[index],
							InitialTimeevaluated: new Date(this.initialTimeI),  // Include initial time
							FinalTimeevaluated: new Date(this.finalTimeI),  // Include final time
							Values: [],
							timestamps: [],
							status: [],
							DataSize: 0 // DataSize is 0 in case of error
						};
					}
				}
				//When there is no data in Historian
				else if(result.value.result.length <=0){
					this.DCNotfier.dgConsole("No data found in historian");
					const currentValue=this.readCurrentValue(nodes[index]);					
						return {
							Nodeaddress: nodes[index],
							InitialTimeevaluated: new Date(this.initialTimeI),  // Include initial time
							FinalTimeevaluated: new Date(this.finalTimeI),  // Include final time
							Values: [currentValue.Values],
							timestamps: [new Date(currentValue.timestamps).getTime()],
							status: [currentValue.status],
							DataSize: 0 // DataSize is 0 in case of error
						};
				}
			});
			
			return structuredResults;
		});
	
	}
	
	//Performs HistQuery
	async asyncHistQuery(node) {
		const initialTime = new Date(this.initialTimeI);
		const finalTime = new Date(this.finalTimeI);
		const intervalQuery = this.intervalQuery || 3600 * 1000; // Default to 1 hour if not set
	
		// Break the time range into smaller intervals
		let currentStartTime = initialTime.getTime();
		let allValues = [];
	
		while (currentStartTime < finalTime.getTime()) {
			let currentEndTime = Math.min(currentStartTime + intervalQuery, finalTime.getTime());
	
			const filter = {
				type: ["v:1"], // Example type, adjust based on actual requirements
				timestamp: [`n:>=${currentStartTime}<${currentEndTime}`],
				address: [`g:${node}`]
			};
	
			this.DCNotfier.dgConsole("-----------Query filter-------------");
			this.DCNotfier.dgConsole(filter);
			this.DCNotfier.dgConsole("Initial time query");
			this.DCNotfier.dgConsole(new Date(currentStartTime).toString());
			this.DCNotfier.dgConsole("Final time query");
			this.DCNotfier.dgConsole(new Date(currentEndTime).toString());
	
			try {
				let continuationPoint = null;
				let hasMoreData = true;
	
				while (hasMoreData) {
					const options = {
						continuationpoint: continuationPoint,
						timeout: 3600 // Set a timeout of 1 hour
					};
	
					// Wrap the history.query in a promise to use with await
					const result = await new Promise((resolve, reject) => {
						try {
							const queryResult = history.query(filter, options);
							this.DCNotfier.dgConsole("result size: ");
							this.DCNotfier.dgConsole(queryResult.result.length);
							resolve(queryResult);
						} catch (error) {
							reject(error);
						}
					});
	
					if (result.error) {
						throw new Error(result.error.message);
					}
	
					// Concatenate the result array
					allValues = allValues.concat(result.result);
	
					if (result.continuationpoint) {
						continuationPoint = result.continuationpoint;
					} else {
						hasMoreData = false;
					}
				}
			} catch (error) {
				console.error(`Error querying data for node ${node}:`, error);
				return [{
					status: "rejected",
					reason: error.message
				}];
			}
	
			currentStartTime = currentEndTime;
		}
	
		// After collecting all results, format them correctly
		return {
			
				More: false,
				continuationpoint: 0,
				result: allValues
			
		};
	}
	
	//Performs Current Value Read
    readCurrentValue(node) {
        try {
            // Find the node
            var nodeI = Ua.findNode(node);

            // Check if the node result is properly defined
            if (nodeI?.result) {
                // Extract and return the desired object
                const output = {
                    Values: nodeI.result.value,
                    timestamps: nodeI.result.sourceTime?.value,
                    status: nodeI.result.status?.value,
                };
                return output;
            } else {
                console.error(`Node result is undefined or missing required fields for node ${node}.`);
                return null;
            }
        } catch (error) {
            // Handle and log any errors that occur
            console.error(`Error reading current value for node ${node}:`, error);
            return null;
        }
    }
	
	//Database Request
	async rawDatabaseExecutor(databaseRequest) {
		try {
			
			// Initialize the database manager with the provided database request
			this.databaseManager.initialize(databaseRequest.databaseConnectionParameters,this.DCNotfier);
			
			
			// Execute the basic read to get the partial data from the database
			const partialDatabaseData = await this.databaseManager.basicRead();
			this.DCNotfier.dgConsole("partialDatabaseData");
			this.DCNotfier.dgConsole(partialDatabaseData);
	
			this.DCNotfier.dgConsole("databaseRequest");
			this.DCNotfier.dgConsole(databaseRequest);
			// Destructure the relevant data from partialDatabaseData
			const { queryAnswer, readingColumns } = partialDatabaseData;
			const columnTypes = databaseRequest.databaseConnectionParameters.readingParameters.columnTypes;
			const timeColumn = databaseRequest.databaseConnectionParameters.timeParameters.timeColumn;
			const finalTime = databaseRequest.databaseConnectionParameters.timeParameters.finalTime;
			const initialTime = databaseRequest.databaseConnectionParameters.timeParameters.initialTime;
			const timeFormat = databaseRequest.databaseConnectionParameters.timeParameters.timeFormat;
	
			// Check if the time filter was successful
			const timeFilterSuccess = (readingColumns[0] === timeColumn);
	
			// Log if time filter succeeded
			this.DCNotfier.dgConsole("Time filter success:");
			this.DCNotfier.dgConsole(timeFilterSuccess);
			
			this.DCNotfier.dgConsole("readingColumns");
			this.DCNotfier.dgConsole(readingColumns);
			
			this.DCNotfier.dgConsole("columnTypes");
			this.DCNotfier.dgConsole(columnTypes);
			
			// Initialize the result structure
			const formattedData = readingColumns.map((columnName, columnIndex) => {
				// Extract values for this column across all rows in queryAnswer
				const readingColumnType = columnTypes[columnIndex];
				const timestampIndex = readingColumnType == "Time" ? columnIndex : 0;
				const values = queryAnswer.map(row => parseFloat(row[columnIndex]));
				const dataSize = values.length;
				const timestamps = timeFilterSuccess
					? queryAnswer.map(row => this.parseTimestamp(row[timestampIndex], timeFormat))
					: Array(dataSize).fill(0);
	
				// Return the structured data for each column
				return {
					DataSize: dataSize,
					FinalTimeevaluated: finalTime,
					InitialTimeevaluated: initialTime,
					Nodeaddress: columnName,
					Values: values,
					status: Array(dataSize).fill(0), // Default status array
					timestamps: timestamps
				};
			});
	
			return formattedData;
		} catch (error) {
			console.error("Error in rawDatabaseExecutor:", error);

		}
	}
	
	
	//-----------------------------------------------//
	//------Data Sending Functions-----//	
		
	// Gives final format to data
	dashboardDataFormater(processedData) {
		let chartsData = [];
		let errors = [];
	
		try {
			// First, validate that processedData is an array
			if (!Array.isArray(processedData)) {
				errors.push("processedData is not an array or is undefined.");
				// Early return if there's nothing to process
				return {
					chartsData: [],
					Errors: errors
				};
			}
	
			processedData.forEach(chart => {
				// Wrap each chart's processing in a separate try-catch to isolate failures
				try {
	
					// Basic validation
					if (!chart.chartID) {
						errors.push("Chart is missing chartID. Skipping this chart.");
						return; // Skip this chart; move to next
					}
					if (!chart.elementType) {
						errors.push(`Chart with ID ${chart.chartID} is missing elementType. Skipping this chart.`);
						return;
					}
					if (!chart.processedDataStruct || !Array.isArray(chart.processedDataStruct) || chart.processedDataStruct.length === 0) {
						errors.push(`Chart with ID ${chart.chartID} has no valid processedDataStruct. Skipping this chart.`);
						return;
					}
	
					// Pack InformationRT and Tooltip Info
					let informationRT = chart.processedDataStruct.map((dataStruct) => {
						if (!dataStruct.informationRT) {
							errors.push(`Chart with ID ${chart.chartID} missing dataStruct.informationRT field.`);
							// Instead of returning null or skipping, we still return an empty string or some fallback
							return "";
						}
						return dataStruct.informationRT;
					});
	
					let tooltipInfo = chart.processedDataStruct.map((dataStruct) => {
						if (!dataStruct.tooltipInfo) {
							errors.push(`Chart with ID ${chart.chartID} missing dataStruct.tooltipInfo field.`);
							return "";
						}
						return dataStruct.tooltipInfo;
					});
	
					let chartData = {
						chartID: chart.chartID,
						informationRT: informationRT,
						tooltipInfo: tooltipInfo,
						chartSeries: [],
						LimitDashboardData: [],
						chartCategories: chart.processedDataStruct[0]?.chartCategories || []
					};
	
					// Check if elementType is "Chart"
					if (chart.elementType === "Chart") {
						// Validate chartType
						if (!chart.chartType) {
							errors.push(`chartType is missing for chartID ${chart.chartID}. Skipping this chart.`);
							return;
						}
						
						switch (chart.chartType) {
							case "Line":
							case "Spline":
							case "Area":
							case "Column":
							case "Bar":
								// For these types, each processedDataStruct item becomes a series
								chart.processedDataStruct.forEach((dataStruct, k) => {
									try {
										const seriesName = dataStruct.processedNode || `Unnamed_Series_${k}`;
										const chartID = chart.chartID;
	
										// Validate processedDataI
										if (!dataStruct.processedDataI || !Array.isArray(dataStruct.processedDataI)) {
											errors.push(`Chart with ID ${chart.chartID} and seriesName ${seriesName} has invalid processedDataI.`);
											return;
										}
	
										// Build the main series
										let series = {
											name: seriesName,
											data: dataStruct.processedDataI.map((dataPoint, i) => {
												if (chart.categoryType === "AllData-DateTime") {
													const category = chartData.chartCategories.find(c => c.chartNode === dataStruct.processedNode);
													// If the category is missing, note an error
													if (!category) {
														errors.push(`Missing chartNode category for seriesName "${seriesName}" in chartID ${chart.chartID}.`);
														return dataPoint;
													} else {
														return [category.categories[i], dataPoint];
													}
												} else {
													return dataPoint;
												}
											})
										};
	
										// Build the limit series if enabled
										let limitAnalysisEnabledI = dataStruct.LimitDashboardData?.filteredData?.Enabled === true;
										let seriesLimint = {};
										if (limitAnalysisEnabledI) {
											if (chart.categoryType === "AllData-DateTime") {
												if (!dataStruct.LimitDashboardData.filteredData?.Values || 
													!dataStruct.LimitDashboardData.filteredData?.timestamps) {
													errors.push(`LimitDashboardData is missing Values or timestamps for chartID ${chart.chartID}, seriesName ${seriesName}.`);
												} else {
													seriesLimint = {
														name: seriesName + "_Limit",
														data: dataStruct.LimitDashboardData.filteredData.Values.map((dataPoint, i) => {
															const category = dataStruct.LimitDashboardData.filteredData.timestamps[i];
															return [category, dataPoint];
														})
													};
												}
	
												// Conditional Max/Min Limit Plot Creation
												const maxPlotExists = chartData.LimitDashboardData.some(
													s => s && s.name && s.name.endsWith("_MaxLimPlot")
												);
												if (!maxPlotExists && dataStruct.LimitDashboardData?.plotLimitData?.MaxLimitTrendData?.Values?.length > 0) {
													let maxTrendTimestamps = dataStruct.LimitDashboardData.plotLimitData.MaxLimitTrendData.timestamps;
													if (!maxTrendTimestamps) {
														errors.push(`MaxLimitTrendData is missing timestamps in chartID ${chart.chartID}.`);
													} else {
														let seriesMaxLimitPlot = {
															name: chartID + "_MaxLimPlot",
															data: dataStruct.LimitDashboardData.plotLimitData.MaxLimitTrendData.Values.map((val, i) => {
																const category = maxTrendTimestamps[i];
																return [category, val];
															})
														};
														chartData.LimitDashboardData.push(seriesMaxLimitPlot);
													}
												}
	
												const minPlotExists = chartData.LimitDashboardData.some(
													s => s && s.name && s.name.endsWith("_MinLimPlot")
												);
												if (!minPlotExists && dataStruct.LimitDashboardData?.plotLimitData?.MinLimitTrendData?.Values?.length > 0) {
													let minTrendTimestamps = dataStruct.LimitDashboardData.plotLimitData.MinLimitTrendData.timestamps;
													if (!minTrendTimestamps) {
														errors.push(`MinLimitTrendData is missing timestamps in chartID ${chart.chartID}.`);
													} else {
														let seriesMinLimitPlot = {
															name: chartID + "_MinLimPlot",
															data: dataStruct.LimitDashboardData.plotLimitData.MinLimitTrendData.Values.map((val, i) => {
																const category = minTrendTimestamps[i];
																return [category, val];
															})
														};
														chartData.LimitDashboardData.push(seriesMinLimitPlot);
													}
												}
	
											} else if (chart.categoryType.includes("Interval")) {
												if (!Array.isArray(dataStruct.LimitDashboardData.filteredData.Values)) {
													errors.push(`LimitDashboardData.filteredData.Values is invalid for chartID ${chart.chartID}, seriesName ${seriesName}.`);
												} else {
													seriesLimint = {
														name: seriesName + "_Limit",
														data: dataStruct.LimitDashboardData.filteredData.Values
													};
												}
											}
										}
	
										chartData.chartSeries.push(series);
										chartData.LimitDashboardData.push(seriesLimint);
									} catch (seriesError) {
										errors.push(`Error processing series for chartID ${chart.chartID}: ${seriesError.message}`);
									}
								});
								break;
	
							case "Pie":
							case "Pyramid":
								// For Pie/Pyramid, use processedDataI directly as the series data
								try {
									let seriesData = chart.processedDataStruct.map((dataStruct, idx) => {
										if (!dataStruct.processedDataI || !Array.isArray(dataStruct.processedDataI)) {
											errors.push(`ChartID ${chart.chartID} (Pie/Pyramid) has invalid processedDataI on item index ${idx}.`);
											return { name: dataStruct.processedNode || `Unnamed_Series_${idx}`, y: 0 };
										}
										return {
											name: dataStruct.processedNode || `Unnamed_Series_${idx}`,
											y: dataStruct.processedDataI[0] || 0
										};
									});
									chartData.chartSeries.push({ name: "Aggregate", data: seriesData });
								} catch (pieError) {
									errors.push(`Error processing Pie/Pyramid chart for chartID ${chart.chartID}: ${pieError.message}`);
								}
								break;
	
							case "Gauge":
							case "Solidgauge":
								// Use the last value of processedDataI
								try {
									if (chart.processedDataStruct.length > 0) {
										let lastDataStruct = chart.processedDataStruct[chart.processedDataStruct.length - 1];
										if (!lastDataStruct.processedDataI || !Array.isArray(lastDataStruct.processedDataI)) {
											errors.push(`ChartID ${chart.chartID} (Gauge) has invalid processedDataI on lastDataStruct.`);
										} else {
											let gaugeData = {
												name: lastDataStruct.processedNode || "Unnamed_Gauge",
												data: [lastDataStruct.processedDataI[lastDataStruct.processedDataI.length - 1]]
											};
											chartData.chartSeries.push(gaugeData);
										}
									}
								} catch (gaugeError) {
									errors.push(`Error processing Gauge for chartID ${chart.chartID}: ${gaugeError.message}`);
								}
								break;
	
							case "Histogram":
								try {
									if (chart.processedDataStruct[0]) {
										const seriesName = chart.processedDataStruct[0].processedNode || "Histogram_Series";
										if (!chart.processedDataStruct[0].processedDataI ||
											!Array.isArray(chart.processedDataStruct[0].processedDataI)) {
											errors.push(`ChartID ${chart.chartID} has invalid processedDataI for Histogram.`);
										} else {
											const scatterData = chart.processedDataStruct[0].processedDataI.map(dataPoint => dataPoint);
											chartData.chartSeries.push({
												name: seriesName,
												type: 'scatter',
												data: scatterData,
											});
										}
									}
								} catch (histError) {
									errors.push(`Error processing Histogram for chartID ${chart.chartID}: ${histError.message}`);
								}
								break;
	
							default:
								errors.push(`Unsupported chartType: ${chart.chartType} for chartID ${chart.chartID}`);
						} // end switch
	
					} else if (chart.elementType === "Table") {
						// For Table elements
						try {
							let tableSeriesData = [];
							let seriesNames = [];
	
							chart.processedDataStruct.forEach((dataStruct) => {
								seriesNames.push(dataStruct.processedNode || "Unnamed_Table_Node");
								if (!dataStruct.processedDataI || !Array.isArray(dataStruct.processedDataI)) {
									errors.push(`ChartID ${chart.chartID} (Table) has invalid processedDataI.`);
								} else {
									dataStruct.processedDataI.forEach((dataPoint, index) => {
										if (!tableSeriesData[index]) {
											tableSeriesData[index] = [];
										}
										tableSeriesData[index].push(dataPoint);
									});
								}
							});
	
							var tableSeries = {
								name: seriesNames.join(", "),
								data: tableSeriesData
							};
	
							// Make sure rows are consistent in length
							const fields = tableSeries.name.split(",").map(f => f.trim());
							const expectedCount = fields.length;
	
							tableSeries.data = tableSeries.data.filter(item => item.length === expectedCount);
	
							chartData.chartSeries = (tableSeries);
						} catch (tableError) {
							errors.push(`Error processing Table for chartID ${chart.chartID}: ${tableError.message}`);
						}
	
					} else if (chart.elementType === "Number") {
						// For Number elements
						try {
							if (chart.processedDataStruct.length > 0) {
								let lastDataStruct = chart.processedDataStruct[chart.processedDataStruct.length - 1];
								if (!lastDataStruct.processedDataI || !Array.isArray(lastDataStruct.processedDataI)) {
									errors.push(`ChartID ${chart.chartID} (Number) has invalid processedDataI on lastDataStruct.`);
								} else {
									let gaugeData = {
										name: lastDataStruct.processedNode || "Unnamed_Number",
										data: [lastDataStruct.processedDataI[lastDataStruct.processedDataI.length - 1]]
									};
									chartData.chartSeries.push(gaugeData);
	
									// If there is LimitDashboardData add it
									let limitAnalysisEnabledI = lastDataStruct?.LimitDashboardData?.filteredData?.Enabled;
									if (limitAnalysisEnabledI) {
										if (chart.categoryType && chart.categoryType.includes("Single")) {
											if (!Array.isArray(lastDataStruct.LimitDashboardData.filteredData.Values)) {
												errors.push(`ChartID ${chart.chartID} (Number) has invalid filteredData.Values for limit data.`);
											} else {
												let seriesLimint = {
													name: lastDataStruct.processedNode + "_Limit",
													data: lastDataStruct.LimitDashboardData.filteredData.Values,
												};
												chartData.LimitDashboardData.push(seriesLimint);
											}
										}
									}
								}
							}
						} catch (numError) {
							errors.push(`Error processing Number element for chartID ${chart.chartID}: ${numError.message}`);
						}
	
					} else {
						// Unknown element type
						errors.push(`Unsupported elementType: ${chart.elementType} for chartID ${chart.chartID}`);
					}
	
					chartsData.push(chartData);
	
				} catch (chartError) {
					// Catch any unexpected errors in processing this chart
					errors.push(`Error processing chart with ID ${chart.chartID}: ${chartError.message}`);
				}
			});
	
		} catch (error) {
			// Catch any higher-level error in the entire function
			errors.push(`Error processing data: ${error.message}`);
		}
	
		return {
			chartsData: chartsData,
			Errors: errors
		};
	}

	
	//Writes back to Menu
	dashboardDataWriter() {
		// Assuming this function is part of a class that has access to this.dataRequest and this.dashboardData
		if (this.dashboardData) {
			 Parameters.response.setHeader("Content-Type", "application");
			 Parameters.response.write(JSON.stringify(this.dashboardData), "");
			}
		else {
			Parameters.response.setHeader("Content-Type", "application");
			Parameters.response.write("Error creating Dashboard Data", "");
			this.DCNotfier.dgConsole("Single data request is not set to true.");
		}
	}
	
	//-----------------------------------------------//
	//-------------Auxiliary Functions--------------//
	
	//Extract specific info from the rawDataRequest 
	rawDataRequestProcessor(dataRequest, infoRequired) {
		switch (infoRequired) {
			case "nodesRequest":
				const dataRequestI = dataRequest.chartsNodes;
				const chartConfigI=dataRequest.chartsConfig;
				const uniqueNodes = new Set();
				dataRequestI.forEach((chart, i)  => {
					if (dataRequest.chartsConfig [i].dataSource =="Internal-Historian"){
						chart.chartNodes.forEach(node => uniqueNodes.add(node));
					}
				});
				return Array.from(uniqueNodes);
	
			case "rawDataRequestRTInfo":
				const rtInfo = [];
				
				dataRequest.updateRequest.forEach((request,index) => {
					this.DCNotfier.dgConsole(dataRequest.chartsConfig[index].dataSource);
					if (dataRequest.chartsConfig[index].dataSource=="Internal-Historian"){
						request.informationRT.forEach(info => {
							if (info.AllDataRequired) {
								rtInfo.push({
									Nodeaddress: info.Node,
									finalTime: info.IntervalInfo.end,
									initialTime: info.IntervalInfo.start
								});
							}
						});
					}
				});
				return rtInfo;
	
			case "databaseRequest":
				const databaseRequestConfigMap = new Map();
	
				dataRequest.chartsConfig.forEach((config, i) => {
					if (config.dataSource === "External-Database") {
						const chartID = config.chartID;
						const databaseParams = config.specialParameters.Database;
						const columnTypes = config.specialParameters.TableConfig.DataColumnTypes;
						const chartNodes = dataRequest.chartsNodes.find(node => node.chartID === chartID).chartNodes;
						const updateRequest = dataRequest.updateRequest.find(update => update.chartID === chartID);
	
						// Generate a unique key for this configuration
						const key = [
							databaseParams.DatabaseType,
							databaseParams.Driver,
							databaseParams.Server,
							databaseParams.Database,
							databaseParams.User,
							databaseParams.Password,
							databaseParams.TableName,
							databaseParams.TimeColumn,
							databaseParams.TimeFormat,
							chartNodes.join(","), 
							updateRequest.finalTime,
							updateRequest.initialTime
						].join("|");
	
						// Check if configuration with this key already exists
						if (databaseRequestConfigMap.has(key)) {
							// Add chartID to the existing configurations chartID array
							databaseRequestConfigMap.get(key).databaseConnectionParameters.chartID.push(chartID);
						} else {
							// Create a new configuration entry with chartID as an array
							databaseRequestConfigMap.set(key, {
								databaseConnectionParameters: {
									chartID: [chartID],
									connectionParameters: {
										customConnectionString: "",
										databaseType: databaseParams.DatabaseType,
										driver: databaseParams.Driver,
										server: databaseParams.Server,
										database: databaseParams.Database,
										user: databaseParams.User,
										password: databaseParams.Password,
										tableName: databaseParams.TableName
									},
									readingParameters: {
										readingColumns: chartNodes,	
										columnTypes: columnTypes									
									},
									timeParameters: {
										finalTime: new Date(updateRequest.finalTime),
										initialTime: new Date(updateRequest.initialTime),
										timeColumn: databaseParams.TimeColumn,
										timeFormat: databaseParams.TimeFormat
									}
								}
							});
						}
					}
				});	
	
				// Convert Map values to an array and return
				return Array.from(databaseRequestConfigMap.values());
	
			default:
				console.error(`Unknown infoRequired type: ${infoRequired}`);
				return null;
		}
	}
	
	//Handle Spaces
	handleSpacesDecode(string) {
		if (this.replacementString === undefined) {
			console.error("replacementString is not defined.");
			return string; // Return original string if replacementString is not defined
		}
		return string.replaceAll(this.replacementString, " ");
	}
	
	//Parse Timestamps
	parseTimestamp(timestampString, format) {
		const formatParts = format.split(/[- :.[\]]+/);
		const dateParts = timestampString.split(/[- :.[\]]+/);
		
	
		const dateComponents = {
			YYYY: 1970,
			MM: 1,
			DD: 1,
			hh: 0,
			mm: 0,
			ss: 0,
			fff: 0,
			ffffff: 0,
			fffffffff: 0
		};
	
		// Map each part of the date according to the format
		formatParts.forEach((part, index) => {
			if (dateComponents.hasOwnProperty(part)) {
				dateComponents[part] = parseInt(dateParts[index], 10);
			}
		});
		
		// If microseconds (ffffff) are present, convert them to milliseconds
		if (dateComponents.ffffff && dateComponents.ffffff > 0) {
			// Convert microseconds (e.g. 126200) to milliseconds (126)
			const fractionalMs = Math.floor(dateComponents.ffffff / 1000);
			dateComponents.fff = fractionalMs;
		}
	
		const date = new Date(
			dateComponents.YYYY,
			dateComponents.MM - 1,
			dateComponents.DD,
			dateComponents.hh,
			dateComponents.mm,
			dateComponents.ss,
			dateComponents.fff
		);
	
		return date.getTime();
	}
	
}

//---------------Dashboard Database Manager----------------//
//-----------------------------------------------------//
class DashboardDatabaseManager {

    constructor(databaseRequest) {
        this.odbcClient = null;
		this.connectionStatus = null;
		
        this.databaseConnParameters;
        this.connectionParameters;
        this.connectionString;
       
        this.tableName;
        this.writingParameters;
        this.readingParameters;
        this.timeParameters;
        this.readingColumns;
    
         
        this.sqlQuery = '';
        this.queryAnswer = null;
        this.searchParte = "";
        this.columns = "";
        this.queryFilter;
        this.foundErrors;
        
        //Custom
        this.existConflict=false;
        this.textConfilct="";
        this.DCNotfier;
    }

	initialize (databaseRequest,dashboardCreatorNotifier){

		//Initialize Notifier
		this.DCNotfier=dashboardCreatorNotifier;
		
		this.DCNotfier.dgConsole("databaseRequest passed.....")
		this.DCNotfier.dgConsole(databaseRequest)
		
		//Initialize Parameters
		this.databaseConnParameters=databaseRequest;
        this.connectionParameters=this.databaseConnParameters.connectionParameters;

        this.connectionString =(this.databaseConnParameters.connectionParameters.customConnectionString==undefined || this.databaseConnParameters.connectionParameters.customConnectionString<=0) ? this.createOdbcConnectionString():this.databaseConnParameters.connectionParameters.customConnectionString;
       
        this.tableName = this.databaseConnParameters.connectionParameters.tableName;
        this.writingParameters = this.databaseConnParameters.writingParameters;
        this.readingParameters= this.databaseConnParameters.readingParameters;
        this.timeParameters=this.databaseConnParameters.timeParameters;
        this.readingColumns=this.readingParameters.readingColumns;
        
        
	 }
	 
	 
    basicWrite() {
        // Create Query
       // this.createQuery("INSERT");
        this.DCNotfier.dgConsole("-------------------Insert Query--------------");
        this.DCNotfier.dgConsole(this.sqlQuery);

        // Open Connection
        this.openConnection();
        this.DCNotfier.dgConsole("-------------------Connection Status--------------");
        this.DCNotfier.dgConsole(this.connectionStatus);
		
        // Write to Database
        this.writeToDatabase();
        //this.DCNotfier.dgConsole("-------------------Query Answer--------------");
        this.DCNotfier.dgConsole(this.queryAnswer);
        
        // Create Select Query
        this.createQuery("SELECT");
		this.DCNotfier.dgConsole("-------------------Select Query--------------");
        this.DCNotfier.dgConsole(this.sqlQuery);
        
        //Read from Database
         this.readFromDatabase();
        this.DCNotfier.dgConsole("-------------------Query Answer--------------");
        this.DCNotfier.dgConsole(this.queryAnswer);
        
        // Close Connection
       this.closeConnection();
    }
    
    async basicRead() {      
		
		this.DCNotfier.dgConsole("Initial Time");
		this.DCNotfier.dgConsole(new Date(this.timeParameters.initialTime).toLocaleString());
		this.DCNotfier.dgConsole("Final Time");
		this.DCNotfier.dgConsole(new Date(this.timeParameters.finalTime).toLocaleString());
		
				
        // Open Connection
        this.openConnection();
        this.DCNotfier.dgConsole("-------------------Connection Status--------------");
        this.DCNotfier.dgConsole(this.connectionStatus);
        
		 //Create time Filter
        this.createTimeFilter();
        this.DCNotfier.dgConsole("-------------------Query Filter--------------");
        this.DCNotfier.dgConsole(this.queryFilter);
        
       // Create Query
       this.createQuery("SHOW COLUMNS");
        this.DCNotfier.dgConsole("-------------------Show Query--------------");
        this.DCNotfier.dgConsole(this.sqlQuery);
        
		//Check Existing Columns
		await this.checkExistingColumns();        
		this.DCNotfier.dgConsole("-------------------Cheking Columns--------------");
        this.DCNotfier.dgConsole(this.foundErrors);       
        
        // Create Query
       this.createQuery("SELECT");
        this.DCNotfier.dgConsole("-------------------Select Query--------------");
        this.DCNotfier.dgConsole(this.sqlQuery);
        
        //Read from Database
        await this.readFromDatabase();
        this.DCNotfier.dgConsole("-------------------Query Answer--------------");
        this.DCNotfier.dgConsole(this.queryAnswer);
        
        // Close Connection
       this.closeConnection();
       
       return  ({queryAnswer: this.queryAnswer, readingColumns: this.readingColumns});
    }
    
    advancedWrite() {
    
		// Create Select Query
        this.createQuery("SELECT");
		this.DCNotfier.dgConsole("-------------------Select Query--------------");
        this.DCNotfier.dgConsole(this.sqlQuery);
        
          // Open Connection
        this.openConnection();
        this.DCNotfier.dgConsole("-------------------Connection Status--------------");
        this.DCNotfier.dgConsole(this.connectionStatus);
        
        //Read from Database
         this.readFromDatabase();
        this.DCNotfier.dgConsole("-------------------Query Answer--------------");
        this.DCNotfier.dgConsole(this.queryAnswer);
        
        //Check Confliict
        this.checkConflict();
        
        if(!this.existConflict){
			// Create Query
			this.createQuery("INSERT");
			this.DCNotfier.dgConsole("-------------------Insert Query--------------");
			this.DCNotfier.dgConsole(this.sqlQuery);
			
			// Write to Database
			this.writeToDatabase();
			//this.DCNotfier.dgConsole("-------------------Query Answer--------------");
			this.DCNotfier.dgConsole(this.queryAnswer);      
			
			return "The record was written succesfully";  
        }
        
        else {
			this.DCNotfier.dgConsole(this.textConfilct);
			return this.textConfilct;
        }
       // Close Connection
       this.closeConnection();
    
    }

    openConnection() {
		try {
			this.DCNotfier.dgConsole("this.connectionString");
			this.DCNotfier.dgConsole(this.connectionString);
			// Create ODBC Object
			this.odbcClient = new ODBCClient();
			this.odbcClient.source = this.connectionString;
	
			// Open Connection
			this.connectionStatus = this.odbcClient.open();
	
			// Check if the connection was successful
			if (!this.connectionStatus) {
				throw new Error("Failed to open connection: Connection status returned false.");
			}
			
			this.DCNotfier.dgConsole("Connection opened successfully.");
		} catch (error) {
			// Log error and set connection status to false
			console.error("Error opening connection:", error.message);
			this.connectionStatus = false;
	
			// Optionally, set an error message attribute or take further action
			this.errorMessage = `Connection Error: ${error.message}`;
		}
	}
    
    closeConnection(){
		this.odbcClient.close();
     }

	/****************CREATE QUERY FUNCTION**************/
	
   createQuery(type) {
		this.columns = this.readingColumns.join(', ');
	
		switch (this.connectionParameters.databaseType.toUpperCase()) {
			case "MSSQL":
				if (type === "INSERT") {
					const values = Object.values(this.writingParameters)
						.map(value => value.includes("FROM_UNIXTIME") ? `${value}` : `'${value}'`)
						.join(', ');
					this.sqlQuery = `INSERT INTO ${this.tableName} (${this.columns}) VALUES (${values});`;
				} else if (type === "SELECT") {
					this.sqlQuery = this.queryFilter
						? `SELECT ${this.columns} FROM ${this.tableName} WHERE ${this.queryFilter};`
						: `SELECT ${this.columns} FROM ${this.tableName};`;
				} else if (type === "SHOW COLUMNS") {
					this.sqlQuery = `SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = '${this.tableName}';`;
				}
				break;
	
			case "MYSQL":
				if (type === "INSERT") {
					const values = Object.values(this.writingParameters)
						.map(value => value.includes("FROM_UNIXTIME") ? `${value}` : `'${value}'`)
						.join(', ');
					this.sqlQuery = `INSERT INTO ${this.tableName} (${this.columns}) VALUES (${values});`;
				} else if (type === "SELECT") {
					this.sqlQuery = this.queryFilter
						? `SELECT ${this.columns} FROM ${this.tableName} WHERE ${this.queryFilter};`
						: `SELECT ${this.columns} FROM ${this.tableName};`;
				} else if (type === "SHOW COLUMNS") {
					this.sqlQuery = `SHOW COLUMNS FROM ${this.tableName};`;
				}
				break;
	
			case "ORACLE":
				if (type === "INSERT") {
					const values = Object.values(this.writingParameters)
						.map(value => value.includes("FROM_UNIXTIME") ? `${value}` : `'${value}'`)
						.join(', ');
					this.sqlQuery = `INSERT INTO ${this.tableName} (${this.columns}) VALUES (${values})`;
				} else if (type === "SELECT") {
					this.sqlQuery = this.queryFilter
						? `SELECT ${this.columns} FROM ${this.tableName} WHERE ${this.queryFilter}`
						: `SELECT ${this.columns} FROM ${this.tableName}`;
				} else if (type === "SHOW COLUMNS") {
					this.sqlQuery = `SELECT column_name FROM all_tab_columns WHERE table_name = UPPER('${this.tableName}')`;
				}
				break;
	
			case "POSTGRESQL":
				if (type === "INSERT") {
					const values = Object.values(this.writingParameters)
						.map(value => value.includes("FROM_UNIXTIME") ? `${value}` : `'${value}'`)
						.join(', ');
					this.sqlQuery = `INSERT INTO ${this.tableName} (${this.columns}) VALUES (${values})`;
				} else if (type === "SELECT") {
					this.sqlQuery = this.queryFilter
						? `SELECT ${this.columns} FROM ${this.tableName} WHERE ${this.queryFilter}`
						: `SELECT ${this.columns} FROM ${this.tableName}`;
				} else if (type === "SHOW COLUMNS") {
					this.sqlQuery = `SELECT column_name FROM information_schema.columns WHERE table_name = '${this.tableName}';`;
				}
				break;
	
			case "SQLITE":
				if (type === "INSERT") {
					const values = Object.values(this.writingParameters)
						.map(value => value.includes("FROM_UNIXTIME") ? `${value}` : `'${value}'`)
						.join(', ');
					this.sqlQuery = `INSERT INTO ${this.tableName} (${this.columns}) VALUES (${values})`;
				} else if (type === "SELECT") {
					this.sqlQuery = this.queryFilter
						? `SELECT ${this.columns} FROM ${this.tableName} WHERE ${this.queryFilter}`
						: `SELECT ${this.columns} FROM ${this.tableName}`;
				} else if (type === "SHOW COLUMNS") {
					this.sqlQuery = `PRAGMA table_info(${this.tableName});`;
				}
				break;
	
			case "DB2":
				if (type === "INSERT") {
					const values = Object.values(this.writingParameters)
						.map(value => value.includes("FROM_UNIXTIME") ? `${value}` : `'${value}'`)
						.join(', ');
					this.sqlQuery = `INSERT INTO ${this.tableName} (${this.columns}) VALUES (${values})`;
				} else if (type === "SELECT") {
					this.sqlQuery = this.queryFilter
						? `SELECT ${this.columns} FROM ${this.tableName} WHERE ${this.queryFilter}`
						: `SELECT ${this.columns} FROM ${this.tableName}`;
				} else if (type === "SHOW COLUMNS") {
					this.sqlQuery = `SELECT COLNAME FROM SYSCAT.COLUMNS WHERE TABNAME = UPPER('${this.tableName}')`;
				}
				break;
	
			default:
				throw new Error(`Unsupported database type: ${this.connectionParameters.databaseType}`);
		}
	}
	
    
    createFilter(filterType) {
		// Initialize the filter query part
		let filter = '';
		const { initialTime, finalTime, timeColumn } = this.timeParameters;
		this.DCNotfier.dgConsole("Excecuting create Filter..................")
		// Format the initial and final times
		const formattedInitialTime = this.formatTimestamp(new Date(initialTime));
		const formattedFinalTime = this.formatTimestamp(new Date(finalTime));
	    this.DCNotfier.dgConsole("After formatted filter..................")
	    
		if (filterType === "timeQuery") {
			switch (this.connectionParameters.databaseType.toUpperCase()) {
				case "MSSQL":
					filter = `${timeColumn} BETWEEN CONVERT(DATETIME, '${formattedInitialTime}', 120) AND CONVERT(DATETIME, '${formattedFinalTime}', 120)`;
					break;
	
				case "MYSQL":
					filter = `${timeColumn} BETWEEN STR_TO_DATE('${formattedInitialTime}', '%Y-%m-%d %H:%i:%s') AND STR_TO_DATE('${formattedFinalTime}', '%Y-%m-%d %H:%i:%s')`;
					break;
	
				case "ORACLE":
					filter = `${timeColumn} BETWEEN TO_DATE('${formattedInitialTime}', 'YYYY-MM-DD HH24:MI:SS') AND TO_DATE('${formattedFinalTime}', 'YYYY-MM-DD HH24:MI:SS')`;
					break;
	
				case "POSTGRESQL":
					filter = `${timeColumn} BETWEEN TO_TIMESTAMP('${formattedInitialTime}', 'YYYY-MM-DD HH24:MI:SS') AND TO_TIMESTAMP('${formattedFinalTime}', 'YYYY-MM-DD HH24:MI:SS')`;
					break;
	
				case "SQLITE":
					filter = `${timeColumn} BETWEEN datetime('${formattedInitialTime}') AND datetime('${formattedFinalTime}')`;
					break;
	
				case "DB2":
					filter = `${timeColumn} BETWEEN TIMESTAMP('${formattedInitialTime}') AND TIMESTAMP('${formattedFinalTime}')`;
					break;
	
				default:
					throw new Error(`Unsupported database type: ${this.connectionParameters.databaseType}`);
			}
	
			// Store filter for use in query
			return filter;			
		} else {
			throw new Error(`Unsupported filter type: ${filterType}`);
		}
	}
	
	
	createTimeFilter() {
		
		// Add time column
		this.timeColumnAdd() 
		
		const { initialTime, finalTime, timeColumn } = this.timeParameters;
	
		// Check if time parameters are valid (not undefined or empty strings)
		if (initialTime && finalTime && timeColumn) {
			// Call createFilter with "timeQuery" to generate the WHERE clause
			this.queryFilter = this.createFilter("timeQuery");
		} else {
			// If parameters are invalid, set queryFilter to null or an empty string
			this.queryFilter = null;
			this.DCNotfier.dgConsole("Error: Time parameters are not properly set.");
		}
	}
    
    readFromDatabase() {
        this.DCNotfier.dgConsole("Reading from database");

        // Connection Successful
        if (this.connectionStatus) {
            try {
                this.queryAnswer = this.odbcClient.query(this.sqlQuery);
                return this.queryAnswer;
            } catch (exp) {
                this.DCNotfier.dgConsole(exp);
                if (exp.message.indexOf('No Data') > -1)
                    return 0; // no data found

                return undefined;
            }
        } else {
            // Connection Failed
            this.DCNotfier.dgConsole("Error opening ODBC");
            return undefined;
        }
    }

    writeToDatabase() {
		
        // Connection Successful
        if (this.connectionStatus) {
            try {
                this.queryAnswer = this.odbcClient.query(this.sqlQuery);
                return this.queryAnswer;
            } catch (exp) {
                this.DCNotfier.dgConsole(exp);
               if (exp.message.indexOf('No Data') > -1)
                    return 0; // ok

                return undefined;
            } 
        } else {
            // Connection Failedection
            this.DCNotfier.dgConsole("Error opening ODBC");
            return undefined;
        }

    }
    
    /****************CONFLICT PREVENTION**************/
    
    checkConflict(){
    }

	checkExistingColumns() {
        this.foundErrors = []; // Initialize or reset foundErrors
        
        // Query the database to get columns in `this.tableName`
        const columnResult = this.readFromDatabase(); // Assuming this returns an array of column names        
            
        //Special Case for SQLLite
        if(this.connectionParameters.databaseType.toUpperCase()=="SQLITE"){
			columnResult=columnResult.map(innerArray => [innerArray[1]]);
        }
		
        // Create a set of existing columns for fast lookup
        const existingColumns = columnResult.map(col => col[0]); // 'Field' should match the column name key in your result
		
        // Check each column in readingColumns
        this.readingColumns = this.readingColumns.filter(column => {
            if (!existingColumns.includes(column)) {
                this.foundErrors.push(`Column '${column}' does not exist in database`);
                return false; // Exclude column if it doesn't exist in database
            }
            return true; // Keep column if it exists
        });
    }    
    
    //Create ODBC String
    createOdbcConnectionString() {
		
		
		// Ensure the required `dbType` and `driver` are provided
		if (!this.connectionParameters.databaseType || !this.connectionParameters.driver) {
			throw new Error("Database type ('dbType') and driver are required parameters.");
		}
		
		// Initialize base string with driver info
		let connectionString = `Driver={${this.connectionParameters.driver}};`;
	
		// Database-specific configurations
		switch (this.connectionParameters.databaseType.toUpperCase()) {
			case "MSSQL":
				if (!this.connectionParameters.server || !this.connectionParameters.database || !this.connectionParameters.user || !this.connectionParameters.password) {
					throw new Error("MSSQL requires server, database, uid, and pwd.");
				}
				connectionString += `Server=${this.connectionParameters.server};Database=${this.connectionParameters.database};UID=${this.connectionParameters.user};PWD=${this.connectionParameters.password};`;
				break;
			
			case "MYSQL":
				if (!this.connectionParameters.server || !this.connectionParameters.database || !this.connectionParameters.user || !this.connectionParameters.password) {
					throw new Error("MySQL requires server, database, uid, and pwd.");
				}
				connectionString += `Server=${this.connectionParameters.server};Database=${this.connectionParameters.database};User=${this.connectionParameters.user};Password=${this.connectionParameters.password};`;
				break;
			
			case "ORACLE":
				if (!this.connectionParameters.server || !this.connectionParameters.user || !this.connectionParameters.password) {
					throw new Error("Oracle requires server, uid, and pwd.");
				}
				connectionString += `DBQ=${this.connectionParameters.server};UID=${this.connectionParameters.user};PWD=${this.connectionParameters.password};`;
				break;
			
			case "POSTGRESQL":
				if (!this.connectionParameters.server || !this.connectionParameters.database || !this.connectionParameters.user || !this.connectionParameters.password) {
					throw new Error("PostgreSQL requires server, database, uid, and pwd.");
				}
				connectionString += `Server=${this.connectionParameters.server};Database=${this.connectionParameters.database};UID=${this.connectionParameters.user};PWD=${this.connectionParameters.password};`;
				break;
			
			case "SQLITE":
				if (!this.connectionParameters.database) {
					throw new Error("SQLite requires a database file path as 'database'.");
				}
				connectionString += `Database=${this.connectionParameters.database};`;
				break;
			
			case "DB2":
				if (!this.connectionParameters.database || !this.connectionParameters.user || !this.connectionParameters.password) {
					throw new Error("DB2 requires database, uid, and pwd.");
				}
				connectionString += `Database=${this.connectionParameters.database};UID=${this.connectionParameters.user};PWD=${this.connectionParameters.password};`;
				if (this.connectionParameters.server) {
					connectionString += `Hostname=${this.connectionParameters.server};`; // Optional for DB2
				}
				break;
	
			default:
				throw new Error(`Unsupported database type: ${this.connectionParameters.databaseType}`);
		}
	
		return connectionString;
	}
	
	// Function to convert Unix timestamp to specified format
    formatTimestamp(date) {
		// Ensure the date is a Date object
		if (!(date instanceof Date)) {
			this.DCNotfier.dgConsole("Excecuting here")
			throw new Error("The parameter must be a Date object.");
		}
		
		
	
		// Extract components
		const YYYY = date.getFullYear();
		const MM = String(date.getMonth() + 1).padStart(2, '0');
		const DD = String(date.getDate()).padStart(2, '0');
		const hh = String(date.getHours()).padStart(2, '0');
		const mm = String(date.getMinutes()).padStart(2, '0');
		const ss = String(date.getSeconds()).padStart(2, '0');
		const fff = String(date.getMilliseconds()).padStart(3, '0');
		const ffffff = fff + "000".slice(0, 3); // Extend to six digits if needed
		const fffffffff = fff + "000000".slice(0, 6); // Extend to nine digits if needed
	
		// Format based on this.timeFormat
		switch (this.timeParameters.timeFormat) {
			case 'YYYY-MM-DD hh:mm:ss.fff':
				return `${YYYY}-${MM}-${DD} ${hh}:${mm}:${ss}.${fff}`;
			case 'YYYY-MM-DD hh:mm:ss':
				return `${YYYY}-${MM}-${DD} ${hh}:${mm}:${ss}`;
			case 'YYYY-MM-DD':
				return `${YYYY}-${MM}-${DD}`;
			case 'hh:mm:ss':
				return `${hh}:${mm}:${ss}`;
			case 'YYYY-MM-DD hh:mm:ss.ffffff':
				return `${YYYY}-${MM}-${DD} ${hh}:${mm}:${ss}.${ffffff}`;
			case 'YYYY-MM-DD hh:mm:ss.fffffffff':
				return `${YYYY}-${MM}-${DD} ${hh}:${mm}:${ss}.${fffffffff}`;
			case 'YYYY-MM-DD hh:mm:ss[.ffffff]':
				return `${YYYY}-${MM}-${DD} ${hh}:${mm}:${ss}.${ffffff}`;
			case 'YYYY-MM-DD hh:mm:ss[.ff]':
				return `${YYYY}-${MM}-${DD} ${hh}:${mm}:${ss}.${fff.slice(0, 2)}`;
			case 'YYYY-MM-DD hh:mm:ss.ffffff':
				return `${YYYY}-${MM}-${DD} ${hh}:${mm}:${ss}.${ffffff}`;
			default:
				throw new Error(`Unsupported format: ${this.timeParameters.timeFormat}`);
		}
	}

	timeColumnAdd() {
		const timeColumn = this.databaseConnParameters.timeParameters.timeColumn;
		const index = this.readingColumns.indexOf(timeColumn);
	
		if (index !== -1) {
			// Remove the time column from its current position
			this.readingColumns.splice(index, 1);
		}
		
		// Add the time column to the beginning of the array
		this.readingColumns.unshift(timeColumn);
	}
	
}

//---------------Dashboard Creator Notifier----------------//
//-----------------------------------------------------//
class DashboardCreatorNotifier {

	constructor(dataRequest) {	
		this.debuggingEnabled=	(JSON.parse(dataRequest).updateRequest[0].DbgE);
	}
		
	dgConsole(message){
		if (this.debuggingEnabled){
			console.log(message);
		}
	}
}


//Create Dashboard Notifier used by DashboardDataCreator
const dashboardCreatorNotifier1 = new DashboardCreatorNotifier(dataRequest);

//Create Dashboard Notifier used by DashboardDataCreator
const dashboardDatabaseManager1 = new DashboardDatabaseManager();


//Create Dashboard Processor used by DashboardDataCreator
const dashboardDataProcessor1 = new dashboardDataProcessor(dashboardCreatorNotifier1);

//Create Dashboard Cache Manager used by DashboardDataCreator
const dashboardCacheManager1 = new DashboardCacheManager(dashboardCreatorNotifier1,dataRequest);

//Create Dashboard Data Creator
const dashboardDataCreator1 = new DashboardDataCreator(dataRequest);

//Create and Send Dashboard data
dashboardDataCreator1.initialize(dashboardDataProcessor1,dashboardDatabaseManager1,dashboardCacheManager1,dashboardCreatorNotifier1);]]></code>
</script>
